<!DOCTYPE html>
<!-- saved from url=(0031)http://localhost:8080/ui/source -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>unknown cpu</title>
  
<style type="text/css">
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
html, body {
  height: 100%;
}
body {
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  font-size: 13px;
  line-height: 1.4;
  display: flex;
  flex-direction: column;
}
a {
  color: #2a66d9;
}
.header {
  display: flex;
  align-items: center;
  height: 44px;
  min-height: 44px;
  background-color: #eee;
  color: #212121;
  padding: 0 1rem;
}
.header > div {
  margin: 0 0.125em;
}
.header .title h1 {
  font-size: 1.75em;
  margin-right: 1rem;
}
.header .title a {
  color: #212121;
  text-decoration: none;
}
.header .title a:hover {
  text-decoration: underline;
}
.header .description {
  width: 100%;
  text-align: right;
  white-space: nowrap;
}
@media screen and (max-width: 799px) {
  .header input {
    display: none;
  }
}
#detailsbox {
  display: none;
  z-index: 1;
  position: fixed;
  top: 40px;
  right: 20px;
  background-color: #ffffff;
  box-shadow: 0 1px 5px rgba(0,0,0,.3);
  line-height: 24px;
  padding: 1em;
  text-align: left;
}
.header input {
  background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' style='pointer-events:none;display:block;width:100%25;height:100%25;fill:#757575'%3E%3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61.0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E") no-repeat 4px center/20px 20px;
  border: 1px solid #d1d2d3;
  border-radius: 2px 0 0 2px;
  padding: 0.25em;
  padding-left: 28px;
  margin-left: 1em;
  font-family: 'Roboto', 'Noto', sans-serif;
  font-size: 1em;
  line-height: 24px;
  color: #212121;
}
.downArrow {
  border-top: .36em solid #ccc;
  border-left: .36em solid transparent;
  border-right: .36em solid transparent;
  margin-bottom: .05em;
  margin-left: .5em;
  transition: border-top-color 200ms;
}
.menu-item {
  height: 100%;
  text-transform: uppercase;
  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  position: relative;
}
.menu-item .menu-name:hover {
  opacity: 0.75;
}
.menu-item .menu-name:hover .downArrow {
  border-top-color: #666;
}
.menu-name {
  height: 100%;
  padding: 0 0.5em;
  display: flex;
  align-items: center;
  justify-content: center;
}
.submenu {
  display: none;
  z-index: 1;
  margin-top: -4px;
  min-width: 10em;
  position: absolute;
  left: 0px;
  background-color: white;
  box-shadow: 0 1px 5px rgba(0,0,0,.3);
  font-size: 100%;
  text-transform: none;
}
.menu-item, .submenu {
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
}
.submenu hr {
  border: 0;
  border-top: 2px solid #eee;
}
.submenu a {
  display: block;
  padding: .5em 1em;
  text-decoration: none;
}
.submenu a:hover, .submenu a.active {
  color: white;
  background-color: #6b82d6;
}
.submenu a.disabled {
  color: gray;
  pointer-events: none;
}

#content {
  overflow-y: scroll;
  padding: 1em;
}
#top {
  overflow-y: scroll;
}
#graph {
  overflow: hidden;
}
#graph svg {
  width: 100%;
  height: auto;
  padding: 10px;
}
#content.source .filename {
  margin-top: 0;
  margin-bottom: 1em;
  font-size: 120%;
}
#content.source pre {
  margin-bottom: 3em;
}
table {
  border-spacing: 0px;
  width: 100%;
  padding-bottom: 1em;
  white-space: nowrap;
}
table thead {
  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
}
table tr th {
  background-color: #ddd;
  text-align: right;
  padding: .3em .5em;
}
table tr td {
  padding: .3em .5em;
  text-align: right;
}
#top table tr th:nth-child(6),
#top table tr th:nth-child(7),
#top table tr td:nth-child(6),
#top table tr td:nth-child(7) {
  text-align: left;
}
#top table tr td:nth-child(6) {
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}
#flathdr1, #flathdr2, #cumhdr1, #cumhdr2, #namehdr {
  cursor: ns-resize;
}
.hilite {
  background-color: #ebf5fb;
  font-weight: bold;
}
</style>

  <style type="text/css">
body {
font-family: sans-serif;
}
h1 {
  font-size: 1.5em;
  margin-bottom: 4px;
}
.legend {
  font-size: 1.25em;
}
.line, .nop, .unimportant {
  color: #aaaaaa;
}
.inlinesrc {
  color: #000066;
}
.deadsrc {
cursor: pointer;
}
.deadsrc:hover {
background-color: #eeeeee;
}
.livesrc {
color: #0000ff;
cursor: pointer;
}
.livesrc:hover {
background-color: #eeeeee;
}
.asm {
color: #008800;
display: none;
}
</style>
  <script type="text/javascript">
function pprof_toggle_asm(e) {
  var target;
  if (!e) e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;

  if (target) {
    var asm = target.nextSibling;
    if (asm && asm.className == "asm") {
      asm.style.display = (asm.style.display == "block" ? "" : "block");
      e.preventDefault();
      return false;
    }
  }
}
</script>
</head>
<body>
  
<div class="header">
  <div class="title">
    <h1><a href="http://localhost:8080/ui/">pprof</a></h1>
  </div>

  <div id="view" class="menu-item">
    <div class="menu-name">
      View
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      <a title="Outputs top entries in text form" href="http://localhost:8080/ui/top" id="topbtn">Top</a>
      <a title="Display profile as a directed graph" href="http://localhost:8080/ui/" id="graphbtn">Graph</a>
      <a title="" href="http://localhost:8080/ui/flamegraph" id="flamegraph">Flame Graph</a>
      <a title="Output callers/callees of functions matching regexp" href="http://localhost:8080/ui/peek" id="peek">Peek</a>
      <a title="Output annotated source for functions matching regexp" href="http://localhost:8080/ui/source" id="list">Source</a>
      <a title="Output assembly listings annotated with samples" href="http://localhost:8080/ui/disasm" id="disasm">Disassemble</a>
    </div>
  </div>

  
  
  <div id="sample" class="menu-item">
    <div class="menu-name">
      Sample
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      
      <a href="http://localhost:8080/ui/source?si=samples" id="samples">samples</a>
      
      <a href="http://localhost:8080/ui/source?si=cpu" id="cpu">cpu</a>
      
    </div>
  </div>
  

  <div id="refine" class="menu-item">
    <div class="menu-name">
      Refine
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      <a title="Restricts to samples going through a node matching regexp
Discard samples that do not include a node matching this regexp.
Matching includes the function name, filename or object name.
" href="http://localhost:8080/ui/source?" id="focus" class="disabled">Focus</a>
      <a title="Skips paths going through any nodes matching regexp
If set, discard samples that include a node matching this regexp.
Matching includes the function name, filename or object name.
" href="http://localhost:8080/ui/source?" id="ignore" class="disabled">Ignore</a>
      <a title="Skips nodes matching regexp
Discard nodes that match this location.
Other nodes from samples that include this location will be shown.
Matching includes the function name, filename or object name.
" href="http://localhost:8080/ui/source?" id="hide" class="disabled">Hide</a>
      <a title="Only show nodes matching regexp
If set, only show nodes that match this location.
Matching includes the function name, filename or object name.
" href="http://localhost:8080/ui/source?" id="show" class="disabled">Show</a>
      <a title="Drops functions above the highest matched frame.
If set, all frames above the highest match are dropped from every sample.
Matching includes the function name, filename or object name.
" href="http://localhost:8080/ui/source?" id="show-from" class="disabled">Show from</a>
      <hr>
      <a title="Show the entire profile" href="http://localhost:8080/ui/source?">Reset</a>
    </div>
  </div>

  <div>
    <input id="search" type="text" placeholder="Search regexp" autocomplete="off" autocapitalize="none" size="40">
  </div>

  <div class="description">
    <a title="Show information about the profile and this view" href="http://localhost:8080/ui/source#" id="details">unknown cpu</a>
    <div id="detailsbox">
      <div>Type: cpu</div><div>Time: Mar 22, 2019 at 5:19pm (CST)</div><div>Duration: 30.14s, Total samples = 12.51s (41.50%)</div>
    </div>
  </div>
</div>

<div id="errors"></div>

  <div id="content" class="source">
    <h2>runtime.cgocall</h2><p class="filename">C:\blockchainenv\Go\src\runtime\cgocall.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       3.78s      3.81s (flat, cum) 30.46%
<span class="line">    123</span> <span class="nop">           .          .           	// </span>
<span class="line">    124</span> <span class="nop">           .          .           	// fn may call back into Go code, in which case we'll exit the </span>
<span class="line">    125</span> <span class="nop">           .          .           	// "system call", run the Go code (which may grow the stack), </span>
<span class="line">    126</span> <span class="nop">           .          .           	// and then re-enter the "system call" reusing the PC and SP </span>
<span class="line">    127</span> <span class="nop">           .          .           	// saved by entersyscall here. </span>
<span class="line">    128</span> <span class="nop">        10ms       20ms           	entersyscall() </span>
<span class="line">    129</span> <span class="nop">           .          .            </span>
<span class="line">    130</span> <span class="nop">       3.77s      3.77s           	mp.incgo = true </span>
<span class="line">    131</span> <span class="nop">           .          .           	errno := asmcgocall(fn, arg) </span>
<span class="line">    132</span> <span class="nop">           .          .            </span>
<span class="line">    133</span> <span class="nop">           .          .           	// Update accounting before exitsyscall because exitsyscall may </span>
<span class="line">    134</span> <span class="nop">           .          .           	// reschedule us on to a different M. </span>
<span class="line">    135</span> <span class="nop">           .          .           	mp.incgo = false </span>
<span class="line">    136</span> <span class="nop">           .          .           	mp.ncgo-- </span>
<span class="line">    137</span> <span class="nop">           .          .            </span>
<span class="line">    138</span> <span class="nop">           .       20ms           	exitsyscall() </span>
<span class="line">    139</span> <span class="nop">           .          .            </span>
<span class="line">    140</span> <span class="nop">           .          .           	// Note that raceacquire must be called only after exitsyscall has </span>
<span class="line">    141</span> <span class="nop">           .          .           	// wired this M to a P. </span>
<span class="line">    142</span> <span class="nop">           .          .           	if raceenabled { </span>
<span class="line">    143</span> <span class="nop">           .          .           		raceacquire(unsafe.Pointer(&amp;racecgosync)) </span>
</pre>
<h2>compress/flate.(*decompressor).huffSym</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\inflate.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       1.10s      1.74s (flat, cum) 13.91%
<span class="line">    702</span> <span class="nop">           .          .           	f.nb += 8 </span>
<span class="line">    703</span> <span class="nop">           .          .           	return nil </span>
<span class="line">    704</span> <span class="nop">           .          .           } </span>
<span class="line">    705</span> <span class="nop">           .          .            </span>
<span class="line">    706</span> <span class="nop">           .          .           // Read the next Huffman-encoded symbol from f according to h. </span>
<span class="line">    707</span> <span class="nop">       190ms      200ms           func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) { </span>
<span class="line">    708</span> <span class="nop">           .          .           	// Since a huffmanDecoder can be empty or be composed of a degenerate tree </span>
<span class="line">    709</span> <span class="nop">           .          .           	// with single element, huffSym must error on these two edge cases. In both </span>
<span class="line">    710</span> <span class="nop">           .          .           	// cases, the chunks slice will be 0 for the invalid sequence, leading it </span>
<span class="line">    711</span> <span class="nop">           .          .           	// satisfy the n == 0 check below. </span>
<span class="line">    712</span> <span class="nop">        30ms       30ms           	n := uint(h.min) </span>
<span class="line">    713</span> <span class="nop">           .          .           	// Optimization. Compiler isn't smart enough to keep f.b,f.nb in registers, </span>
<span class="line">    714</span> <span class="nop">           .          .           	// but is smart enough to keep local variables in registers, so use nb and b, </span>
<span class="line">    715</span> <span class="nop">           .          .           	// inline call to moreBits and reassign b,nb back to f on return. </span>
<span class="line">    716</span> <span class="nop">        10ms       10ms           	nb, b := f.nb, f.b </span>
<span class="line">    717</span> <span class="nop">        10ms       10ms           	for { </span>
<span class="line">    718</span> <span class="nop">        30ms       30ms           		for nb &lt; n { </span>
<span class="line">    719</span> <span class="nop">        80ms      710ms           			c, err := f.r.ReadByte() </span>
<span class="line">    720</span> <span class="nop">           .          .           			if err != nil { </span>
<span class="line">    721</span> <span class="nop">           .          .           				f.b = b </span>
<span class="line">    722</span> <span class="nop">           .          .           				f.nb = nb </span>
<span class="line">    723</span> <span class="nop">           .          .           				return 0, noEOF(err) </span>
<span class="line">    724</span> <span class="nop">           .          .           			} </span>
<span class="line">    725</span> <span class="nop">        20ms       20ms           			f.roffset++ </span>
<span class="line">    726</span> <span class="nop">       120ms      120ms           			b |= uint32(c) &lt;&lt; (nb &amp; 31) </span>
<span class="line">    727</span> <span class="nop">           .          .           			nb += 8 </span>
<span class="line">    728</span> <span class="nop">           .          .           		} </span>
<span class="line">    729</span> <span class="nop">        40ms       40ms           		chunk := h.chunks[b&amp;(huffmanNumChunks-1)] </span>
<span class="line">    730</span> <span class="nop">       180ms      180ms           		n = uint(chunk &amp; huffmanCountMask) </span>
<span class="line">    731</span> <span class="nop">       120ms      120ms           		if n &gt; huffmanChunkBits { </span>
<span class="line">    732</span> <span class="nop">        40ms       40ms           			chunk = h.links[chunk&gt;&gt;huffmanValueShift][(b&gt;&gt;huffmanChunkBits)&amp;h.linkMask] </span>
<span class="line">    733</span> <span class="nop">        20ms       20ms           			n = uint(chunk &amp; huffmanCountMask) </span>
<span class="line">    734</span> <span class="nop">           .          .           		} </span>
<span class="line">    735</span> <span class="nop">        10ms       10ms           		if n &lt;= nb { </span>
<span class="line">    736</span> <span class="nop">        10ms       10ms           			if n == 0 { </span>
<span class="line">    737</span> <span class="nop">           .          .           				f.b = b </span>
<span class="line">    738</span> <span class="nop">           .          .           				f.nb = nb </span>
<span class="line">    739</span> <span class="nop">           .          .           				f.err = CorruptInputError(f.roffset) </span>
<span class="line">    740</span> <span class="nop">           .          .           				return 0, f.err </span>
<span class="line">    741</span> <span class="nop">           .          .           			} </span>
<span class="line">    742</span> <span class="nop">        30ms       30ms           			f.b = b &gt;&gt; (n &amp; 31) </span>
<span class="line">    743</span> <span class="nop">        10ms       10ms           			f.nb = nb - n </span>
<span class="line">    744</span> <span class="nop">       150ms      150ms           			return int(chunk &gt;&gt; huffmanValueShift), nil </span>
<span class="line">    745</span> <span class="nop">           .          .           		} </span>
<span class="line">    746</span> <span class="nop">           .          .           	} </span>
<span class="line">    747</span> <span class="nop">           .          .           } </span>
<span class="line">    748</span> <span class="nop">           .          .            </span>
<span class="line">    749</span> <span class="nop">           .          .           func makeReader(r io.Reader) Reader { </span>
</pre>
<h2>bufio.(*Reader).ReadByte</h2><p class="filename">C:\blockchainenv\Go\src\bufio\bufio.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       580ms      770ms (flat, cum)  6.16%
<span class="line">    238</span> <span class="nop">           .          .           	return n, nil </span>
<span class="line">    239</span> <span class="nop">           .          .           } </span>
<span class="line">    240</span> <span class="nop">           .          .            </span>
<span class="line">    241</span> <span class="nop">           .          .           // ReadByte reads and returns a single byte. </span>
<span class="line">    242</span> <span class="nop">           .          .           // If no byte is available, returns an error. </span>
<span class="line">    243</span> <span class="nop">       280ms      280ms           func (b *Reader) ReadByte() (byte, error) { </span>
<span class="line">    244</span> <span class="nop">        10ms       10ms           	b.lastRuneSize = -1 </span>
<span class="line">    245</span> <span class="nop">        40ms       40ms           	for b.r == b.w { </span>
<span class="line">    246</span> <span class="nop">           .          .           		if b.err != nil { </span>
<span class="line">    247</span> <span class="nop">           .          .           			return 0, b.readErr() </span>
<span class="line">    248</span> <span class="nop">           .          .           		} </span>
<span class="line">    249</span> <span class="nop">           .      190ms           		b.fill() // buffer is empty </span>
<span class="line">    250</span> <span class="nop">           .          .           	} </span>
<span class="line">    251</span> <span class="nop">        80ms       80ms           	c := b.buf[b.r] </span>
<span class="line">    252</span> <span class="nop">        40ms       40ms           	b.r++ </span>
<span class="line">    253</span> <span class="nop">           .          .           	b.lastByte = int(c) </span>
<span class="line">    254</span> <span class="nop">       130ms      130ms           	return c, nil </span>
<span class="line">    255</span> <span class="nop">           .          .           } </span>
<span class="line">    256</span> <span class="nop">           .          .            </span>
<span class="line">    257</span> <span class="nop">           .          .           // UnreadByte unreads the last byte. Only the most recently read byte can be unread. </span>
<span class="line">    258</span> <span class="nop">           .          .           // </span>
<span class="line">    259</span> <span class="nop">           .          .           // UnreadByte returns an error if the most recent method called on the </span>
</pre>
<h2>vendor/golang.org/x/text/encoding/unicode.utf8Decoder.Transform</h2><p class="filename">C:\blockchainenv\githubProj\go-crawler\src\vendor\golang.org\x\text\encoding\unicode\unicode.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       480ms      500ms (flat, cum)  4.00%
<span class="line">     48</span> <span class="nop">           .          .           	if len(dst) &lt; n { </span>
<span class="line">     49</span> <span class="nop">           .          .           		err = transform.ErrShortDst </span>
<span class="line">     50</span> <span class="nop">           .          .           		n = len(dst) </span>
<span class="line">     51</span> <span class="nop">           .          .           		atEOF = false </span>
<span class="line">     52</span> <span class="nop">           .          .           	} </span>
<span class="line">     53</span> <span class="nop">       120ms      120ms           	for nSrc &lt; n { </span>
<span class="line">     54</span> <span class="nop">        10ms       10ms           		c := src[nSrc] </span>
<span class="line">     55</span> <span class="nop">        20ms       20ms           		if c &lt; utf8.RuneSelf { </span>
<span class="line">     56</span> <span class="nop">        80ms       80ms           			nSrc++ </span>
<span class="line">     57</span> <span class="nop">        10ms       10ms           			continue </span>
<span class="line">     58</span> <span class="nop">           .          .           		} </span>
<span class="line">     59</span> <span class="nop">        10ms       10ms           		first := utf8internal.First[c] </span>
<span class="line">     60</span> <span class="nop">           .          .           		size := int(first &amp; utf8internal.SizeMask) </span>
<span class="line">     61</span> <span class="nop">        20ms       20ms           		if first == utf8internal.FirstInvalid { </span>
<span class="line">     62</span> <span class="nop">           .          .           			goto handleInvalid // invalid starter byte </span>
<span class="line">     63</span> <span class="nop">           .          .           		} </span>
<span class="line">     64</span> <span class="nop">        90ms       90ms           		accept = utf8internal.AcceptRanges[first&gt;&gt;utf8internal.AcceptShift] </span>
<span class="line">     65</span> <span class="nop">           .          .           		if nSrc+size &gt; n { </span>
<span class="line">     66</span> <span class="nop">           .          .           			if !atEOF { </span>
<span class="line">     67</span> <span class="nop">           .          .           				// We may stop earlier than necessary here if the short sequence </span>
<span class="line">     68</span> <span class="nop">           .          .           				// has invalid bytes. Not checking for this simplifies the code </span>
<span class="line">     69</span> <span class="nop">           .          .           				// and may avoid duplicate computations in certain conditions. </span>
<span class="line">     70</span> <span class="nop">           .          .           				if err == nil { </span>
<span class="line">     71</span> <span class="nop">           .          .           					err = transform.ErrShortSrc </span>
<span class="line">     72</span> <span class="nop">           .          .           				} </span>
<span class="line">     73</span> <span class="nop">           .          .           				break </span>
<span class="line">     74</span> <span class="nop">           .          .           			} </span>
<span class="line">     75</span> <span class="nop">           .          .           			// Determine the maximal subpart of an ill-formed subsequence. </span>
<span class="line">     76</span> <span class="nop">           .          .           			switch { </span>
<span class="line">     77</span> <span class="nop">           .          .           			case nSrc+1 &gt;= n || src[nSrc+1] &lt; accept.Lo || accept.Hi &lt; src[nSrc+1]: </span>
<span class="line">     78</span> <span class="nop">           .          .           				size = 1 </span>
<span class="line">     79</span> <span class="nop">           .          .           			case nSrc+2 &gt;= n || src[nSrc+2] &lt; utf8internal.LoCB || utf8internal.HiCB &lt; src[nSrc+2]: </span>
<span class="line">     80</span> <span class="nop">           .          .           				size = 2 </span>
<span class="line">     81</span> <span class="nop">           .          .           			default: </span>
<span class="line">     82</span> <span class="nop">           .          .           				size = 3 // As we are short, the maximum is 3. </span>
<span class="line">     83</span> <span class="nop">           .          .           			} </span>
<span class="line">     84</span> <span class="nop">           .          .           			goto handleInvalid </span>
<span class="line">     85</span> <span class="nop">           .          .           		} </span>
<span class="line">     86</span> <span class="nop">           .          .           		if c = src[nSrc+1]; c &lt; accept.Lo || accept.Hi &lt; c { </span>
<span class="line">     87</span> <span class="nop">           .          .           			size = 1 </span>
<span class="line">     88</span> <span class="nop">           .          .           			goto handleInvalid // invalid continuation byte </span>
<span class="line">     89</span> <span class="nop">           .          .           		} else if size == 2 { </span>
<span class="line">     90</span> <span class="nop">           .          .           		} else if c = src[nSrc+2]; c &lt; utf8internal.LoCB || utf8internal.HiCB &lt; c { </span>
<span class="line">     91</span> <span class="nop">           .          .           			size = 2 </span>
<span class="line">     92</span> <span class="nop">           .          .           			goto handleInvalid // invalid continuation byte </span>
<span class="line">     93</span> <span class="nop">           .          .           		} else if size == 3 { </span>
<span class="line">     94</span> <span class="nop">           .          .           		} else if c = src[nSrc+3]; c &lt; utf8internal.LoCB || utf8internal.HiCB &lt; c { </span>
<span class="line">     95</span> <span class="nop">           .          .           			size = 3 </span>
<span class="line">     96</span> <span class="nop">           .          .           			goto handleInvalid // invalid continuation byte </span>
<span class="line">     97</span> <span class="nop">           .          .           		} </span>
<span class="line">     98</span> <span class="nop">           .          .           		nSrc += size </span>
<span class="line">     99</span> <span class="nop">           .          .           		continue </span>
<span class="line">    100</span> <span class="nop">           .          .            </span>
<span class="line">    101</span> <span class="nop">           .          .           	handleInvalid: </span>
<span class="line">    102</span> <span class="nop">           .          .           		// Copy the scanned input so far. </span>
<span class="line">    103</span> <span class="nop">        90ms       90ms           		nDst += copy(dst[nDst:], src[pSrc:nSrc]) </span>
<span class="line">    104</span> <span class="nop">           .          .            </span>
<span class="line">    105</span> <span class="nop">           .          .           		// Append RuneError to the destination. </span>
<span class="line">    106</span> <span class="nop">           .          .           		const runeError = "\ufffd" </span>
<span class="line">    107</span> <span class="nop">           .          .           		if nDst+len(runeError) &gt; len(dst) { </span>
<span class="line">    108</span> <span class="nop">           .          .           			return nDst, nSrc, transform.ErrShortDst </span>
<span class="line">    109</span> <span class="nop">           .          .           		} </span>
<span class="line">    110</span> <span class="nop">           .          .           		nDst += copy(dst[nDst:], runeError) </span>
<span class="line">    111</span> <span class="nop">           .          .            </span>
<span class="line">    112</span> <span class="nop">           .          .           		// Skip the maximal subpart of an ill-formed subsequence according to </span>
<span class="line">    113</span> <span class="nop">           .          .           		// the W3C standard way instead of the Go way. This Transform is </span>
<span class="line">    114</span> <span class="nop">           .          .           		// probably the only place in the text repo where it is warranted. </span>
<span class="line">    115</span> <span class="nop">           .          .           		nSrc += size </span>
<span class="line">    116</span> <span class="nop">           .          .           		pSrc = nSrc </span>
<span class="line">    117</span> <span class="nop">           .          .            </span>
<span class="line">    118</span> <span class="nop">           .          .           		// Recompute the maximum source length. </span>
<span class="line">    119</span> <span class="nop">           .          .           		if sz := len(dst) - nDst; sz &lt; len(src)-nSrc { </span>
<span class="line">    120</span> <span class="nop">           .          .           			err = transform.ErrShortDst </span>
<span class="line">    121</span> <span class="nop">           .          .           			n = nSrc + sz </span>
<span class="line">    122</span> <span class="nop">           .          .           			atEOF = false </span>
<span class="line">    123</span> <span class="nop">           .          .           		} </span>
<span class="line">    124</span> <span class="nop">           .          .           	} </span>
<span class="line">    125</span> <span class="nop">        30ms       50ms           	return nDst + copy(dst[nDst:], src[pSrc:nSrc]), nSrc, err </span>
<span class="line">    126</span> <span class="nop">           .          .           } </span>
<span class="line">    127</span> <span class="nop">           .          .            </span>
<span class="line">    128</span> <span class="nop">           .          .           // UTF16 returns a UTF-16 Encoding for the given default endianness and byte </span>
<span class="line">    129</span> <span class="nop">           .          .           // order mark (BOM) policy. </span>
<span class="line">    130</span> <span class="nop">           .          .           // </span>
</pre>
<h2>compress/flate.(*decompressor).huffmanBlock</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\inflate.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       470ms      3.14s (flat, cum) 25.10%
<span class="line">    489</span> <span class="nop">           .          .           	} </span>
<span class="line">    490</span> <span class="nop">           .          .            </span>
<span class="line">    491</span> <span class="nop">           .          .           readLiteral: </span>
<span class="line">    492</span> <span class="nop">           .          .           	// Read literal and/or (length, distance) according to RFC section 3.2.3. </span>
<span class="line">    493</span> <span class="nop">           .          .           	{ </span>
<span class="line">    494</span> <span class="nop">        50ms      1.52s           		v, err := f.huffSym(f.hl) </span>
<span class="line">    495</span> <span class="nop">           .          .           		if err != nil { </span>
<span class="line">    496</span> <span class="nop">           .          .           			f.err = err </span>
<span class="line">    497</span> <span class="nop">           .          .           			return </span>
<span class="line">    498</span> <span class="nop">           .          .           		} </span>
<span class="line">    499</span> <span class="nop">           .          .           		var n uint // number of bits extra </span>
<span class="line">    500</span> <span class="nop">           .          .           		var length int </span>
<span class="line">    501</span> <span class="nop">           .          .           		switch { </span>
<span class="line">    502</span> <span class="nop">        20ms       20ms           		case v &lt; 256: </span>
<span class="line">    503</span> <span class="nop">        10ms      120ms           			f.dict.writeByte(byte(v)) </span>
<span class="line">    504</span> <span class="nop">           .       10ms           			if f.dict.availWrite() == 0 { </span>
<span class="line">    505</span> <span class="nop">           .          .           				f.toRead = f.dict.readFlush() </span>
<span class="line">    506</span> <span class="nop">           .          .           				f.step = (*decompressor).huffmanBlock </span>
<span class="line">    507</span> <span class="nop">           .          .           				f.stepState = stateInit </span>
<span class="line">    508</span> <span class="nop">           .          .           				return </span>
<span class="line">    509</span> <span class="nop">           .          .           			} </span>
<span class="line">    510</span> <span class="nop">           .          .           			goto readLiteral </span>
<span class="line">    511</span> <span class="nop">        50ms       50ms           		case v == 256: </span>
<span class="line">    512</span> <span class="nop">           .          .           			f.finishBlock() </span>
<span class="line">    513</span> <span class="nop">           .          .           			return </span>
<span class="line">    514</span> <span class="nop">           .          .           		// otherwise, reference to older data </span>
<span class="line">    515</span> <span class="nop">        10ms       10ms           		case v &lt; 265: </span>
<span class="line">    516</span> <span class="nop">        30ms       30ms           			length = v - (257 - 3) </span>
<span class="line">    517</span> <span class="nop">           .          .           			n = 0 </span>
<span class="line">    518</span> <span class="nop">        20ms       20ms           		case v &lt; 269: </span>
<span class="line">    519</span> <span class="nop">           .          .           			length = v*2 - (265*2 - 11) </span>
<span class="line">    520</span> <span class="nop">           .          .           			n = 1 </span>
<span class="line">    521</span> <span class="nop">           .          .           		case v &lt; 273: </span>
<span class="line">    522</span> <span class="nop">           .          .           			length = v*4 - (269*4 - 19) </span>
<span class="line">    523</span> <span class="nop">           .          .           			n = 2 </span>
<span class="line">    524</span> <span class="nop">           .          .           		case v &lt; 277: </span>
<span class="line">    525</span> <span class="nop">           .          .           			length = v*8 - (273*8 - 35) </span>
<span class="line">    526</span> <span class="nop">           .          .           			n = 3 </span>
<span class="line">    527</span> <span class="nop">           .          .           		case v &lt; 281: </span>
<span class="line">    528</span> <span class="nop">           .          .           			length = v*16 - (277*16 - 67) </span>
<span class="line">    529</span> <span class="nop">           .          .           			n = 4 </span>
<span class="line">    530</span> <span class="nop">        10ms       10ms           		case v &lt; 285: </span>
<span class="line">    531</span> <span class="nop">           .          .           			length = v*32 - (281*32 - 131) </span>
<span class="line">    532</span> <span class="nop">           .          .           			n = 5 </span>
<span class="line">    533</span> <span class="nop">           .          .           		case v &lt; maxNumLit: </span>
<span class="line">    534</span> <span class="nop">           .          .           			length = 258 </span>
<span class="line">    535</span> <span class="nop">           .          .           			n = 0 </span>
<span class="line">    536</span> <span class="nop">           .          .           		default: </span>
<span class="line">    537</span> <span class="nop">           .          .           			f.err = CorruptInputError(f.roffset) </span>
<span class="line">    538</span> <span class="nop">           .          .           			return </span>
<span class="line">    539</span> <span class="nop">           .          .           		} </span>
<span class="line">    540</span> <span class="nop">        20ms       20ms           		if n &gt; 0 { </span>
<span class="line">    541</span> <span class="nop">           .          .           			for f.nb &lt; n { </span>
<span class="line">    542</span> <span class="nop">        10ms       10ms           				if err = f.moreBits(); err != nil { </span>
<span class="line">    543</span> <span class="nop">           .          .           					f.err = err </span>
<span class="line">    544</span> <span class="nop">           .          .           					return </span>
<span class="line">    545</span> <span class="nop">           .          .           				} </span>
<span class="line">    546</span> <span class="nop">           .          .           			} </span>
<span class="line">    547</span> <span class="nop">           .          .           			length += int(f.b &amp; uint32(1&lt;&lt;n-1)) </span>
<span class="line">    548</span> <span class="nop">           .          .           			f.b &gt;&gt;= n </span>
<span class="line">    549</span> <span class="nop">           .          .           			f.nb -= n </span>
<span class="line">    550</span> <span class="nop">           .          .           		} </span>
<span class="line">    551</span> <span class="nop">           .          .            </span>
<span class="line">    552</span> <span class="nop">           .          .           		var dist int </span>
<span class="line">    553</span> <span class="nop">        30ms       30ms           		if f.hd == nil { </span>
<span class="line">    554</span> <span class="nop">           .          .           			for f.nb &lt; 5 { </span>
<span class="line">    555</span> <span class="nop">           .          .           				if err = f.moreBits(); err != nil { </span>
<span class="line">    556</span> <span class="nop">           .          .           					f.err = err </span>
<span class="line">    557</span> <span class="nop">           .          .           					return </span>
<span class="line">    558</span> <span class="nop">           .          .           				} </span>
<span class="line">    559</span> <span class="nop">           .          .           			} </span>
<span class="line">    560</span> <span class="nop">           .          .           			dist = int(bits.Reverse8(uint8(f.b &amp; 0x1F &lt;&lt; 3))) </span>
<span class="line">    561</span> <span class="nop">           .          .           			f.b &gt;&gt;= 5 </span>
<span class="line">    562</span> <span class="nop">           .          .           			f.nb -= 5 </span>
<span class="line">    563</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    564</span> <span class="nop">        20ms      280ms           			if dist, err = f.huffSym(f.hd); err != nil { </span>
<span class="line">    565</span> <span class="nop">           .          .           				f.err = err </span>
<span class="line">    566</span> <span class="nop">           .          .           				return </span>
<span class="line">    567</span> <span class="nop">           .          .           			} </span>
<span class="line">    568</span> <span class="nop">           .          .           		} </span>
<span class="line">    569</span> <span class="nop">           .          .            </span>
<span class="line">    570</span> <span class="nop">           .          .           		switch { </span>
<span class="line">    571</span> <span class="nop">        10ms       10ms           		case dist &lt; 4: </span>
<span class="line">    572</span> <span class="nop">           .          .           			dist++ </span>
<span class="line">    573</span> <span class="nop">        10ms       10ms           		case dist &lt; maxNumDist: </span>
<span class="line">    574</span> <span class="nop">        10ms       10ms           			nb := uint(dist-2) &gt;&gt; 1 </span>
<span class="line">    575</span> <span class="nop">           .          .           			// have 1 bit in bottom of dist, need nb more. </span>
<span class="line">    576</span> <span class="nop">        20ms       20ms           			extra := (dist &amp; 1) &lt;&lt; nb </span>
<span class="line">    577</span> <span class="nop">        20ms       20ms           			for f.nb &lt; nb { </span>
<span class="line">    578</span> <span class="nop">        20ms      310ms           				if err = f.moreBits(); err != nil { </span>
<span class="line">    579</span> <span class="nop">           .          .           					f.err = err </span>
<span class="line">    580</span> <span class="nop">           .          .           					return </span>
<span class="line">    581</span> <span class="nop">           .          .           				} </span>
<span class="line">    582</span> <span class="nop">           .          .           			} </span>
<span class="line">    583</span> <span class="nop">        10ms       10ms           			extra |= int(f.b &amp; uint32(1&lt;&lt;nb-1)) </span>
<span class="line">    584</span> <span class="nop">        30ms       30ms           			f.b &gt;&gt;= nb </span>
<span class="line">    585</span> <span class="nop">           .          .           			f.nb -= nb </span>
<span class="line">    586</span> <span class="nop">        10ms       10ms           			dist = 1&lt;&lt;(nb+1) + 1 + extra </span>
<span class="line">    587</span> <span class="nop">           .          .           		default: </span>
<span class="line">    588</span> <span class="nop">           .          .           			f.err = CorruptInputError(f.roffset) </span>
<span class="line">    589</span> <span class="nop">           .          .           			return </span>
<span class="line">    590</span> <span class="nop">           .          .           		} </span>
<span class="line">    591</span> <span class="nop">           .          .            </span>
<span class="line">    592</span> <span class="nop">           .          .           		// No check on length; encoding can be prescient. </span>
<span class="line">    593</span> <span class="nop">        20ms       30ms           		if dist &gt; f.dict.histSize() { </span>
<span class="line">    594</span> <span class="nop">           .          .           			f.err = CorruptInputError(f.roffset) </span>
<span class="line">    595</span> <span class="nop">           .          .           			return </span>
<span class="line">    596</span> <span class="nop">           .          .           		} </span>
<span class="line">    597</span> <span class="nop">           .          .            </span>
<span class="line">    598</span> <span class="nop">           .          .           		f.copyLen, f.copyDist = length, dist </span>
<span class="line">    599</span> <span class="nop">           .          .           		goto copyHistory </span>
<span class="line">    600</span> <span class="nop">           .          .           	} </span>
<span class="line">    601</span> <span class="nop">           .          .            </span>
<span class="line">    602</span> <span class="nop">           .          .           copyHistory: </span>
<span class="line">    603</span> <span class="nop">           .          .           	// Perform a backwards copy according to RFC section 3.2.3. </span>
<span class="line">    604</span> <span class="nop">           .          .           	{ </span>
<span class="line">    605</span> <span class="nop">        20ms      500ms           		cnt := f.dict.tryWriteCopy(f.copyDist, f.copyLen) </span>
<span class="line">    606</span> <span class="nop">           .          .           		if cnt == 0 { </span>
<span class="line">    607</span> <span class="nop">           .       30ms           			cnt = f.dict.writeCopy(f.copyDist, f.copyLen) </span>
<span class="line">    608</span> <span class="nop">           .          .           		} </span>
<span class="line">    609</span> <span class="nop">           .          .           		f.copyLen -= cnt </span>
<span class="line">    610</span> <span class="nop">           .          .            </span>
<span class="line">    611</span> <span class="nop">        10ms       20ms           		if f.dict.availWrite() == 0 || f.copyLen &gt; 0 { </span>
<span class="line">    612</span> <span class="nop">           .          .           			f.toRead = f.dict.readFlush() </span>
<span class="line">    613</span> <span class="nop">           .          .           			f.step = (*decompressor).huffmanBlock // We need to continue this work </span>
<span class="line">    614</span> <span class="nop">           .          .           			f.stepState = stateDict </span>
<span class="line">    615</span> <span class="nop">           .          .           			return </span>
<span class="line">    616</span> <span class="nop">           .          .           		} </span>
</pre>
<h2>runtime.memmove</h2><p class="filename">C:\blockchainenv\Go\src\runtime\memmove_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       370ms      370ms (flat, cum)  2.96%
<span class="line">     29</span> <span class="nop">           .          .           #include "textflag.h" </span>
<span class="line">     30</span> <span class="nop">           .          .            </span>
<span class="line">     31</span> <span class="nop">           .          .           // func memmove(to, from unsafe.Pointer, n uintptr) </span>
<span class="line">     32</span> <span class="nop">           .          .           TEXT runtime·memmove(SB), NOSPLIT, $0-24 </span>
<span class="line">     33</span> <span class="nop">           .          .            </span>
<span class="line">     34</span> <span class="nop">        20ms       20ms           	MOVQ	to+0(FP), DI </span>
<span class="line">     35</span> <span class="nop">           .          .           	MOVQ	from+8(FP), SI </span>
<span class="line">     36</span> <span class="nop">        20ms       20ms           	MOVQ	n+16(FP), BX </span>
<span class="line">     37</span> <span class="nop">           .          .            </span>
<span class="line">     38</span> <span class="nop">           .          .           	// REP instructions have a high startup cost, so we handle small sizes </span>
<span class="line">     39</span> <span class="nop">           .          .           	// with some straightline code. The REP MOVSQ instruction is really fast </span>
<span class="line">     40</span> <span class="nop">           .          .           	// for large sizes. The cutover is approximately 2K. </span>
<span class="line">     41</span> <span class="nop">           .          .           tail: </span>
<span class="line">     42</span> <span class="nop">           .          .           	// move_129through256 or smaller work whether or not the source and the </span>
<span class="line">     43</span> <span class="nop">           .          .           	// destination memory regions overlap because they load all data into </span>
<span class="line">     44</span> <span class="nop">           .          .           	// registers before writing it back.  move_256through2048 on the other </span>
<span class="line">     45</span> <span class="nop">           .          .           	// hand can be used only when the memory regions don't overlap or the copy </span>
<span class="line">     46</span> <span class="nop">           .          .           	// direction is forward. </span>
<span class="line">     47</span> <span class="nop">           .          .           	// </span>
<span class="line">     48</span> <span class="nop">           .          .           	// BSR+branch table make almost all memmove/memclr benchmarks worse. Not worth doing. </span>
<span class="line">     49</span> <span class="nop">        10ms       10ms           	TESTQ	BX, BX </span>
<span class="line">     50</span> <span class="nop">           .          .           	JEQ	move_0 </span>
<span class="line">     51</span> <span class="nop">           .          .           	CMPQ	BX, $2 </span>
<span class="line">     52</span> <span class="nop">           .          .           	JBE	move_1or2 </span>
<span class="line">     53</span> <span class="nop">           .          .           	CMPQ	BX, $4 </span>
<span class="line">     54</span> <span class="nop">           .          .           	JB	move_3 </span>
<span class="line">     55</span> <span class="nop">        30ms       30ms           	JBE	move_4 </span>
<span class="line">     56</span> <span class="nop">        20ms       20ms           	CMPQ	BX, $8 </span>
<span class="line">     57</span> <span class="nop">           .          .           	JB	move_5through7 </span>
<span class="line">     58</span> <span class="nop">           .          .           	JE	move_8 </span>
<span class="line">     59</span> <span class="nop">           .          .           	CMPQ	BX, $16 </span>
<span class="line">     60</span> <span class="nop">           .          .           	JBE	move_9through16 </span>
<span class="line">     61</span> <span class="nop">           .          .           	CMPQ	BX, $32 </span>
<span class="line">     62</span> <span class="nop">           .          .           	JBE	move_17through32 </span>
<span class="line">     63</span> <span class="nop">           .          .           	CMPQ	BX, $64 </span>
<span class="line">     64</span> <span class="nop">           .          .           	JBE	move_33through64 </span>
<span class="line">     65</span> <span class="nop">           .          .           	CMPQ	BX, $128 </span>
<span class="line">     66</span> <span class="nop">           .          .           	JBE	move_65through128 </span>
<span class="line">     67</span> <span class="nop">           .          .           	CMPQ	BX, $256 </span>
<span class="line">     68</span> <span class="nop">           .          .           	JBE	move_129through256 </span>
<span class="line">     69</span> <span class="nop">           .          .            </span>
<span class="line">     70</span> <span class="nop">           .          .           	TESTB	$1, runtime·useAVXmemmove(SB) </span>
<span class="line">     71</span> <span class="nop">           .          .           	JNZ	avxUnaligned </span>
<span class="line">     72</span> <span class="nop">           .          .            </span>
<span class="line">     73</span> <span class="nop">           .          .           /* </span>
<span class="line">     74</span> <span class="nop">           .          .            * check and set for backwards </span>
<span class="line">     75</span> <span class="nop">           .          .            */ </span>
<span class="line">     76</span> <span class="nop">           .          .           	CMPQ	SI, DI </span>
<span class="line">     77</span> <span class="nop">           .          .           	JLS	back </span>
<span class="line">     78</span> <span class="nop">           .          .            </span>
<span class="line">     79</span> <span class="nop">           .          .           /* </span>
<span class="line">     80</span> <span class="nop">           .          .            * forward copy loop </span>
<span class="line">     81</span> <span class="nop">           .          .            */ </span>
<span class="line">     82</span> <span class="nop">           .          .           forward: </span>
<span class="line">     83</span> <span class="nop">           .          .           	CMPQ	BX, $2048 </span>
<span class="line">     84</span> <span class="nop">           .          .           	JLS	move_256through2048 </span>
<span class="line">     85</span> <span class="nop">           .          .            </span>
<span class="line">     86</span> <span class="nop">           .          .           	// If REP MOVSB isn't fast, don't use it </span>
<span class="line">     87</span> <span class="nop">           .          .           	CMPB	internal∕cpu·X86+const_offsetX86HasERMS(SB), $1 // enhanced REP MOVSB/STOSB </span>
<span class="line">     88</span> <span class="nop">           .          .           	JNE	fwdBy8 </span>
<span class="line">     89</span> <span class="nop">           .          .            </span>
<span class="line">     90</span> <span class="nop">           .          .           	// Check alignment </span>
<span class="line">     91</span> <span class="nop">           .          .           	MOVL	SI, AX </span>
<span class="line">     92</span> <span class="nop">           .          .           	ORL	DI, AX </span>
<span class="line">     93</span> <span class="nop">           .          .           	TESTL	$7, AX </span>
<span class="line">     94</span> <span class="nop">           .          .           	JEQ	fwdBy8 </span>
<span class="line">     95</span> <span class="nop">           .          .            </span>
<span class="line">     96</span> <span class="nop">           .          .           	// Do 1 byte at a time </span>
<span class="line">     97</span> <span class="nop">           .          .           	MOVQ	BX, CX </span>
<span class="line">     98</span> <span class="nop">           .          .           	REP;	MOVSB </span>
<span class="line">     99</span> <span class="nop">           .          .           	RET </span>
<span class="line">    100</span> <span class="nop">           .          .            </span>
<span class="line">    101</span> <span class="nop">           .          .           fwdBy8: </span>
<span class="line">    102</span> <span class="nop">           .          .           	// Do 8 bytes at a time </span>
<span class="line">    103</span> <span class="nop">           .          .           	MOVQ	BX, CX </span>
<span class="line">    104</span> <span class="nop">           .          .           	SHRQ	$3, CX </span>
<span class="line">    105</span> <span class="nop">           .          .           	ANDQ	$7, BX </span>
<span class="line">    106</span> <span class="nop">           .          .           	REP;	MOVSQ </span>
<span class="line">    107</span> <span class="nop">           .          .           	JMP	tail </span>
<span class="line">    108</span> <span class="nop">           .          .            </span>
<span class="line">    109</span> <span class="nop">           .          .           back: </span>
<span class="line">    110</span> <span class="nop">           .          .           /* </span>
<span class="line">    111</span> <span class="nop">           .          .            * check overlap </span>
<span class="line">    112</span> <span class="nop">           .          .            */ </span>
<span class="line">    113</span> <span class="nop">           .          .           	MOVQ	SI, CX </span>
<span class="line">    114</span> <span class="nop">           .          .           	ADDQ	BX, CX </span>
<span class="line">    115</span> <span class="nop">           .          .           	CMPQ	CX, DI </span>
<span class="line">    116</span> <span class="nop">           .          .           	JLS	forward </span>
<span class="line">    117</span> <span class="nop">           .          .           /* </span>
<span class="line">    118</span> <span class="nop">           .          .            * whole thing backwards has </span>
<span class="line">    119</span> <span class="nop">           .          .            * adjusted addresses </span>
<span class="line">    120</span> <span class="nop">           .          .            */ </span>
<span class="line">    121</span> <span class="nop">           .          .           	ADDQ	BX, DI </span>
<span class="line">    122</span> <span class="nop">           .          .           	ADDQ	BX, SI </span>
<span class="line">    123</span> <span class="nop">           .          .           	STD </span>
<span class="line">    124</span> <span class="nop">           .          .            </span>
<span class="line">    125</span> <span class="nop">           .          .           /* </span>
<span class="line">    126</span> <span class="nop">           .          .            * copy </span>
<span class="line">    127</span> <span class="nop">           .          .            */ </span>
<span class="line">    128</span> <span class="nop">           .          .           	MOVQ	BX, CX </span>
<span class="line">    129</span> <span class="nop">           .          .           	SHRQ	$3, CX </span>
<span class="line">    130</span> <span class="nop">           .          .           	ANDQ	$7, BX </span>
<span class="line">    131</span> <span class="nop">           .          .            </span>
<span class="line">    132</span> <span class="nop">           .          .           	SUBQ	$8, DI </span>
<span class="line">    133</span> <span class="nop">           .          .           	SUBQ	$8, SI </span>
<span class="line">    134</span> <span class="nop">           .          .           	REP;	MOVSQ </span>
<span class="line">    135</span> <span class="nop">           .          .            </span>
<span class="line">    136</span> <span class="nop">           .          .           	CLD </span>
<span class="line">    137</span> <span class="nop">           .          .           	ADDQ	$8, DI </span>
<span class="line">    138</span> <span class="nop">           .          .           	ADDQ	$8, SI </span>
<span class="line">    139</span> <span class="nop">           .          .           	SUBQ	BX, DI </span>
<span class="line">    140</span> <span class="nop">           .          .           	SUBQ	BX, SI </span>
<span class="line">    141</span> <span class="nop">           .          .           	JMP	tail </span>
<span class="line">    142</span> <span class="nop">           .          .            </span>
<span class="line">    143</span> <span class="nop">           .          .           move_1or2: </span>
<span class="line">    144</span> <span class="nop">           .          .           	MOVB	(SI), AX </span>
<span class="line">    145</span> <span class="nop">           .          .           	MOVB	-1(SI)(BX*1), CX </span>
<span class="line">    146</span> <span class="nop">           .          .           	MOVB	AX, (DI) </span>
<span class="line">    147</span> <span class="nop">           .          .           	MOVB	CX, -1(DI)(BX*1) </span>
<span class="line">    148</span> <span class="nop">           .          .           	RET </span>
<span class="line">    149</span> <span class="nop">           .          .           move_0: </span>
<span class="line">    150</span> <span class="nop">           .          .           	RET </span>
<span class="line">    151</span> <span class="nop">           .          .           move_4: </span>
<span class="line">    152</span> <span class="nop">           .          .           	MOVL	(SI), AX </span>
<span class="line">    153</span> <span class="nop">        10ms       10ms           	MOVL	AX, (DI) </span>
<span class="line">    154</span> <span class="nop">           .          .           	RET </span>
<span class="line">    155</span> <span class="nop">           .          .           move_3: </span>
<span class="line">    156</span> <span class="nop">        30ms       30ms           	MOVW	(SI), AX </span>
<span class="line">    157</span> <span class="nop">        10ms       10ms           	MOVB	2(SI), CX </span>
<span class="line">    158</span> <span class="nop">        10ms       10ms           	MOVW	AX, (DI) </span>
<span class="line">    159</span> <span class="nop">           .          .           	MOVB	CX, 2(DI) </span>
<span class="line">    160</span> <span class="nop">           .          .           	RET </span>
<span class="line">    161</span> <span class="nop">           .          .           move_5through7: </span>
<span class="line">    162</span> <span class="nop">        10ms       10ms           	MOVL	(SI), AX </span>
<span class="line">    163</span> <span class="nop">        30ms       30ms           	MOVL	-4(SI)(BX*1), CX </span>
<span class="line">    164</span> <span class="nop">           .          .           	MOVL	AX, (DI) </span>
<span class="line">    165</span> <span class="nop">           .          .           	MOVL	CX, -4(DI)(BX*1) </span>
<span class="line">    166</span> <span class="nop">           .          .           	RET </span>
<span class="line">    167</span> <span class="nop">           .          .           move_8: </span>
<span class="line">    168</span> <span class="nop">           .          .           	// We need a separate case for 8 to make sure we write pointers atomically. </span>
<span class="line">    169</span> <span class="nop">        10ms       10ms           	MOVQ	(SI), AX </span>
<span class="line">    170</span> <span class="nop">           .          .           	MOVQ	AX, (DI) </span>
<span class="line">    171</span> <span class="nop">           .          .           	RET </span>
<span class="line">    172</span> <span class="nop">           .          .           move_9through16: </span>
<span class="line">    173</span> <span class="nop">        10ms       10ms           	MOVQ	(SI), AX </span>
<span class="line">    174</span> <span class="nop">        30ms       30ms           	MOVQ	-8(SI)(BX*1), CX </span>
<span class="line">    175</span> <span class="nop">           .          .           	MOVQ	AX, (DI) </span>
<span class="line">    176</span> <span class="nop">           .          .           	MOVQ	CX, -8(DI)(BX*1) </span>
<span class="line">    177</span> <span class="nop">           .          .           	RET </span>
<span class="line">    178</span> <span class="nop">           .          .           move_17through32: </span>
<span class="line">    179</span> <span class="nop">           .          .           	MOVOU	(SI), X0 </span>
<span class="line">    180</span> <span class="nop">           .          .           	MOVOU	-16(SI)(BX*1), X1 </span>
<span class="line">    181</span> <span class="nop">        10ms       10ms           	MOVOU	X0, (DI) </span>
<span class="line">    182</span> <span class="nop">           .          .           	MOVOU	X1, -16(DI)(BX*1) </span>
<span class="line">    183</span> <span class="nop">           .          .           	RET </span>
<span class="line">    184</span> <span class="nop">           .          .           move_33through64: </span>
<span class="line">    185</span> <span class="nop">        10ms       10ms           	MOVOU	(SI), X0 </span>
<span class="line">    186</span> <span class="nop">           .          .           	MOVOU	16(SI), X1 </span>
<span class="line">    187</span> <span class="nop">           .          .           	MOVOU	-32(SI)(BX*1), X2 </span>
<span class="line">    188</span> <span class="nop">           .          .           	MOVOU	-16(SI)(BX*1), X3 </span>
<span class="line">    189</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    190</span> <span class="nop">           .          .           	MOVOU	X1, 16(DI) </span>
<span class="line">    191</span> <span class="nop">           .          .           	MOVOU	X2, -32(DI)(BX*1) </span>
<span class="line">    192</span> <span class="nop">           .          .           	MOVOU	X3, -16(DI)(BX*1) </span>
<span class="line">    193</span> <span class="nop">           .          .           	RET </span>
<span class="line">    194</span> <span class="nop">           .          .           move_65through128: </span>
<span class="line">    195</span> <span class="nop">           .          .           	MOVOU	(SI), X0 </span>
<span class="line">    196</span> <span class="nop">        10ms       10ms           	MOVOU	16(SI), X1 </span>
<span class="line">    197</span> <span class="nop">           .          .           	MOVOU	32(SI), X2 </span>
<span class="line">    198</span> <span class="nop">           .          .           	MOVOU	48(SI), X3 </span>
<span class="line">    199</span> <span class="nop">           .          .           	MOVOU	-64(SI)(BX*1), X4 </span>
<span class="line">    200</span> <span class="nop">           .          .           	MOVOU	-48(SI)(BX*1), X5 </span>
<span class="line">    201</span> <span class="nop">           .          .           	MOVOU	-32(SI)(BX*1), X6 </span>
<span class="line">    202</span> <span class="nop">           .          .           	MOVOU	-16(SI)(BX*1), X7 </span>
<span class="line">    203</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    204</span> <span class="nop">           .          .           	MOVOU	X1, 16(DI) </span>
<span class="line">    205</span> <span class="nop">           .          .           	MOVOU	X2, 32(DI) </span>
<span class="line">    206</span> <span class="nop">           .          .           	MOVOU	X3, 48(DI) </span>
<span class="line">    207</span> <span class="nop">           .          .           	MOVOU	X4, -64(DI)(BX*1) </span>
<span class="line">    208</span> <span class="nop">           .          .           	MOVOU	X5, -48(DI)(BX*1) </span>
<span class="line">    209</span> <span class="nop">           .          .           	MOVOU	X6, -32(DI)(BX*1) </span>
<span class="line">    210</span> <span class="nop">           .          .           	MOVOU	X7, -16(DI)(BX*1) </span>
<span class="line">    211</span> <span class="nop">           .          .           	RET </span>
<span class="line">    212</span> <span class="nop">           .          .           move_129through256: </span>
<span class="line">    213</span> <span class="nop">           .          .           	MOVOU	(SI), X0 </span>
<span class="line">    214</span> <span class="nop">        10ms       10ms           	MOVOU	16(SI), X1 </span>
<span class="line">    215</span> <span class="nop">           .          .           	MOVOU	32(SI), X2 </span>
<span class="line">    216</span> <span class="nop">           .          .           	MOVOU	48(SI), X3 </span>
<span class="line">    217</span> <span class="nop">           .          .           	MOVOU	64(SI), X4 </span>
<span class="line">    218</span> <span class="nop">           .          .           	MOVOU	80(SI), X5 </span>
<span class="line">    219</span> <span class="nop">           .          .           	MOVOU	96(SI), X6 </span>
<span class="line">    220</span> <span class="nop">           .          .           	MOVOU	112(SI), X7 </span>
<span class="line">    221</span> <span class="nop">           .          .           	MOVOU	-128(SI)(BX*1), X8 </span>
<span class="line">    222</span> <span class="nop">           .          .           	MOVOU	-112(SI)(BX*1), X9 </span>
<span class="line">    223</span> <span class="nop">           .          .           	MOVOU	-96(SI)(BX*1), X10 </span>
<span class="line">    224</span> <span class="nop">           .          .           	MOVOU	-80(SI)(BX*1), X11 </span>
<span class="line">    225</span> <span class="nop">           .          .           	MOVOU	-64(SI)(BX*1), X12 </span>
<span class="line">    226</span> <span class="nop">           .          .           	MOVOU	-48(SI)(BX*1), X13 </span>
<span class="line">    227</span> <span class="nop">           .          .           	MOVOU	-32(SI)(BX*1), X14 </span>
<span class="line">    228</span> <span class="nop">           .          .           	MOVOU	-16(SI)(BX*1), X15 </span>
<span class="line">    229</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    230</span> <span class="nop">           .          .           	MOVOU	X1, 16(DI) </span>
<span class="line">    231</span> <span class="nop">           .          .           	MOVOU	X2, 32(DI) </span>
<span class="line">    232</span> <span class="nop">           .          .           	MOVOU	X3, 48(DI) </span>
<span class="line">    233</span> <span class="nop">           .          .           	MOVOU	X4, 64(DI) </span>
<span class="line">    234</span> <span class="nop">           .          .           	MOVOU	X5, 80(DI) </span>
<span class="line">    235</span> <span class="nop">           .          .           	MOVOU	X6, 96(DI) </span>
<span class="line">    236</span> <span class="nop">           .          .           	MOVOU	X7, 112(DI) </span>
<span class="line">    237</span> <span class="nop">           .          .           	MOVOU	X8, -128(DI)(BX*1) </span>
<span class="line">    238</span> <span class="nop">           .          .           	MOVOU	X9, -112(DI)(BX*1) </span>
<span class="line">    239</span> <span class="nop">           .          .           	MOVOU	X10, -96(DI)(BX*1) </span>
<span class="line">    240</span> <span class="nop">           .          .           	MOVOU	X11, -80(DI)(BX*1) </span>
<span class="line">    241</span> <span class="nop">           .          .           	MOVOU	X12, -64(DI)(BX*1) </span>
<span class="line">    242</span> <span class="nop">           .          .           	MOVOU	X13, -48(DI)(BX*1) </span>
<span class="line">    243</span> <span class="nop">           .          .           	MOVOU	X14, -32(DI)(BX*1) </span>
<span class="line">    244</span> <span class="nop">           .          .           	MOVOU	X15, -16(DI)(BX*1) </span>
<span class="line">    245</span> <span class="nop">           .          .           	RET </span>
<span class="line">    246</span> <span class="nop">           .          .           move_256through2048: </span>
<span class="line">    247</span> <span class="nop">           .          .           	SUBQ	$256, BX </span>
<span class="line">    248</span> <span class="nop">           .          .           	MOVOU	(SI), X0 </span>
<span class="line">    249</span> <span class="nop">           .          .           	MOVOU	16(SI), X1 </span>
<span class="line">    250</span> <span class="nop">           .          .           	MOVOU	32(SI), X2 </span>
<span class="line">    251</span> <span class="nop">           .          .           	MOVOU	48(SI), X3 </span>
<span class="line">    252</span> <span class="nop">           .          .           	MOVOU	64(SI), X4 </span>
<span class="line">    253</span> <span class="nop">           .          .           	MOVOU	80(SI), X5 </span>
<span class="line">    254</span> <span class="nop">           .          .           	MOVOU	96(SI), X6 </span>
<span class="line">    255</span> <span class="nop">           .          .           	MOVOU	112(SI), X7 </span>
<span class="line">    256</span> <span class="nop">           .          .           	MOVOU	128(SI), X8 </span>
<span class="line">    257</span> <span class="nop">           .          .           	MOVOU	144(SI), X9 </span>
<span class="line">    258</span> <span class="nop">           .          .           	MOVOU	160(SI), X10 </span>
<span class="line">    259</span> <span class="nop">           .          .           	MOVOU	176(SI), X11 </span>
<span class="line">    260</span> <span class="nop">           .          .           	MOVOU	192(SI), X12 </span>
<span class="line">    261</span> <span class="nop">           .          .           	MOVOU	208(SI), X13 </span>
<span class="line">    262</span> <span class="nop">           .          .           	MOVOU	224(SI), X14 </span>
<span class="line">    263</span> <span class="nop">           .          .           	MOVOU	240(SI), X15 </span>
<span class="line">    264</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    265</span> <span class="nop">           .          .           	MOVOU	X1, 16(DI) </span>
<span class="line">    266</span> <span class="nop">           .          .           	MOVOU	X2, 32(DI) </span>
<span class="line">    267</span> <span class="nop">           .          .           	MOVOU	X3, 48(DI) </span>
<span class="line">    268</span> <span class="nop">           .          .           	MOVOU	X4, 64(DI) </span>
<span class="line">    269</span> <span class="nop">           .          .           	MOVOU	X5, 80(DI) </span>
<span class="line">    270</span> <span class="nop">           .          .           	MOVOU	X6, 96(DI) </span>
<span class="line">    271</span> <span class="nop">           .          .           	MOVOU	X7, 112(DI) </span>
<span class="line">    272</span> <span class="nop">           .          .           	MOVOU	X8, 128(DI) </span>
<span class="line">    273</span> <span class="nop">           .          .           	MOVOU	X9, 144(DI) </span>
<span class="line">    274</span> <span class="nop">           .          .           	MOVOU	X10, 160(DI) </span>
<span class="line">    275</span> <span class="nop">           .          .           	MOVOU	X11, 176(DI) </span>
<span class="line">    276</span> <span class="nop">           .          .           	MOVOU	X12, 192(DI) </span>
<span class="line">    277</span> <span class="nop">           .          .           	MOVOU	X13, 208(DI) </span>
<span class="line">    278</span> <span class="nop">           .          .           	MOVOU	X14, 224(DI) </span>
<span class="line">    279</span> <span class="nop">           .          .           	MOVOU	X15, 240(DI) </span>
<span class="line">    280</span> <span class="nop">           .          .           	CMPQ	BX, $256 </span>
<span class="line">    281</span> <span class="nop">           .          .           	LEAQ	256(SI), SI </span>
<span class="line">    282</span> <span class="nop">           .          .           	LEAQ	256(DI), DI </span>
<span class="line">    283</span> <span class="nop">           .          .           	JGE	move_256through2048 </span>
<span class="line">    284</span> <span class="nop">           .          .           	JMP	tail </span>
<span class="line">    285</span> <span class="nop">           .          .            </span>
<span class="line">    286</span> <span class="nop">           .          .           avxUnaligned: </span>
<span class="line">    287</span> <span class="nop">           .          .           	// There are two implementations of move algorithm. </span>
<span class="line">    288</span> <span class="nop">           .          .           	// The first one for non-overlapped memory regions. It uses forward copying. </span>
<span class="line">    289</span> <span class="nop">           .          .           	// The second one for overlapped regions. It uses backward copying </span>
<span class="line">    290</span> <span class="nop">           .          .           	MOVQ	DI, CX </span>
<span class="line">    291</span> <span class="nop">           .          .           	SUBQ	SI, CX </span>
<span class="line">    292</span> <span class="nop">           .          .           	// Now CX contains distance between SRC and DEST </span>
<span class="line">    293</span> <span class="nop">           .          .           	CMPQ	CX, BX </span>
<span class="line">    294</span> <span class="nop">           .          .           	// If the distance lesser than region length it means that regions are overlapped </span>
<span class="line">    295</span> <span class="nop">           .          .           	JC	copy_backward </span>
<span class="line">    296</span> <span class="nop">           .          .            </span>
<span class="line">    297</span> <span class="nop">           .          .           	// Non-temporal copy would be better for big sizes. </span>
<span class="line">    298</span> <span class="nop">           .          .           	CMPQ	BX, $0x100000 </span>
<span class="line">    299</span> <span class="nop">           .          .           	JAE	gobble_big_data_fwd </span>
<span class="line">    300</span> <span class="nop">           .          .            </span>
<span class="line">    301</span> <span class="nop">           .          .           	// Memory layout on the source side </span>
<span class="line">    302</span> <span class="nop">           .          .           	// SI                                       CX </span>
<span class="line">    303</span> <span class="nop">           .          .           	// |&lt;---------BX before correction---------&gt;| </span>
<span class="line">    304</span> <span class="nop">           .          .           	// |       |&lt;--BX corrected--&gt;|             | </span>
<span class="line">    305</span> <span class="nop">           .          .           	// |       |                  |&lt;--- AX  ---&gt;| </span>
<span class="line">    306</span> <span class="nop">           .          .           	// |&lt;-R11-&gt;|                  |&lt;-128 bytes-&gt;| </span>
<span class="line">    307</span> <span class="nop">           .          .           	// +----------------------------------------+ </span>
<span class="line">    308</span> <span class="nop">           .          .           	// | Head  | Body             | Tail        | </span>
<span class="line">    309</span> <span class="nop">           .          .           	// +-------+------------------+-------------+ </span>
<span class="line">    310</span> <span class="nop">           .          .           	// ^       ^                  ^ </span>
<span class="line">    311</span> <span class="nop">           .          .           	// |       |                  | </span>
<span class="line">    312</span> <span class="nop">           .          .           	// Save head into Y4          Save tail into X5..X12 </span>
<span class="line">    313</span> <span class="nop">           .          .           	//         | </span>
<span class="line">    314</span> <span class="nop">           .          .           	//         SI+R11, where R11 = ((DI &amp; -32) + 32) - DI </span>
<span class="line">    315</span> <span class="nop">           .          .           	// Algorithm: </span>
<span class="line">    316</span> <span class="nop">           .          .           	// 1. Unaligned save of the tail's 128 bytes </span>
<span class="line">    317</span> <span class="nop">           .          .           	// 2. Unaligned save of the head's 32  bytes </span>
<span class="line">    318</span> <span class="nop">           .          .           	// 3. Destination-aligned copying of body (128 bytes per iteration) </span>
<span class="line">    319</span> <span class="nop">           .          .           	// 4. Put head on the new place </span>
<span class="line">    320</span> <span class="nop">           .          .           	// 5. Put the tail on the new place </span>
<span class="line">    321</span> <span class="nop">           .          .           	// It can be important to satisfy processor's pipeline requirements for </span>
<span class="line">    322</span> <span class="nop">           .          .           	// small sizes as the cost of unaligned memory region copying is </span>
<span class="line">    323</span> <span class="nop">           .          .           	// comparable with the cost of main loop. So code is slightly messed there. </span>
<span class="line">    324</span> <span class="nop">           .          .           	// There is more clean implementation of that algorithm for bigger sizes </span>
<span class="line">    325</span> <span class="nop">           .          .           	// where the cost of unaligned part copying is negligible. </span>
<span class="line">    326</span> <span class="nop">           .          .           	// You can see it after gobble_big_data_fwd label. </span>
<span class="line">    327</span> <span class="nop">           .          .           	LEAQ	(SI)(BX*1), CX </span>
<span class="line">    328</span> <span class="nop">           .          .           	MOVQ	DI, R10 </span>
<span class="line">    329</span> <span class="nop">           .          .           	// CX points to the end of buffer so we need go back slightly. We will use negative offsets there. </span>
<span class="line">    330</span> <span class="nop">           .          .           	MOVOU	-0x80(CX), X5 </span>
<span class="line">    331</span> <span class="nop">        10ms       10ms           	MOVOU	-0x70(CX), X6 </span>
<span class="line">    332</span> <span class="nop">           .          .           	MOVQ	$0x80, AX </span>
<span class="line">    333</span> <span class="nop">           .          .           	// Align destination address </span>
<span class="line">    334</span> <span class="nop">           .          .           	ANDQ	$-32, DI </span>
<span class="line">    335</span> <span class="nop">           .          .           	ADDQ	$32, DI </span>
<span class="line">    336</span> <span class="nop">           .          .           	// Continue tail saving. </span>
<span class="line">    337</span> <span class="nop">           .          .           	MOVOU	-0x60(CX), X7 </span>
<span class="line">    338</span> <span class="nop">           .          .           	MOVOU	-0x50(CX), X8 </span>
<span class="line">    339</span> <span class="nop">           .          .           	// Make R11 delta between aligned and unaligned destination addresses. </span>
<span class="line">    340</span> <span class="nop">           .          .           	MOVQ	DI, R11 </span>
<span class="line">    341</span> <span class="nop">           .          .           	SUBQ	R10, R11 </span>
<span class="line">    342</span> <span class="nop">           .          .           	// Continue tail saving. </span>
<span class="line">    343</span> <span class="nop">           .          .           	MOVOU	-0x40(CX), X9 </span>
<span class="line">    344</span> <span class="nop">           .          .           	MOVOU	-0x30(CX), X10 </span>
<span class="line">    345</span> <span class="nop">           .          .           	// Let's make bytes-to-copy value adjusted as we've prepared unaligned part for copying. </span>
<span class="line">    346</span> <span class="nop">           .          .           	SUBQ	R11, BX </span>
<span class="line">    347</span> <span class="nop">           .          .           	// Continue tail saving. </span>
<span class="line">    348</span> <span class="nop">           .          .           	MOVOU	-0x20(CX), X11 </span>
<span class="line">    349</span> <span class="nop">           .          .           	MOVOU	-0x10(CX), X12 </span>
<span class="line">    350</span> <span class="nop">           .          .           	// The tail will be put on its place after main body copying. </span>
<span class="line">    351</span> <span class="nop">           .          .           	// It's time for the unaligned heading part. </span>
<span class="line">    352</span> <span class="nop">           .          .           	VMOVDQU	(SI), Y4 </span>
<span class="line">    353</span> <span class="nop">           .          .           	// Adjust source address to point past head. </span>
<span class="line">    354</span> <span class="nop">           .          .           	ADDQ	R11, SI </span>
<span class="line">    355</span> <span class="nop">           .          .           	SUBQ	AX, BX </span>
<span class="line">    356</span> <span class="nop">           .          .           	// Aligned memory copying there </span>
<span class="line">    357</span> <span class="nop">           .          .           gobble_128_loop: </span>
<span class="line">    358</span> <span class="nop">           .          .           	VMOVDQU	(SI), Y0 </span>
<span class="line">    359</span> <span class="nop">        10ms       10ms           	VMOVDQU	0x20(SI), Y1 </span>
<span class="line">    360</span> <span class="nop">        20ms       20ms           	VMOVDQU	0x40(SI), Y2 </span>
<span class="line">    361</span> <span class="nop">           .          .           	VMOVDQU	0x60(SI), Y3 </span>
<span class="line">    362</span> <span class="nop">        10ms       10ms           	ADDQ	AX, SI </span>
<span class="line">    363</span> <span class="nop">           .          .           	VMOVDQA	Y0, (DI) </span>
<span class="line">    364</span> <span class="nop">        10ms       10ms           	VMOVDQA	Y1, 0x20(DI) </span>
<span class="line">    365</span> <span class="nop">        10ms       10ms           	VMOVDQA	Y2, 0x40(DI) </span>
<span class="line">    366</span> <span class="nop">           .          .           	VMOVDQA	Y3, 0x60(DI) </span>
<span class="line">    367</span> <span class="nop">        10ms       10ms           	ADDQ	AX, DI </span>
<span class="line">    368</span> <span class="nop">           .          .           	SUBQ	AX, BX </span>
<span class="line">    369</span> <span class="nop">           .          .           	JA	gobble_128_loop </span>
<span class="line">    370</span> <span class="nop">           .          .           	// Now we can store unaligned parts. </span>
<span class="line">    371</span> <span class="nop">           .          .           	ADDQ	AX, BX </span>
<span class="line">    372</span> <span class="nop">           .          .           	ADDQ	DI, BX </span>
</pre>
<h2>runtime.scanobject</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mgcmark.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       340ms      830ms (flat, cum)  6.63%
<span class="line">   1077</span> <span class="nop">           .          .           // b must point to the beginning of a heap object or an oblet. </span>
<span class="line">   1078</span> <span class="nop">           .          .           // scanobject consults the GC bitmap for the pointer mask and the </span>
<span class="line">   1079</span> <span class="nop">           .          .           // spans for the size of the object. </span>
<span class="line">   1080</span> <span class="nop">           .          .           // </span>
<span class="line">   1081</span> <span class="nop">           .          .           //go:nowritebarrier </span>
<span class="line">   1082</span> <span class="nop">        10ms       10ms           func scanobject(b uintptr, gcw *gcWork) { </span>
<span class="line">   1083</span> <span class="nop">           .          .           	// Find the bits for b and the size of the object at b. </span>
<span class="line">   1084</span> <span class="nop">           .          .           	// </span>
<span class="line">   1085</span> <span class="nop">           .          .           	// b is either the beginning of an object, in which case this </span>
<span class="line">   1086</span> <span class="nop">           .          .           	// is the size of the object to scan, or it points to an </span>
<span class="line">   1087</span> <span class="nop">           .          .           	// oblet, in which case we compute the size to scan below. </span>
<span class="line">   1088</span> <span class="nop">           .       30ms           	hbits := heapBitsForAddr(b) </span>
<span class="line">   1089</span> <span class="nop">        20ms       40ms           	s := spanOfUnchecked(b) </span>
<span class="line">   1090</span> <span class="nop">           .          .           	n := s.elemsize </span>
<span class="line">   1091</span> <span class="nop">           .          .           	if n == 0 { </span>
<span class="line">   1092</span> <span class="nop">           .          .           		throw("scanobject n == 0") </span>
<span class="line">   1093</span> <span class="nop">           .          .           	} </span>
<span class="line">   1094</span> <span class="nop">           .          .            </span>
<span class="line">   1095</span> <span class="nop">           .          .           	if n &gt; maxObletBytes { </span>
<span class="line">   1096</span> <span class="nop">           .          .           		// Large object. Break into oblets for better </span>
<span class="line">   1097</span> <span class="nop">           .          .           		// parallelism and lower latency. </span>
<span class="line">   1098</span> <span class="nop">           .          .           		if b == s.base() { </span>
<span class="line">   1099</span> <span class="nop">           .          .           			// It's possible this is a noscan object (not </span>
<span class="line">   1100</span> <span class="nop">           .          .           			// from greyobject, but from other code </span>
<span class="line">   1101</span> <span class="nop">           .          .           			// paths), in which case we must *not* enqueue </span>
<span class="line">   1102</span> <span class="nop">           .          .           			// oblets since their bitmaps will be </span>
<span class="line">   1103</span> <span class="nop">           .          .           			// uninitialized. </span>
<span class="line">   1104</span> <span class="nop">           .          .           			if s.spanclass.noscan() { </span>
<span class="line">   1105</span> <span class="nop">           .          .           				// Bypass the whole scan. </span>
<span class="line">   1106</span> <span class="nop">           .          .           				gcw.bytesMarked += uint64(n) </span>
<span class="line">   1107</span> <span class="nop">           .          .           				return </span>
<span class="line">   1108</span> <span class="nop">           .          .           			} </span>
<span class="line">   1109</span> <span class="nop">           .          .            </span>
<span class="line">   1110</span> <span class="nop">           .          .           			// Enqueue the other oblets to scan later. </span>
<span class="line">   1111</span> <span class="nop">           .          .           			// Some oblets may be in b's scalar tail, but </span>
<span class="line">   1112</span> <span class="nop">           .          .           			// these will be marked as "no more pointers", </span>
<span class="line">   1113</span> <span class="nop">           .          .           			// so we'll drop out immediately when we go to </span>
<span class="line">   1114</span> <span class="nop">           .          .           			// scan those. </span>
<span class="line">   1115</span> <span class="nop">           .          .           			for oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes { </span>
<span class="line">   1116</span> <span class="nop">           .          .           				if !gcw.putFast(oblet) { </span>
<span class="line">   1117</span> <span class="nop">           .          .           					gcw.put(oblet) </span>
<span class="line">   1118</span> <span class="nop">           .          .           				} </span>
<span class="line">   1119</span> <span class="nop">           .          .           			} </span>
<span class="line">   1120</span> <span class="nop">           .          .           		} </span>
<span class="line">   1121</span> <span class="nop">           .          .            </span>
<span class="line">   1122</span> <span class="nop">           .          .           		// Compute the size of the oblet. Since this object </span>
<span class="line">   1123</span> <span class="nop">           .          .           		// must be a large object, s.base() is the beginning </span>
<span class="line">   1124</span> <span class="nop">           .          .           		// of the object. </span>
<span class="line">   1125</span> <span class="nop">           .          .           		n = s.base() + s.elemsize - b </span>
<span class="line">   1126</span> <span class="nop">           .          .           		if n &gt; maxObletBytes { </span>
<span class="line">   1127</span> <span class="nop">           .          .           			n = maxObletBytes </span>
<span class="line">   1128</span> <span class="nop">           .          .           		} </span>
<span class="line">   1129</span> <span class="nop">           .          .           	} </span>
<span class="line">   1130</span> <span class="nop">           .          .            </span>
<span class="line">   1131</span> <span class="nop">           .          .           	var i uintptr </span>
<span class="line">   1132</span> <span class="nop">        90ms       90ms           	for i = 0; i &lt; n; i += sys.PtrSize { </span>
<span class="line">   1133</span> <span class="nop">           .          .           		// Find bits for this word. </span>
<span class="line">   1134</span> <span class="nop">           .          .           		if i != 0 { </span>
<span class="line">   1135</span> <span class="nop">           .          .           			// Avoid needless hbits.next() on last iteration. </span>
<span class="line">   1136</span> <span class="nop">        20ms       40ms           			hbits = hbits.next() </span>
<span class="line">   1137</span> <span class="nop">           .          .           		} </span>
<span class="line">   1138</span> <span class="nop">           .          .           		// Load bits once. See CL 22712 and issue 16973 for discussion. </span>
<span class="line">   1139</span> <span class="nop">        40ms       50ms           		bits := hbits.bits() </span>
<span class="line">   1140</span> <span class="nop">           .          .           		// During checkmarking, 1-word objects store the checkmark </span>
<span class="line">   1141</span> <span class="nop">           .          .           		// in the type bit for the one word. The only one-word objects </span>
<span class="line">   1142</span> <span class="nop">           .          .           		// are pointers, or else they'd be merged with other non-pointer </span>
<span class="line">   1143</span> <span class="nop">           .          .           		// data into larger allocations. </span>
<span class="line">   1144</span> <span class="nop">           .          .           		if i != 1*sys.PtrSize &amp;&amp; bits&amp;bitScan == 0 { </span>
<span class="line">   1145</span> <span class="nop">           .          .           			break // no more pointers in this object </span>
<span class="line">   1146</span> <span class="nop">           .          .           		} </span>
<span class="line">   1147</span> <span class="nop">        10ms       10ms           		if bits&amp;bitPointer == 0 { </span>
<span class="line">   1148</span> <span class="nop">           .          .           			continue // not a pointer </span>
<span class="line">   1149</span> <span class="nop">           .          .           		} </span>
<span class="line">   1150</span> <span class="nop">           .          .            </span>
<span class="line">   1151</span> <span class="nop">           .          .           		// Work here is duplicated in scanblock and above. </span>
<span class="line">   1152</span> <span class="nop">           .          .           		// If you make changes here, make changes there too. </span>
<span class="line">   1153</span> <span class="nop">        20ms       20ms           		obj := *(*uintptr)(unsafe.Pointer(b + i)) </span>
<span class="line">   1154</span> <span class="nop">           .          .            </span>
<span class="line">   1155</span> <span class="nop">           .          .           		// At this point we have extracted the next potential pointer. </span>
<span class="line">   1156</span> <span class="nop">           .          .           		// Quickly filter out nil and pointers back to the current object. </span>
<span class="line">   1157</span> <span class="nop">        60ms       60ms           		if obj != 0 &amp;&amp; obj-b &gt;= n { </span>
<span class="line">   1158</span> <span class="nop">           .          .           			// Test if obj points into the Go heap and, if so, </span>
<span class="line">   1159</span> <span class="nop">           .          .           			// mark the object. </span>
<span class="line">   1160</span> <span class="nop">           .          .           			// </span>
<span class="line">   1161</span> <span class="nop">           .          .           			// Note that it's possible for findObject to </span>
<span class="line">   1162</span> <span class="nop">           .          .           			// fail if obj points to a just-allocated heap </span>
<span class="line">   1163</span> <span class="nop">           .          .           			// object because of a race with growing the </span>
<span class="line">   1164</span> <span class="nop">           .          .           			// heap. In this case, we know the object was </span>
<span class="line">   1165</span> <span class="nop">           .          .           			// just allocated and hence will be marked by </span>
<span class="line">   1166</span> <span class="nop">           .          .           			// allocation itself. </span>
<span class="line">   1167</span> <span class="nop">        20ms      220ms           			if obj, span, objIndex := findObject(obj, b, i); obj != 0 { </span>
<span class="line">   1168</span> <span class="nop">        40ms      250ms           				greyobject(obj, b, i, span, gcw, objIndex) </span>
<span class="line">   1169</span> <span class="nop">           .          .           			} </span>
<span class="line">   1170</span> <span class="nop">           .          .           		} </span>
<span class="line">   1171</span> <span class="nop">           .          .           	} </span>
<span class="line">   1172</span> <span class="nop">        10ms       10ms           	gcw.bytesMarked += uint64(n) </span>
<span class="line">   1173</span> <span class="nop">           .          .           	gcw.scanWork += int64(i) </span>
<span class="line">   1174</span> <span class="nop">           .          .           } </span>
<span class="line">   1175</span> <span class="nop">           .          .            </span>
<span class="line">   1176</span> <span class="nop">           .          .           // Shade the object if it isn't already. </span>
<span class="line">   1177</span> <span class="nop">           .          .           // The object is not nil and known to be in the heap. </span>
</pre>
<h2>runtime.findObject</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mbitmap.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       270ms      370ms (flat, cum)  2.96%
<span class="line">    357</span> <span class="nop">           .          .           // findObject panics. </span>
<span class="line">    358</span> <span class="nop">           .          .           // </span>
<span class="line">    359</span> <span class="nop">           .          .           // refBase and refOff optionally give the base address of the object </span>
<span class="line">    360</span> <span class="nop">           .          .           // in which the pointer p was found and the byte offset at which it </span>
<span class="line">    361</span> <span class="nop">           .          .           // was found. These are used for error reporting. </span>
<span class="line">    362</span> <span class="nop">        10ms       10ms           func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr) { </span>
<span class="line">    363</span> <span class="nop">        10ms      110ms           	s = spanOf(p) </span>
<span class="line">    364</span> <span class="nop">           .          .           	// If p is a bad pointer, it may not be in s's bounds. </span>
<span class="line">    365</span> <span class="nop">       120ms      120ms           	if s == nil || p &lt; s.base() || p &gt;= s.limit || s.state != mSpanInUse { </span>
<span class="line">    366</span> <span class="nop">           .          .           		if s == nil || s.state == mSpanManual { </span>
<span class="line">    367</span> <span class="nop">           .          .           			// If s is nil, the virtual address has never been part of the heap. </span>
<span class="line">    368</span> <span class="nop">           .          .           			// This pointer may be to some mmap'd region, so we allow it. </span>
<span class="line">    369</span> <span class="nop">           .          .           			// Pointers into stacks are also ok, the runtime manages these explicitly. </span>
<span class="line">    370</span> <span class="nop">        10ms       10ms           			return </span>
<span class="line">    371</span> <span class="nop">           .          .           		} </span>
<span class="line">    372</span> <span class="nop">           .          .            </span>
<span class="line">    373</span> <span class="nop">           .          .           		// The following ensures that we are rigorous about what data </span>
<span class="line">    374</span> <span class="nop">           .          .           		// structures hold valid pointers. </span>
<span class="line">    375</span> <span class="nop">           .          .           		if debug.invalidptr != 0 { </span>
<span class="line">    376</span> <span class="nop">           .          .           			// Typically this indicates an incorrect use </span>
<span class="line">    377</span> <span class="nop">           .          .           			// of unsafe or cgo to store a bad pointer in </span>
<span class="line">    378</span> <span class="nop">           .          .           			// the Go heap. It may also indicate a runtime </span>
<span class="line">    379</span> <span class="nop">           .          .           			// bug. </span>
<span class="line">    380</span> <span class="nop">           .          .           			// </span>
<span class="line">    381</span> <span class="nop">           .          .           			// TODO(austin): We could be more aggressive </span>
<span class="line">    382</span> <span class="nop">           .          .           			// and detect pointers to unallocated objects </span>
<span class="line">    383</span> <span class="nop">           .          .           			// in allocated spans. </span>
<span class="line">    384</span> <span class="nop">           .          .           			printlock() </span>
<span class="line">    385</span> <span class="nop">           .          .           			print("runtime: pointer ", hex(p)) </span>
<span class="line">    386</span> <span class="nop">           .          .           			if s.state != mSpanInUse { </span>
<span class="line">    387</span> <span class="nop">           .          .           				print(" to unallocated span") </span>
<span class="line">    388</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    389</span> <span class="nop">           .          .           				print(" to unused region of span") </span>
<span class="line">    390</span> <span class="nop">           .          .           			} </span>
<span class="line">    391</span> <span class="nop">           .          .           			print(" span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", s.state, "\n") </span>
<span class="line">    392</span> <span class="nop">           .          .           			if refBase != 0 { </span>
<span class="line">    393</span> <span class="nop">           .          .           				print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n") </span>
<span class="line">    394</span> <span class="nop">           .          .           				gcDumpObject("object", refBase, refOff) </span>
<span class="line">    395</span> <span class="nop">           .          .           			} </span>
<span class="line">    396</span> <span class="nop">           .          .           			getg().m.traceback = 2 </span>
<span class="line">    397</span> <span class="nop">           .          .           			throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)") </span>
<span class="line">    398</span> <span class="nop">           .          .           		} </span>
<span class="line">    399</span> <span class="nop">           .          .           		return </span>
<span class="line">    400</span> <span class="nop">           .          .           	} </span>
<span class="line">    401</span> <span class="nop">           .          .           	// If this span holds object of a power of 2 size, just mask off the bits to </span>
<span class="line">    402</span> <span class="nop">           .          .           	// the interior of the object. Otherwise use the size to get the base. </span>
<span class="line">    403</span> <span class="nop">        10ms       10ms           	if s.baseMask != 0 { </span>
<span class="line">    404</span> <span class="nop">           .          .           		// optimize for power of 2 sized objects. </span>
<span class="line">    405</span> <span class="nop">           .          .           		base = s.base() </span>
<span class="line">    406</span> <span class="nop">           .          .           		base = base + (p-base)&amp;uintptr(s.baseMask) </span>
<span class="line">    407</span> <span class="nop">        30ms       30ms           		objIndex = (base - s.base()) &gt;&gt; s.divShift </span>
<span class="line">    408</span> <span class="nop">           .          .           		// base = p &amp; s.baseMask is faster for small spans, </span>
<span class="line">    409</span> <span class="nop">           .          .           		// but doesn't work for large spans. </span>
<span class="line">    410</span> <span class="nop">           .          .           		// Overall, it's faster to use the more general computation above. </span>
<span class="line">    411</span> <span class="nop">           .          .           	} else { </span>
<span class="line">    412</span> <span class="nop">        20ms       20ms           		base = s.base() </span>
<span class="line">    413</span> <span class="nop">           .          .           		if p-base &gt;= s.elemsize { </span>
<span class="line">    414</span> <span class="nop">           .          .           			// n := (p - base) / s.elemsize, using division by multiplication </span>
<span class="line">    415</span> <span class="nop">        10ms       10ms           			objIndex = uintptr(p-base) &gt;&gt; s.divShift * uintptr(s.divMul) &gt;&gt; s.divShift2 </span>
<span class="line">    416</span> <span class="nop">           .          .           			base += objIndex * s.elemsize </span>
<span class="line">    417</span> <span class="nop">           .          .           		} </span>
<span class="line">    418</span> <span class="nop">           .          .           	} </span>
<span class="line">    419</span> <span class="nop">        50ms       50ms           	return </span>
<span class="line">    420</span> <span class="nop">           .          .           } </span>
<span class="line">    421</span> <span class="nop">           .          .            </span>
<span class="line">    422</span> <span class="nop">           .          .           // next returns the heapBits describing the next pointer-sized word in memory. </span>
<span class="line">    423</span> <span class="nop">           .          .           // That is, if h describes address p, h.next() describes p+ptrSize. </span>
<span class="line">    424</span> <span class="nop">           .          .           // Note that next does not modify h. The caller must record the result. </span>
</pre>
<h2>compress/flate.(*dictDecoder).tryWriteCopy</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\dict_decoder.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       230ms      480ms (flat, cum)  3.84%
<span class="line">    149</span> <span class="nop">           .          .           // </span>
<span class="line">    150</span> <span class="nop">           .          .           // This method is designed to be inlined for performance reasons. </span>
<span class="line">    151</span> <span class="nop">           .          .           // </span>
<span class="line">    152</span> <span class="nop">           .          .           // This invariant must be kept: 0 &lt; dist &lt;= histSize() </span>
<span class="line">    153</span> <span class="nop">           .          .           func (dd *dictDecoder) tryWriteCopy(dist, length int) int { </span>
<span class="line">    154</span> <span class="nop">        20ms       20ms           	dstPos := dd.wrPos </span>
<span class="line">    155</span> <span class="nop">           .          .           	endPos := dstPos + length </span>
<span class="line">    156</span> <span class="nop">        10ms       10ms           	if dstPos &lt; dist || endPos &gt; len(dd.hist) { </span>
<span class="line">    157</span> <span class="nop">           .          .           		return 0 </span>
<span class="line">    158</span> <span class="nop">           .          .           	} </span>
<span class="line">    159</span> <span class="nop">           .          .           	dstBase := dstPos </span>
<span class="line">    160</span> <span class="nop">        10ms       10ms           	srcPos := dstPos - dist </span>
<span class="line">    161</span> <span class="nop">           .          .            </span>
<span class="line">    162</span> <span class="nop">           .          .           	// Copy possibly overlapping section before destination position. </span>
<span class="line">    163</span> <span class="nop">           .          .           loop: </span>
<span class="line">    164</span> <span class="nop">       170ms      420ms           	dstPos += copy(dd.hist[dstPos:endPos], dd.hist[srcPos:dstPos]) </span>
<span class="line">    165</span> <span class="nop">           .          .           	if dstPos &lt; endPos { </span>
<span class="line">    166</span> <span class="nop">           .          .           		goto loop // Avoid for-loop so that this function can be inlined </span>
<span class="line">    167</span> <span class="nop">           .          .           	} </span>
<span class="line">    168</span> <span class="nop">           .          .            </span>
<span class="line">    169</span> <span class="nop">        20ms       20ms           	dd.wrPos = dstPos </span>
<span class="line">    170</span> <span class="nop">           .          .           	return dstPos - dstBase </span>
<span class="line">    171</span> <span class="nop">           .          .           } </span>
<span class="line">    172</span> <span class="nop">           .          .            </span>
<span class="line">    173</span> <span class="nop">           .          .           // readFlush returns a slice of the historical buffer that is ready to be </span>
<span class="line">    174</span> <span class="nop">           .          .           // emitted to the user. The data returned by readFlush must be fully consumed </span>
</pre>
<h2>runtime.step</h2><p class="filename">C:\blockchainenv\Go\src\runtime\symtab.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       210ms      230ms (flat, cum)  1.84%
<span class="line">    791</span> <span class="nop">           .          .           	} </span>
<span class="line">    792</span> <span class="nop">           .          .           	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize)) </span>
<span class="line">    793</span> <span class="nop">           .          .           } </span>
<span class="line">    794</span> <span class="nop">           .          .            </span>
<span class="line">    795</span> <span class="nop">           .          .           // step advances to the next pc, value pair in the encoded table. </span>
<span class="line">    796</span> <span class="nop">        30ms       30ms           func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) { </span>
<span class="line">    797</span> <span class="nop">           .          .           	// For both uvdelta and pcdelta, the common case (~70%) </span>
<span class="line">    798</span> <span class="nop">           .          .           	// is that they are a single byte. If so, avoid calling readvarint. </span>
<span class="line">    799</span> <span class="nop">           .          .           	uvdelta := uint32(p[0]) </span>
<span class="line">    800</span> <span class="nop">           .          .           	if uvdelta == 0 &amp;&amp; !first { </span>
<span class="line">    801</span> <span class="nop">           .          .           		return nil, false </span>
<span class="line">    802</span> <span class="nop">           .          .           	} </span>
<span class="line">    803</span> <span class="nop">           .          .           	n := uint32(1) </span>
<span class="line">    804</span> <span class="nop">        10ms       10ms           	if uvdelta&amp;0x80 != 0 { </span>
<span class="line">    805</span> <span class="nop">           .          .           		n, uvdelta = readvarint(p) </span>
<span class="line">    806</span> <span class="nop">           .          .           	} </span>
<span class="line">    807</span> <span class="nop">        20ms       20ms           	*val += int32(-(uvdelta &amp; 1) ^ (uvdelta &gt;&gt; 1)) </span>
<span class="line">    808</span> <span class="nop">        50ms       50ms           	p = p[n:] </span>
<span class="line">    809</span> <span class="nop">           .          .            </span>
<span class="line">    810</span> <span class="nop">        10ms       10ms           	pcdelta := uint32(p[0]) </span>
<span class="line">    811</span> <span class="nop">           .          .           	n = 1 </span>
<span class="line">    812</span> <span class="nop">        20ms       20ms           	if pcdelta&amp;0x80 != 0 { </span>
<span class="line">    813</span> <span class="nop">        20ms       40ms           		n, pcdelta = readvarint(p) </span>
<span class="line">    814</span> <span class="nop">           .          .           	} </span>
<span class="line">    815</span> <span class="nop">        10ms       10ms           	p = p[n:] </span>
<span class="line">    816</span> <span class="nop">           .          .           	*pc += uintptr(pcdelta * sys.PCQuantum) </span>
<span class="line">    817</span> <span class="nop">        40ms       40ms           	return p, true </span>
<span class="line">    818</span> <span class="nop">           .          .           } </span>
<span class="line">    819</span> <span class="nop">           .          .            </span>
<span class="line">    820</span> <span class="nop">           .          .           // readvarint reads a varint from p. </span>
<span class="line">    821</span> <span class="nop">           .          .           func readvarint(p []byte) (read uint32, val uint32) { </span>
<span class="line">    822</span> <span class="nop">           .          .           	var v, shift, n uint32 </span>
</pre>
<h2>runtime.(*guintptr).cas</h2><p class="filename">C:\blockchainenv\Go\src\runtime\runtime2.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       200ms      200ms (flat, cum)  1.60%
<span class="line">    205</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    206</span> <span class="nop">           .          .           func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) } </span>
<span class="line">    207</span> <span class="nop">           .          .            </span>
<span class="line">    208</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    209</span> <span class="nop">           .          .           func (gp *guintptr) cas(old, new guintptr) bool { </span>
<span class="line">    210</span> <span class="nop">       200ms      200ms           	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new)) </span>
<span class="line">    211</span> <span class="nop">           .          .           } </span>
<span class="line">    212</span> <span class="nop">           .          .            </span>
<span class="line">    213</span> <span class="nop">           .          .           // setGNoWB performs *gp = new without a write barrier. </span>
<span class="line">    214</span> <span class="nop">           .          .           // For times when it's impractical to use a guintptr. </span>
<span class="line">    215</span> <span class="nop">           .          .           //go:nosplit </span>
</pre>
<h2>runtime.stdcall1</h2><p class="filename">C:\blockchainenv\Go\src\runtime\os_windows.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       190ms      190ms (flat, cum)  1.52%
<span class="line">    771</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    772</span> <span class="nop">           .          .           func stdcall1(fn stdFunction, a0 uintptr) uintptr { </span>
<span class="line">    773</span> <span class="nop">           .          .           	mp := getg().m </span>
<span class="line">    774</span> <span class="nop">           .          .           	mp.libcall.n = 1 </span>
<span class="line">    775</span> <span class="nop">           .          .           	mp.libcall.args = uintptr(noescape(unsafe.Pointer(&amp;a0))) </span>
<span class="line">    776</span> <span class="nop">       190ms      190ms           	return stdcall(fn) </span>
<span class="line">    777</span> <span class="nop">           .          .           } </span>
<span class="line">    778</span> <span class="nop">           .          .            </span>
<span class="line">    779</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    780</span> <span class="nop">           .          .           func stdcall2(fn stdFunction, a0, a1 uintptr) uintptr { </span>
<span class="line">    781</span> <span class="nop">           .          .           	mp := getg().m </span>
</pre>
<h2>runtime.pcvalue</h2><p class="filename">C:\blockchainenv\Go\src\runtime\symtab.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       190ms      430ms (flat, cum)  3.44%
<span class="line">    613</span> <span class="nop">           .          .           // In practice, this appears to be fairly randomly and evenly distributed. </span>
<span class="line">    614</span> <span class="nop">           .          .           func pcvalueCacheKey(targetpc uintptr) uintptr { </span>
<span class="line">    615</span> <span class="nop">           .          .           	return (targetpc / sys.PtrSize) % uintptr(len(pcvalueCache{}.entries)) </span>
<span class="line">    616</span> <span class="nop">           .          .           } </span>
<span class="line">    617</span> <span class="nop">           .          .            </span>
<span class="line">    618</span> <span class="nop">        20ms       20ms           func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 { </span>
<span class="line">    619</span> <span class="nop">        10ms       10ms           	if off == 0 { </span>
<span class="line">    620</span> <span class="nop">           .          .           		return -1 </span>
<span class="line">    621</span> <span class="nop">           .          .           	} </span>
<span class="line">    622</span> <span class="nop">           .          .            </span>
<span class="line">    623</span> <span class="nop">           .          .           	// Check the cache. This speeds up walks of deep stacks, which </span>
<span class="line">    624</span> <span class="nop">           .          .           	// tend to have the same recursive functions over and over. </span>
<span class="line">    625</span> <span class="nop">           .          .           	// </span>
<span class="line">    626</span> <span class="nop">           .          .           	// This cache is small enough that full associativity is </span>
<span class="line">    627</span> <span class="nop">           .          .           	// cheaper than doing the hashing for a less associative </span>
<span class="line">    628</span> <span class="nop">           .          .           	// cache. </span>
<span class="line">    629</span> <span class="nop">        20ms       20ms           	if cache != nil { </span>
<span class="line">    630</span> <span class="nop">           .          .           		x := pcvalueCacheKey(targetpc) </span>
<span class="line">    631</span> <span class="nop">           .          .           		for i := range cache.entries[x] { </span>
<span class="line">    632</span> <span class="nop">           .          .           			// We check off first because we're more </span>
<span class="line">    633</span> <span class="nop">           .          .           			// likely to have multiple entries with </span>
<span class="line">    634</span> <span class="nop">           .          .           			// different offsets for the same targetpc </span>
<span class="line">    635</span> <span class="nop">           .          .           			// than the other way around, so we'll usually </span>
<span class="line">    636</span> <span class="nop">           .          .           			// fail in the first clause. </span>
<span class="line">    637</span> <span class="nop">        10ms       10ms           			ent := &amp;cache.entries[x][i] </span>
<span class="line">    638</span> <span class="nop">        20ms       20ms           			if ent.off == off &amp;&amp; ent.targetpc == targetpc { </span>
<span class="line">    639</span> <span class="nop">           .          .           				return ent.val </span>
<span class="line">    640</span> <span class="nop">           .          .           			} </span>
<span class="line">    641</span> <span class="nop">           .          .           		} </span>
<span class="line">    642</span> <span class="nop">           .          .           	} </span>
<span class="line">    643</span> <span class="nop">           .          .            </span>
<span class="line">    644</span> <span class="nop">           .          .           	if !f.valid() { </span>
<span class="line">    645</span> <span class="nop">           .          .           		if strict &amp;&amp; panicking == 0 { </span>
<span class="line">    646</span> <span class="nop">           .          .           			print("runtime: no module data for ", hex(f.entry), "\n") </span>
<span class="line">    647</span> <span class="nop">           .          .           			throw("no module data") </span>
<span class="line">    648</span> <span class="nop">           .          .           		} </span>
<span class="line">    649</span> <span class="nop">           .          .           		return -1 </span>
<span class="line">    650</span> <span class="nop">           .          .           	} </span>
<span class="line">    651</span> <span class="nop">           .          .           	datap := f.datap </span>
<span class="line">    652</span> <span class="nop">        10ms       10ms           	p := datap.pclntable[off:] </span>
<span class="line">    653</span> <span class="nop">        10ms       10ms           	pc := f.entry </span>
<span class="line">    654</span> <span class="nop">           .          .           	val := int32(-1) </span>
<span class="line">    655</span> <span class="nop">           .          .           	for { </span>
<span class="line">    656</span> <span class="nop">           .          .           		var ok bool </span>
<span class="line">    657</span> <span class="nop">        90ms      320ms           		p, ok = step(p, &amp;pc, &amp;val, pc == f.entry) </span>
<span class="line">    658</span> <span class="nop">           .          .           		if !ok { </span>
<span class="line">    659</span> <span class="nop">           .          .           			break </span>
<span class="line">    660</span> <span class="nop">           .          .           		} </span>
<span class="line">    661</span> <span class="nop">           .          .           		if targetpc &lt; pc { </span>
<span class="line">    662</span> <span class="nop">           .          .           			// Replace a random entry in the cache. Random </span>
<span class="line">    663</span> <span class="nop">           .          .           			// replacement prevents a performance cliff if </span>
<span class="line">    664</span> <span class="nop">           .          .           			// a recursive stack's cycle is slightly </span>
<span class="line">    665</span> <span class="nop">           .          .           			// larger than the cache. </span>
<span class="line">    666</span> <span class="nop">           .          .           			// Put the new element at the beginning, </span>
<span class="line">    667</span> <span class="nop">           .          .           			// since it is the most likely to be newly used. </span>
<span class="line">    668</span> <span class="nop">           .          .           			if cache != nil { </span>
<span class="line">    669</span> <span class="nop">           .       10ms           				x := pcvalueCacheKey(targetpc) </span>
<span class="line">    670</span> <span class="nop">           .          .           				e := &amp;cache.entries[x] </span>
<span class="line">    671</span> <span class="nop">           .          .           				ci := fastrand() % uint32(len(cache.entries[x])) </span>
<span class="line">    672</span> <span class="nop">           .          .           				e[ci] = e[0] </span>
<span class="line">    673</span> <span class="nop">           .          .           				e[0] = pcvalueCacheEnt{ </span>
<span class="line">    674</span> <span class="nop">           .          .           					targetpc: targetpc, </span>
</pre>
<h2>regexp.(*machine).step</h2><p class="filename">C:\blockchainenv\Go\src\regexp\exec.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       160ms      340ms (flat, cum)  2.72%
<span class="line">    255</span> <span class="nop">           .          .           // step executes one step of the machine, running each of the threads </span>
<span class="line">    256</span> <span class="nop">           .          .           // on runq and appending new threads to nextq. </span>
<span class="line">    257</span> <span class="nop">           .          .           // The step processes the rune c (which may be endOfText), </span>
<span class="line">    258</span> <span class="nop">           .          .           // which starts at position pos and ends at nextPos. </span>
<span class="line">    259</span> <span class="nop">           .          .           // nextCond gives the setting for the empty-width flags after c. </span>
<span class="line">    260</span> <span class="nop">        20ms       20ms           func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag) { </span>
<span class="line">    261</span> <span class="nop">           .          .           	longest := m.re.longest </span>
<span class="line">    262</span> <span class="nop">           .          .           	for j := 0; j &lt; len(runq.dense); j++ { </span>
<span class="line">    263</span> <span class="nop">           .          .           		d := &amp;runq.dense[j] </span>
<span class="line">    264</span> <span class="nop">           .          .           		t := d.t </span>
<span class="line">    265</span> <span class="nop">           .          .           		if t == nil { </span>
<span class="line">    266</span> <span class="nop">           .          .           			continue </span>
<span class="line">    267</span> <span class="nop">           .          .           		} </span>
<span class="line">    268</span> <span class="nop">           .          .           		if longest &amp;&amp; m.matched &amp;&amp; len(t.cap) &gt; 0 &amp;&amp; m.matchcap[0] &lt; t.cap[0] { </span>
<span class="line">    269</span> <span class="nop">           .          .           			m.pool = append(m.pool, t) </span>
<span class="line">    270</span> <span class="nop">           .          .           			continue </span>
<span class="line">    271</span> <span class="nop">           .          .           		} </span>
<span class="line">    272</span> <span class="nop">        10ms       10ms           		i := t.inst </span>
<span class="line">    273</span> <span class="nop">           .          .           		add := false </span>
<span class="line">    274</span> <span class="nop">        20ms       20ms           		switch i.Op { </span>
<span class="line">    275</span> <span class="nop">           .          .           		default: </span>
<span class="line">    276</span> <span class="nop">           .          .           			panic("bad inst") </span>
<span class="line">    277</span> <span class="nop">           .          .            </span>
<span class="line">    278</span> <span class="nop">           .          .           		case syntax.InstMatch: </span>
<span class="line">    279</span> <span class="nop">           .          .           			if len(t.cap) &gt; 0 &amp;&amp; (!longest || !m.matched || m.matchcap[1] &lt; pos) { </span>
<span class="line">    280</span> <span class="nop">           .          .           				t.cap[1] = pos </span>
<span class="line">    281</span> <span class="nop">           .          .           				copy(m.matchcap, t.cap) </span>
<span class="line">    282</span> <span class="nop">           .          .           			} </span>
<span class="line">    283</span> <span class="nop">           .          .           			if !longest { </span>
<span class="line">    284</span> <span class="nop">           .          .           				// First-match mode: cut off all lower-priority threads. </span>
<span class="line">    285</span> <span class="nop">           .          .           				for _, d := range runq.dense[j+1:] { </span>
<span class="line">    286</span> <span class="nop">           .          .           					if d.t != nil { </span>
<span class="line">    287</span> <span class="nop">           .          .           						m.pool = append(m.pool, d.t) </span>
<span class="line">    288</span> <span class="nop">           .          .           					} </span>
<span class="line">    289</span> <span class="nop">           .          .           				} </span>
<span class="line">    290</span> <span class="nop">           .          .           				runq.dense = runq.dense[:0] </span>
<span class="line">    291</span> <span class="nop">           .          .           			} </span>
<span class="line">    292</span> <span class="nop">           .          .           			m.matched = true </span>
<span class="line">    293</span> <span class="nop">           .          .            </span>
<span class="line">    294</span> <span class="nop">           .          .           		case syntax.InstRune: </span>
<span class="line">    295</span> <span class="nop">           .       10ms           			add = i.MatchRune(c) </span>
<span class="line">    296</span> <span class="nop">        10ms       10ms           		case syntax.InstRune1: </span>
<span class="line">    297</span> <span class="nop">        40ms       40ms           			add = c == i.Rune[0] </span>
<span class="line">    298</span> <span class="nop">           .          .           		case syntax.InstRuneAny: </span>
<span class="line">    299</span> <span class="nop">           .          .           			add = true </span>
<span class="line">    300</span> <span class="nop">           .          .           		case syntax.InstRuneAnyNotNL: </span>
<span class="line">    301</span> <span class="nop">           .          .           			add = c != '\n' </span>
<span class="line">    302</span> <span class="nop">           .          .           		} </span>
<span class="line">    303</span> <span class="nop">           .          .           		if add { </span>
<span class="line">    304</span> <span class="nop">        50ms      200ms           			t = m.add(nextq, i.Out, nextPos, t.cap, nextCond, t) </span>
<span class="line">    305</span> <span class="nop">           .          .           		} </span>
<span class="line">    306</span> <span class="nop">           .          .           		if t != nil { </span>
<span class="line">    307</span> <span class="nop">        10ms       30ms           			m.pool = append(m.pool, t) </span>
<span class="line">    308</span> <span class="nop">           .          .           		} </span>
<span class="line">    309</span> <span class="nop">           .          .           	} </span>
<span class="line">    310</span> <span class="nop">           .          .           	runq.dense = runq.dense[:0] </span>
<span class="line">    311</span> <span class="nop">           .          .           } </span>
<span class="line">    312</span> <span class="nop">           .          .            </span>
</pre>
<h2>compress/flate.(*decompressor).moreBits</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\inflate.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       150ms      290ms (flat, cum)  2.32%
<span class="line">    690</span> <span class="nop">           .          .           		return io.ErrUnexpectedEOF </span>
<span class="line">    691</span> <span class="nop">           .          .           	} </span>
<span class="line">    692</span> <span class="nop">           .          .           	return e </span>
<span class="line">    693</span> <span class="nop">           .          .           } </span>
<span class="line">    694</span> <span class="nop">           .          .            </span>
<span class="line">    695</span> <span class="nop">        70ms       70ms           func (f *decompressor) moreBits() error { </span>
<span class="line">    696</span> <span class="nop">           .      140ms           	c, err := f.r.ReadByte() </span>
<span class="line">    697</span> <span class="nop">           .          .           	if err != nil { </span>
<span class="line">    698</span> <span class="nop">           .          .           		return noEOF(err) </span>
<span class="line">    699</span> <span class="nop">           .          .           	} </span>
<span class="line">    700</span> <span class="nop">           .          .           	f.roffset++ </span>
<span class="line">    701</span> <span class="nop">        30ms       30ms           	f.b |= uint32(c) &lt;&lt; f.nb </span>
<span class="line">    702</span> <span class="nop">        30ms       30ms           	f.nb += 8 </span>
<span class="line">    703</span> <span class="nop">        20ms       20ms           	return nil </span>
<span class="line">    704</span> <span class="nop">           .          .           } </span>
<span class="line">    705</span> <span class="nop">           .          .            </span>
<span class="line">    706</span> <span class="nop">           .          .           // Read the next Huffman-encoded symbol from f according to h. </span>
<span class="line">    707</span> <span class="nop">           .          .           func (f *decompressor) huffSym(h *huffmanDecoder) (int, error) { </span>
<span class="line">    708</span> <span class="nop">           .          .           	// Since a huffmanDecoder can be empty or be composed of a degenerate tree </span>
</pre>
<h2>runtime.greyobject</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mgcmark.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       140ms      220ms (flat, cum)  1.76%
<span class="line">   1189</span> <span class="nop">           .          .           // base and off are for debugging only and could be removed. </span>
<span class="line">   1190</span> <span class="nop">           .          .           // </span>
<span class="line">   1191</span> <span class="nop">           .          .           // See also wbBufFlush1, which partially duplicates this logic. </span>
<span class="line">   1192</span> <span class="nop">           .          .           // </span>
<span class="line">   1193</span> <span class="nop">           .          .           //go:nowritebarrierrec </span>
<span class="line">   1194</span> <span class="nop">        20ms       20ms           func greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr) { </span>
<span class="line">   1195</span> <span class="nop">           .          .           	// obj should be start of allocation, and so must be at least pointer-aligned. </span>
<span class="line">   1196</span> <span class="nop">           .          .           	if obj&amp;(sys.PtrSize-1) != 0 { </span>
<span class="line">   1197</span> <span class="nop">           .          .           		throw("greyobject: obj not pointer-aligned") </span>
<span class="line">   1198</span> <span class="nop">           .          .           	} </span>
<span class="line">   1199</span> <span class="nop">        10ms       20ms           	mbits := span.markBitsForIndex(objIndex) </span>
<span class="line">   1200</span> <span class="nop">           .          .            </span>
<span class="line">   1201</span> <span class="nop">           .          .           	if useCheckmark { </span>
<span class="line">   1202</span> <span class="nop">           .          .           		if !mbits.isMarked() { </span>
<span class="line">   1203</span> <span class="nop">           .          .           			printlock() </span>
<span class="line">   1204</span> <span class="nop">           .          .           			print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n") </span>
<span class="line">   1205</span> <span class="nop">           .          .           			print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n") </span>
<span class="line">   1206</span> <span class="nop">           .          .            </span>
<span class="line">   1207</span> <span class="nop">           .          .           			// Dump the source (base) object </span>
<span class="line">   1208</span> <span class="nop">           .          .           			gcDumpObject("base", base, off) </span>
<span class="line">   1209</span> <span class="nop">           .          .            </span>
<span class="line">   1210</span> <span class="nop">           .          .           			// Dump the object </span>
<span class="line">   1211</span> <span class="nop">           .          .           			gcDumpObject("obj", obj, ^uintptr(0)) </span>
<span class="line">   1212</span> <span class="nop">           .          .            </span>
<span class="line">   1213</span> <span class="nop">           .          .           			getg().m.traceback = 2 </span>
<span class="line">   1214</span> <span class="nop">           .          .           			throw("checkmark found unmarked object") </span>
<span class="line">   1215</span> <span class="nop">           .          .           		} </span>
<span class="line">   1216</span> <span class="nop">           .          .           		hbits := heapBitsForAddr(obj) </span>
<span class="line">   1217</span> <span class="nop">           .          .           		if hbits.isCheckmarked(span.elemsize) { </span>
<span class="line">   1218</span> <span class="nop">           .          .           			return </span>
<span class="line">   1219</span> <span class="nop">           .          .           		} </span>
<span class="line">   1220</span> <span class="nop">           .          .           		hbits.setCheckmarked(span.elemsize) </span>
<span class="line">   1221</span> <span class="nop">           .          .           		if !hbits.isCheckmarked(span.elemsize) { </span>
<span class="line">   1222</span> <span class="nop">           .          .           			throw("setCheckmarked and isCheckmarked disagree") </span>
<span class="line">   1223</span> <span class="nop">           .          .           		} </span>
<span class="line">   1224</span> <span class="nop">           .          .           	} else { </span>
<span class="line">   1225</span> <span class="nop">           .          .           		if debug.gccheckmark &gt; 0 &amp;&amp; span.isFree(objIndex) { </span>
<span class="line">   1226</span> <span class="nop">           .          .           			print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n") </span>
<span class="line">   1227</span> <span class="nop">           .          .           			gcDumpObject("base", base, off) </span>
<span class="line">   1228</span> <span class="nop">           .          .           			gcDumpObject("obj", obj, ^uintptr(0)) </span>
<span class="line">   1229</span> <span class="nop">           .          .           			getg().m.traceback = 2 </span>
<span class="line">   1230</span> <span class="nop">           .          .           			throw("marking free object") </span>
<span class="line">   1231</span> <span class="nop">           .          .           		} </span>
<span class="line">   1232</span> <span class="nop">           .          .            </span>
<span class="line">   1233</span> <span class="nop">           .          .           		// If marked we have nothing to do. </span>
<span class="line">   1234</span> <span class="nop">           .       30ms           		if mbits.isMarked() { </span>
<span class="line">   1235</span> <span class="nop">        30ms       30ms           			return </span>
<span class="line">   1236</span> <span class="nop">           .          .           		} </span>
<span class="line">   1237</span> <span class="nop">           .          .           		mbits.setMarked() </span>
<span class="line">   1238</span> <span class="nop">           .          .            </span>
<span class="line">   1239</span> <span class="nop">           .          .           		// Mark span. </span>
<span class="line">   1240</span> <span class="nop">        60ms       90ms           		arena, pageIdx, pageMask := pageIndexOf(span.base()) </span>
<span class="line">   1241</span> <span class="nop">        10ms       10ms           		if arena.pageMarks[pageIdx]&amp;pageMask == 0 { </span>
<span class="line">   1242</span> <span class="nop">           .          .           			atomic.Or8(&amp;arena.pageMarks[pageIdx], pageMask) </span>
<span class="line">   1243</span> <span class="nop">           .          .           		} </span>
<span class="line">   1244</span> <span class="nop">           .          .            </span>
<span class="line">   1245</span> <span class="nop">           .          .           		// If this is a noscan object, fast-track it to black </span>
<span class="line">   1246</span> <span class="nop">           .          .           		// instead of greying it. </span>
<span class="line">   1247</span> <span class="nop">        10ms       10ms           		if span.spanclass.noscan() { </span>
<span class="line">   1248</span> <span class="nop">           .          .           			gcw.bytesMarked += uint64(span.elemsize) </span>
<span class="line">   1249</span> <span class="nop">           .          .           			return </span>
<span class="line">   1250</span> <span class="nop">           .          .           		} </span>
<span class="line">   1251</span> <span class="nop">           .          .           	} </span>
<span class="line">   1252</span> <span class="nop">           .          .            </span>
<span class="line">   1253</span> <span class="nop">           .          .           	// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but </span>
<span class="line">   1254</span> <span class="nop">           .          .           	// seems like a nice optimization that can be added back in. </span>
<span class="line">   1255</span> <span class="nop">           .          .           	// There needs to be time between the PREFETCH and the use. </span>
<span class="line">   1256</span> <span class="nop">           .          .           	// Previously we put the obj in an 8 element buffer that is drained at a rate </span>
<span class="line">   1257</span> <span class="nop">           .          .           	// to give the PREFETCH time to do its work. </span>
<span class="line">   1258</span> <span class="nop">           .          .           	// Use of PREFETCHNTA might be more appropriate than PREFETCH </span>
<span class="line">   1259</span> <span class="nop">           .       10ms           	if !gcw.putFast(obj) { </span>
<span class="line">   1260</span> <span class="nop">           .          .           		gcw.put(obj) </span>
<span class="line">   1261</span> <span class="nop">           .          .           	} </span>
<span class="line">   1262</span> <span class="nop">           .          .           } </span>
<span class="line">   1263</span> <span class="nop">           .          .            </span>
<span class="line">   1264</span> <span class="nop">           .          .           // gcDumpObject dumps the contents of obj for debugging and marks the </span>
</pre>
<h2>runtime.stdcall6</h2><p class="filename">C:\blockchainenv\Go\src\runtime\os_windows.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       130ms      130ms (flat, cum)  1.04%
<span class="line">    811</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    812</span> <span class="nop">           .          .           func stdcall6(fn stdFunction, a0, a1, a2, a3, a4, a5 uintptr) uintptr { </span>
<span class="line">    813</span> <span class="nop">           .          .           	mp := getg().m </span>
<span class="line">    814</span> <span class="nop">           .          .           	mp.libcall.n = 6 </span>
<span class="line">    815</span> <span class="nop">           .          .           	mp.libcall.args = uintptr(noescape(unsafe.Pointer(&amp;a0))) </span>
<span class="line">    816</span> <span class="nop">       130ms      130ms           	return stdcall(fn) </span>
<span class="line">    817</span> <span class="nop">           .          .           } </span>
<span class="line">    818</span> <span class="nop">           .          .            </span>
<span class="line">    819</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    820</span> <span class="nop">           .          .           func stdcall7(fn stdFunction, a0, a1, a2, a3, a4, a5, a6 uintptr) uintptr { </span>
<span class="line">    821</span> <span class="nop">           .          .           	mp := getg().m </span>
</pre>
<h2>runtime.spanOf</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mheap.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       110ms      110ms (flat, cum)  0.88%
<span class="line">    711</span> <span class="nop">           .          .           	// This function looks big, but we use a lot of constant </span>
<span class="line">    712</span> <span class="nop">           .          .           	// folding around arenaL1Bits to get it under the inlining </span>
<span class="line">    713</span> <span class="nop">           .          .           	// budget. Also, many of the checks here are safety checks </span>
<span class="line">    714</span> <span class="nop">           .          .           	// that Go needs to do anyway, so the generated code is quite </span>
<span class="line">    715</span> <span class="nop">           .          .           	// short. </span>
<span class="line">    716</span> <span class="nop">        10ms       10ms           	ri := arenaIndex(p) </span>
<span class="line">    717</span> <span class="nop">           .          .           	if arenaL1Bits == 0 { </span>
<span class="line">    718</span> <span class="nop">           .          .           		// If there's no L1, then ri.l1() can't be out of bounds but ri.l2() can. </span>
<span class="line">    719</span> <span class="nop">           .          .           		if ri.l2() &gt;= uint(len(mheap_.arenas[0])) { </span>
<span class="line">    720</span> <span class="nop">           .          .           			return nil </span>
<span class="line">    721</span> <span class="nop">           .          .           		} </span>
<span class="line">    722</span> <span class="nop">           .          .           	} else { </span>
<span class="line">    723</span> <span class="nop">           .          .           		// If there's an L1, then ri.l1() can be out of bounds but ri.l2() can't. </span>
<span class="line">    724</span> <span class="nop">           .          .           		if ri.l1() &gt;= uint(len(mheap_.arenas)) { </span>
<span class="line">    725</span> <span class="nop">           .          .           			return nil </span>
<span class="line">    726</span> <span class="nop">           .          .           		} </span>
<span class="line">    727</span> <span class="nop">           .          .           	} </span>
<span class="line">    728</span> <span class="nop">        30ms       30ms           	l2 := mheap_.arenas[ri.l1()] </span>
<span class="line">    729</span> <span class="nop">           .          .           	if arenaL1Bits != 0 &amp;&amp; l2 == nil { // Should never happen if there's no L1. </span>
<span class="line">    730</span> <span class="nop">           .          .           		return nil </span>
<span class="line">    731</span> <span class="nop">           .          .           	} </span>
<span class="line">    732</span> <span class="nop">        60ms       60ms           	ha := l2[ri.l2()] </span>
<span class="line">    733</span> <span class="nop">           .          .           	if ha == nil { </span>
<span class="line">    734</span> <span class="nop">           .          .           		return nil </span>
<span class="line">    735</span> <span class="nop">           .          .           	} </span>
<span class="line">    736</span> <span class="nop">        10ms       10ms           	return ha.spans[(p/pageSize)%pagesPerArena] </span>
<span class="line">    737</span> <span class="nop">           .          .           } </span>
<span class="line">    738</span> <span class="nop">           .          .            </span>
<span class="line">    739</span> <span class="nop">           .          .           // spanOfUnchecked is equivalent to spanOf, but the caller must ensure </span>
<span class="line">    740</span> <span class="nop">           .          .           // that p points into an allocated heap arena. </span>
<span class="line">    741</span> <span class="nop">           .          .           // </span>
</pre>
<h2>compress/flate.(*dictDecoder).writeByte</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\dict_decoder.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       110ms      110ms (flat, cum)  0.88%
<span class="line">     89</span> <span class="nop">           .          .            </span>
<span class="line">     90</span> <span class="nop">           .          .           // writeByte writes a single byte to the dictionary. </span>
<span class="line">     91</span> <span class="nop">           .          .           // </span>
<span class="line">     92</span> <span class="nop">           .          .           // This invariant must be kept: 0 &lt; availWrite() </span>
<span class="line">     93</span> <span class="nop">           .          .           func (dd *dictDecoder) writeByte(c byte) { </span>
<span class="line">     94</span> <span class="nop">        80ms       80ms           	dd.hist[dd.wrPos] = c </span>
<span class="line">     95</span> <span class="nop">        30ms       30ms           	dd.wrPos++ </span>
<span class="line">     96</span> <span class="nop">           .          .           } </span>
<span class="line">     97</span> <span class="nop">           .          .            </span>
<span class="line">     98</span> <span class="nop">           .          .           // writeCopy copies a string at a given (dist, length) to the output. </span>
<span class="line">     99</span> <span class="nop">           .          .           // This returns the number of bytes copied and may be less than the requested </span>
<span class="line">    100</span> <span class="nop">           .          .           // length if the available space in the output buffer is too small. </span>
</pre>
<h2>runtime.lock</h2><p class="filename">C:\blockchainenv\Go\src\runtime\lock_sema.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       100ms      170ms (flat, cum)  1.36%
<span class="line">     30</span> <span class="nop">           .          .           	active_spin     = 4 </span>
<span class="line">     31</span> <span class="nop">           .          .           	active_spin_cnt = 30 </span>
<span class="line">     32</span> <span class="nop">           .          .           	passive_spin    = 1 </span>
<span class="line">     33</span> <span class="nop">           .          .           ) </span>
<span class="line">     34</span> <span class="nop">           .          .            </span>
<span class="line">     35</span> <span class="nop">        10ms       10ms           func lock(l *mutex) { </span>
<span class="line">     36</span> <span class="nop">           .          .           	gp := getg() </span>
<span class="line">     37</span> <span class="nop">        10ms       10ms           	if gp.m.locks &lt; 0 { </span>
<span class="line">     38</span> <span class="nop">           .          .           		throw("runtime·lock: lock count") </span>
<span class="line">     39</span> <span class="nop">           .          .           	} </span>
<span class="line">     40</span> <span class="nop">           .          .           	gp.m.locks++ </span>
<span class="line">     41</span> <span class="nop">           .          .            </span>
<span class="line">     42</span> <span class="nop">           .          .           	// Speculative grab for lock. </span>
<span class="line">     43</span> <span class="nop">        50ms       50ms           	if atomic.Casuintptr(&amp;l.key, 0, locked) { </span>
<span class="line">     44</span> <span class="nop">           .          .           		return </span>
<span class="line">     45</span> <span class="nop">           .          .           	} </span>
<span class="line">     46</span> <span class="nop">           .          .           	semacreate(gp.m) </span>
<span class="line">     47</span> <span class="nop">           .          .            </span>
<span class="line">     48</span> <span class="nop">           .          .           	// On uniprocessor's, no point spinning. </span>
<span class="line">     49</span> <span class="nop">           .          .           	// On multiprocessors, spin for ACTIVE_SPIN attempts. </span>
<span class="line">     50</span> <span class="nop">           .          .           	spin := 0 </span>
<span class="line">     51</span> <span class="nop">           .          .           	if ncpu &gt; 1 { </span>
<span class="line">     52</span> <span class="nop">           .          .           		spin = active_spin </span>
<span class="line">     53</span> <span class="nop">           .          .           	} </span>
<span class="line">     54</span> <span class="nop">           .          .           Loop: </span>
<span class="line">     55</span> <span class="nop">           .          .           	for i := 0; ; i++ { </span>
<span class="line">     56</span> <span class="nop">           .          .           		v := atomic.Loaduintptr(&amp;l.key) </span>
<span class="line">     57</span> <span class="nop">           .          .           		if v&amp;locked == 0 { </span>
<span class="line">     58</span> <span class="nop">           .          .           			// Unlocked. Try to lock. </span>
<span class="line">     59</span> <span class="nop">           .          .           			if atomic.Casuintptr(&amp;l.key, v, v|locked) { </span>
<span class="line">     60</span> <span class="nop">           .          .           				return </span>
<span class="line">     61</span> <span class="nop">           .          .           			} </span>
<span class="line">     62</span> <span class="nop">           .          .           			i = 0 </span>
<span class="line">     63</span> <span class="nop">           .          .           		} </span>
<span class="line">     64</span> <span class="nop">           .          .           		if i &lt; spin { </span>
<span class="line">     65</span> <span class="nop">           .       10ms           			procyield(active_spin_cnt) </span>
<span class="line">     66</span> <span class="nop">           .          .           		} else if i &lt; spin+passive_spin { </span>
<span class="line">     67</span> <span class="nop">           .       30ms           			osyield() </span>
<span class="line">     68</span> <span class="nop">           .          .           		} else { </span>
<span class="line">     69</span> <span class="nop">           .          .           			// Someone else has it. </span>
<span class="line">     70</span> <span class="nop">           .          .           			// l-&gt;waitm points to a linked list of M's waiting </span>
<span class="line">     71</span> <span class="nop">           .          .           			// for this lock, chained through m-&gt;nextwaitm. </span>
<span class="line">     72</span> <span class="nop">           .          .           			// Queue this M. </span>
<span class="line">     73</span> <span class="nop">           .          .           			for { </span>
<span class="line">     74</span> <span class="nop">        30ms       30ms           				gp.m.nextwaitm = muintptr(v &amp;^ locked) </span>
<span class="line">     75</span> <span class="nop">           .          .           				if atomic.Casuintptr(&amp;l.key, v, uintptr(unsafe.Pointer(gp.m))|locked) { </span>
<span class="line">     76</span> <span class="nop">           .          .           					break </span>
<span class="line">     77</span> <span class="nop">           .          .           				} </span>
<span class="line">     78</span> <span class="nop">           .          .           				v = atomic.Loaduintptr(&amp;l.key) </span>
<span class="line">     79</span> <span class="nop">           .          .           				if v&amp;locked == 0 { </span>
<span class="line">     80</span> <span class="nop">           .          .           					continue Loop </span>
<span class="line">     81</span> <span class="nop">           .          .           				} </span>
<span class="line">     82</span> <span class="nop">           .          .           			} </span>
<span class="line">     83</span> <span class="nop">           .          .           			if v&amp;locked != 0 { </span>
<span class="line">     84</span> <span class="nop">           .          .           				// Queued. Wait. </span>
<span class="line">     85</span> <span class="nop">           .       30ms           				semasleep(-1) </span>
<span class="line">     86</span> <span class="nop">           .          .           				i = 0 </span>
<span class="line">     87</span> <span class="nop">           .          .           			} </span>
<span class="line">     88</span> <span class="nop">           .          .           		} </span>
<span class="line">     89</span> <span class="nop">           .          .           	} </span>
<span class="line">     90</span> <span class="nop">           .          .           } </span>
</pre>
<h2>runtime.scanblock</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mgcmark.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        90ms      140ms (flat, cum)  1.12%
<span class="line">   1039</span> <span class="nop">           .          .           // This is used to scan non-heap roots, so it does not update </span>
<span class="line">   1040</span> <span class="nop">           .          .           // gcw.bytesMarked or gcw.scanWork. </span>
<span class="line">   1041</span> <span class="nop">           .          .           // </span>
<span class="line">   1042</span> <span class="nop">           .          .           // If stk != nil, possible stack pointers are also reported to stk.putPtr. </span>
<span class="line">   1043</span> <span class="nop">           .          .           //go:nowritebarrier </span>
<span class="line">   1044</span> <span class="nop">        10ms       10ms           func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState) { </span>
<span class="line">   1045</span> <span class="nop">           .          .           	// Use local copies of original parameters, so that a stack trace </span>
<span class="line">   1046</span> <span class="nop">           .          .           	// due to one of the throws below shows the original block </span>
<span class="line">   1047</span> <span class="nop">           .          .           	// base and extent. </span>
<span class="line">   1048</span> <span class="nop">           .          .           	b := b0 </span>
<span class="line">   1049</span> <span class="nop">           .          .           	n := n0 </span>
<span class="line">   1050</span> <span class="nop">           .          .            </span>
<span class="line">   1051</span> <span class="nop">        10ms       10ms           	for i := uintptr(0); i &lt; n; { </span>
<span class="line">   1052</span> <span class="nop">           .          .           		// Find bits for the next word. </span>
<span class="line">   1053</span> <span class="nop">        20ms       20ms           		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8))) </span>
<span class="line">   1054</span> <span class="nop">           .          .           		if bits == 0 { </span>
<span class="line">   1055</span> <span class="nop">           .          .           			i += sys.PtrSize * 8 </span>
<span class="line">   1056</span> <span class="nop">           .          .           			continue </span>
<span class="line">   1057</span> <span class="nop">           .          .           		} </span>
<span class="line">   1058</span> <span class="nop">           .          .           		for j := 0; j &lt; 8 &amp;&amp; i &lt; n; j++ { </span>
<span class="line">   1059</span> <span class="nop">           .          .           			if bits&amp;1 != 0 { </span>
<span class="line">   1060</span> <span class="nop">           .          .           				// Same work as in scanobject; see comments there. </span>
<span class="line">   1061</span> <span class="nop">        10ms       10ms           				p := *(*uintptr)(unsafe.Pointer(b + i)) </span>
<span class="line">   1062</span> <span class="nop">        20ms       20ms           				if p != 0 { </span>
<span class="line">   1063</span> <span class="nop">           .       40ms           					if obj, span, objIndex := findObject(p, b, i); obj != 0 { </span>
<span class="line">   1064</span> <span class="nop">        10ms       20ms           						greyobject(obj, b, i, span, gcw, objIndex) </span>
<span class="line">   1065</span> <span class="nop">           .          .           					} else if stk != nil &amp;&amp; p &gt;= stk.stack.lo &amp;&amp; p &lt; stk.stack.hi { </span>
<span class="line">   1066</span> <span class="nop">           .          .           						stk.putPtr(p) </span>
<span class="line">   1067</span> <span class="nop">           .          .           					} </span>
<span class="line">   1068</span> <span class="nop">           .          .           				} </span>
<span class="line">   1069</span> <span class="nop">           .          .           			} </span>
<span class="line">   1070</span> <span class="nop">        10ms       10ms           			bits &gt;&gt;= 1 </span>
<span class="line">   1071</span> <span class="nop">           .          .           			i += sys.PtrSize </span>
<span class="line">   1072</span> <span class="nop">           .          .           		} </span>
<span class="line">   1073</span> <span class="nop">           .          .           	} </span>
<span class="line">   1074</span> <span class="nop">           .          .           } </span>
<span class="line">   1075</span> <span class="nop">           .          .            </span>
</pre>
<h2>runtime.memclrNoHeapPointers</h2><p class="filename">C:\blockchainenv\Go\src\runtime\memclr_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        90ms       90ms (flat, cum)  0.72%
<span class="line">     71</span> <span class="nop">           .          .           	// For larger sizes it is always faster, even on dual Xeons with 30M cache. </span>
<span class="line">     72</span> <span class="nop">           .          .           	// TODO take into account actual LLC size. E. g. glibc uses LLC size/2. </span>
<span class="line">     73</span> <span class="nop">           .          .           	CMPQ    BX, $0x2000000 </span>
<span class="line">     74</span> <span class="nop">           .          .           	JAE     loop_preheader_avx2_huge </span>
<span class="line">     75</span> <span class="nop">           .          .           loop_avx2: </span>
<span class="line">     76</span> <span class="nop">        10ms       10ms           	VMOVDQU	Y0, 0(DI) </span>
<span class="line">     77</span> <span class="nop">        10ms       10ms           	VMOVDQU	Y0, 32(DI) </span>
<span class="line">     78</span> <span class="nop">        30ms       30ms           	VMOVDQU	Y0, 64(DI) </span>
<span class="line">     79</span> <span class="nop">        10ms       10ms           	VMOVDQU	Y0, 96(DI) </span>
<span class="line">     80</span> <span class="nop">           .          .           	SUBQ	$128, BX </span>
<span class="line">     81</span> <span class="nop">        10ms       10ms           	ADDQ	$128, DI </span>
<span class="line">     82</span> <span class="nop">        10ms       10ms           	CMPQ	BX, $128 </span>
<span class="line">     83</span> <span class="nop">           .          .           	JAE	loop_avx2 </span>
<span class="line">     84</span> <span class="nop">           .          .           	VMOVDQU  Y0, -32(DI)(BX*1) </span>
<span class="line">     85</span> <span class="nop">           .          .           	VMOVDQU  Y0, -64(DI)(BX*1) </span>
<span class="line">     86</span> <span class="nop">           .          .           	VMOVDQU  Y0, -96(DI)(BX*1) </span>
<span class="line">     87</span> <span class="nop">           .          .           	VMOVDQU  Y0, -128(DI)(BX*1) </span>
<span class="line">     88</span> <span class="nop">           .          .           	VZEROUPPER </span>
<span class="line">     89</span> <span class="nop">           .          .           	RET </span>
<span class="line">     90</span> <span class="nop">           .          .           loop_preheader_avx2_huge: </span>
<span class="line">     91</span> <span class="nop">           .          .           	// Align to 32 byte boundary </span>
<span class="line">     92</span> <span class="nop">           .          .           	VMOVDQU  Y0, 0(DI) </span>
<span class="line">     93</span> <span class="nop">           .          .           	MOVQ	DI, SI </span>
<span class="line">     94</span> <span class="nop">           .          .           	ADDQ	$32, DI </span>
<span class="line">     95</span> <span class="nop">           .          .           	ANDQ	$~31, DI </span>
<span class="line">     96</span> <span class="nop">           .          .           	SUBQ	DI, SI </span>
<span class="line">     97</span> <span class="nop">           .          .           	ADDQ	SI, BX </span>
<span class="line">     98</span> <span class="nop">           .          .           loop_avx2_huge: </span>
<span class="line">     99</span> <span class="nop">           .          .           	VMOVNTDQ	Y0, 0(DI) </span>
<span class="line">    100</span> <span class="nop">           .          .           	VMOVNTDQ	Y0, 32(DI) </span>
<span class="line">    101</span> <span class="nop">           .          .           	VMOVNTDQ	Y0, 64(DI) </span>
<span class="line">    102</span> <span class="nop">           .          .           	VMOVNTDQ	Y0, 96(DI) </span>
<span class="line">    103</span> <span class="nop">           .          .           	SUBQ	$128, BX </span>
<span class="line">    104</span> <span class="nop">           .          .           	ADDQ	$128, DI </span>
<span class="line">    105</span> <span class="nop">           .          .           	CMPQ	BX, $128 </span>
<span class="line">    106</span> <span class="nop">           .          .           	JAE	loop_avx2_huge </span>
<span class="line">    107</span> <span class="nop">           .          .           	// In the description of MOVNTDQ in [1] </span>
<span class="line">    108</span> <span class="nop">           .          .           	// "... fencing operation implemented with the SFENCE or MFENCE instruction </span>
<span class="line">    109</span> <span class="nop">           .          .           	// should be used in conjunction with MOVNTDQ instructions..." </span>
<span class="line">    110</span> <span class="nop">           .          .           	// [1] 64-ia-32-architectures-software-developer-manual-325462.pdf </span>
<span class="line">    111</span> <span class="nop">           .          .           	SFENCE </span>
<span class="line">    112</span> <span class="nop">           .          .           	VMOVDQU  Y0, -32(DI)(BX*1) </span>
<span class="line">    113</span> <span class="nop">           .          .           	VMOVDQU  Y0, -64(DI)(BX*1) </span>
<span class="line">    114</span> <span class="nop">           .          .           	VMOVDQU  Y0, -96(DI)(BX*1) </span>
<span class="line">    115</span> <span class="nop">           .          .           	VMOVDQU  Y0, -128(DI)(BX*1) </span>
<span class="line">    116</span> <span class="nop">           .          .           	VZEROUPPER </span>
<span class="line">    117</span> <span class="nop">           .          .           	RET </span>
<span class="line">    118</span> <span class="nop">           .          .            </span>
<span class="line">    119</span> <span class="nop">           .          .           _1or2: </span>
<span class="line">    120</span> <span class="nop">           .          .           	MOVB	AX, (DI) </span>
<span class="line">    121</span> <span class="nop">           .          .           	MOVB	AX, -1(DI)(BX*1) </span>
<span class="line">    122</span> <span class="nop">           .          .           	RET </span>
<span class="line">    123</span> <span class="nop">           .          .           _0: </span>
<span class="line">    124</span> <span class="nop">           .          .           	RET </span>
<span class="line">    125</span> <span class="nop">           .          .           _3or4: </span>
<span class="line">    126</span> <span class="nop">           .          .           	MOVW	AX, (DI) </span>
<span class="line">    127</span> <span class="nop">           .          .           	MOVW	AX, -2(DI)(BX*1) </span>
<span class="line">    128</span> <span class="nop">           .          .           	RET </span>
<span class="line">    129</span> <span class="nop">           .          .           _5through7: </span>
<span class="line">    130</span> <span class="nop">           .          .           	MOVL	AX, (DI) </span>
<span class="line">    131</span> <span class="nop">           .          .           	MOVL	AX, -4(DI)(BX*1) </span>
<span class="line">    132</span> <span class="nop">           .          .           	RET </span>
<span class="line">    133</span> <span class="nop">           .          .           _8: </span>
<span class="line">    134</span> <span class="nop">           .          .           	// We need a separate case for 8 to make sure we clear pointers atomically. </span>
<span class="line">    135</span> <span class="nop">           .          .           	MOVQ	AX, (DI) </span>
<span class="line">    136</span> <span class="nop">           .          .           	RET </span>
<span class="line">    137</span> <span class="nop">           .          .           _9through16: </span>
<span class="line">    138</span> <span class="nop">           .          .           	MOVQ	AX, (DI) </span>
<span class="line">    139</span> <span class="nop">           .          .           	MOVQ	AX, -8(DI)(BX*1) </span>
<span class="line">    140</span> <span class="nop">           .          .           	RET </span>
<span class="line">    141</span> <span class="nop">           .          .           _17through32: </span>
<span class="line">    142</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    143</span> <span class="nop">           .          .           	MOVOU	X0, -16(DI)(BX*1) </span>
<span class="line">    144</span> <span class="nop">           .          .           	RET </span>
<span class="line">    145</span> <span class="nop">           .          .           _33through64: </span>
<span class="line">    146</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
<span class="line">    147</span> <span class="nop">        10ms       10ms           	MOVOU	X0, 16(DI) </span>
<span class="line">    148</span> <span class="nop">           .          .           	MOVOU	X0, -32(DI)(BX*1) </span>
<span class="line">    149</span> <span class="nop">           .          .           	MOVOU	X0, -16(DI)(BX*1) </span>
<span class="line">    150</span> <span class="nop">           .          .           	RET </span>
<span class="line">    151</span> <span class="nop">           .          .           _65through128: </span>
<span class="line">    152</span> <span class="nop">           .          .           	MOVOU	X0, (DI) </span>
</pre>
<h2>runtime.mallocgc</h2><p class="filename">C:\blockchainenv\Go\src\runtime\malloc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        80ms      780ms (flat, cum)  6.24%
<span class="line">    838</span> <span class="nop">           .          .            </span>
<span class="line">    839</span> <span class="nop">           .          .           		if assistG.gcAssistBytes &lt; 0 { </span>
<span class="line">    840</span> <span class="nop">           .          .           			// This G is in debt. Assist the GC to correct </span>
<span class="line">    841</span> <span class="nop">           .          .           			// this before allocating. This must happen </span>
<span class="line">    842</span> <span class="nop">           .          .           			// before disabling preemption. </span>
<span class="line">    843</span> <span class="nop">           .      420ms           			gcAssistAlloc(assistG) </span>
<span class="line">    844</span> <span class="nop">           .          .           		} </span>
<span class="line">    845</span> <span class="nop">           .          .           	} </span>
<span class="line">    846</span> <span class="nop">           .          .            </span>
<span class="line">    847</span> <span class="nop">           .          .           	// Set mp.mallocing to keep from being preempted by GC. </span>
<span class="line">    848</span> <span class="nop">           .          .           	mp := acquirem() </span>
<span class="line">    849</span> <span class="nop">           .          .           	if mp.mallocing != 0 { </span>
<span class="line">    850</span> <span class="nop">           .          .           		throw("malloc deadlock") </span>
<span class="line">    851</span> <span class="nop">           .          .           	} </span>
<span class="line">    852</span> <span class="nop">           .          .           	if mp.gsignal == getg() { </span>
<span class="line">    853</span> <span class="nop">           .          .           		throw("malloc during signal") </span>
<span class="line">    854</span> <span class="nop">           .          .           	} </span>
<span class="line">    855</span> <span class="nop">           .          .           	mp.mallocing = 1 </span>
<span class="line">    856</span> <span class="nop">           .          .            </span>
<span class="line">    857</span> <span class="nop">           .          .           	shouldhelpgc := false </span>
<span class="line">    858</span> <span class="nop">           .          .           	dataSize := size </span>
<span class="line">    859</span> <span class="nop">           .          .           	c := gomcache() </span>
<span class="line">    860</span> <span class="nop">           .          .           	var x unsafe.Pointer </span>
<span class="line">    861</span> <span class="nop">        10ms       10ms           	noscan := typ == nil || typ.kind&amp;kindNoPointers != 0 </span>
<span class="line">    862</span> <span class="nop">           .          .           	if size &lt;= maxSmallSize { </span>
<span class="line">    863</span> <span class="nop">           .          .           		if noscan &amp;&amp; size &lt; maxTinySize { </span>
<span class="line">    864</span> <span class="nop">           .          .           			// Tiny allocator. </span>
<span class="line">    865</span> <span class="nop">           .          .           			// </span>
<span class="line">    866</span> <span class="nop">           .          .           			// Tiny allocator combines several tiny allocation requests </span>
<span class="line">    867</span> <span class="nop">           .          .           			// into a single memory block. The resulting memory block </span>
<span class="line">    868</span> <span class="nop">           .          .           			// is freed when all subobjects are unreachable. The subobjects </span>
<span class="line">    869</span> <span class="nop">           .          .           			// must be noscan (don't have pointers), this ensures that </span>
<span class="line">    870</span> <span class="nop">           .          .           			// the amount of potentially wasted memory is bounded. </span>
<span class="line">    871</span> <span class="nop">           .          .           			// </span>
<span class="line">    872</span> <span class="nop">           .          .           			// Size of the memory block used for combining (maxTinySize) is tunable. </span>
<span class="line">    873</span> <span class="nop">           .          .           			// Current setting is 16 bytes, which relates to 2x worst case memory </span>
<span class="line">    874</span> <span class="nop">           .          .           			// wastage (when all but one subobjects are unreachable). </span>
<span class="line">    875</span> <span class="nop">           .          .           			// 8 bytes would result in no wastage at all, but provides less </span>
<span class="line">    876</span> <span class="nop">           .          .           			// opportunities for combining. </span>
<span class="line">    877</span> <span class="nop">           .          .           			// 32 bytes provides more opportunities for combining, </span>
<span class="line">    878</span> <span class="nop">           .          .           			// but can lead to 4x worst case wastage. </span>
<span class="line">    879</span> <span class="nop">           .          .           			// The best case winning is 8x regardless of block size. </span>
<span class="line">    880</span> <span class="nop">           .          .           			// </span>
<span class="line">    881</span> <span class="nop">           .          .           			// Objects obtained from tiny allocator must not be freed explicitly. </span>
<span class="line">    882</span> <span class="nop">           .          .           			// So when an object will be freed explicitly, we ensure that </span>
<span class="line">    883</span> <span class="nop">           .          .           			// its size &gt;= maxTinySize. </span>
<span class="line">    884</span> <span class="nop">           .          .           			// </span>
<span class="line">    885</span> <span class="nop">           .          .           			// SetFinalizer has a special case for objects potentially coming </span>
<span class="line">    886</span> <span class="nop">           .          .           			// from tiny allocator, it such case it allows to set finalizers </span>
<span class="line">    887</span> <span class="nop">           .          .           			// for an inner byte of a memory block. </span>
<span class="line">    888</span> <span class="nop">           .          .           			// </span>
<span class="line">    889</span> <span class="nop">           .          .           			// The main targets of tiny allocator are small strings and </span>
<span class="line">    890</span> <span class="nop">           .          .           			// standalone escaping variables. On a json benchmark </span>
<span class="line">    891</span> <span class="nop">           .          .           			// the allocator reduces number of allocations by ~12% and </span>
<span class="line">    892</span> <span class="nop">           .          .           			// reduces heap size by ~20%. </span>
<span class="line">    893</span> <span class="nop">           .          .           			off := c.tinyoffset </span>
<span class="line">    894</span> <span class="nop">           .          .           			// Align tiny pointer for required (conservative) alignment. </span>
<span class="line">    895</span> <span class="nop">           .          .           			if size&amp;7 == 0 { </span>
<span class="line">    896</span> <span class="nop">           .          .           				off = round(off, 8) </span>
<span class="line">    897</span> <span class="nop">           .          .           			} else if size&amp;3 == 0 { </span>
<span class="line">    898</span> <span class="nop">           .          .           				off = round(off, 4) </span>
<span class="line">    899</span> <span class="nop">           .          .           			} else if size&amp;1 == 0 { </span>
<span class="line">    900</span> <span class="nop">           .          .           				off = round(off, 2) </span>
<span class="line">    901</span> <span class="nop">           .          .           			} </span>
<span class="line">    902</span> <span class="nop">           .          .           			if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 { </span>
<span class="line">    903</span> <span class="nop">           .          .           				// The object fits into existing tiny block. </span>
<span class="line">    904</span> <span class="nop">           .          .           				x = unsafe.Pointer(c.tiny + off) </span>
<span class="line">    905</span> <span class="nop">           .          .           				c.tinyoffset = off + size </span>
<span class="line">    906</span> <span class="nop">           .          .           				c.local_tinyallocs++ </span>
<span class="line">    907</span> <span class="nop">           .          .           				mp.mallocing = 0 </span>
<span class="line">    908</span> <span class="nop">           .          .           				releasem(mp) </span>
<span class="line">    909</span> <span class="nop">        10ms       10ms           				return x </span>
<span class="line">    910</span> <span class="nop">           .          .           			} </span>
<span class="line">    911</span> <span class="nop">           .          .           			// Allocate a new maxTinySize block. </span>
<span class="line">    912</span> <span class="nop">           .          .           			span := c.alloc[tinySpanClass] </span>
<span class="line">    913</span> <span class="nop">           .       10ms           			v := nextFreeFast(span) </span>
<span class="line">    914</span> <span class="nop">           .          .           			if v == 0 { </span>
<span class="line">    915</span> <span class="nop">           .       10ms           				v, _, shouldhelpgc = c.nextFree(tinySpanClass) </span>
<span class="line">    916</span> <span class="nop">           .          .           			} </span>
<span class="line">    917</span> <span class="nop">           .          .           			x = unsafe.Pointer(v) </span>
<span class="line">    918</span> <span class="nop">           .          .           			(*[2]uint64)(x)[0] = 0 </span>
<span class="line">    919</span> <span class="nop">           .          .           			(*[2]uint64)(x)[1] = 0 </span>
<span class="line">    920</span> <span class="nop">           .          .           			// See if we need to replace the existing tiny block with the new one </span>
<span class="line">    921</span> <span class="nop">           .          .           			// based on amount of remaining free space. </span>
<span class="line">    922</span> <span class="nop">           .          .           			if size &lt; c.tinyoffset || c.tiny == 0 { </span>
<span class="line">    923</span> <span class="nop">           .          .           				c.tiny = uintptr(x) </span>
<span class="line">    924</span> <span class="nop">           .          .           				c.tinyoffset = size </span>
<span class="line">    925</span> <span class="nop">           .          .           			} </span>
<span class="line">    926</span> <span class="nop">           .          .           			size = maxTinySize </span>
<span class="line">    927</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    928</span> <span class="nop">           .          .           			var sizeclass uint8 </span>
<span class="line">    929</span> <span class="nop">        10ms       10ms           			if size &lt;= smallSizeMax-8 { </span>
<span class="line">    930</span> <span class="nop">        10ms       10ms           				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv] </span>
<span class="line">    931</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    932</span> <span class="nop">           .          .           				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv] </span>
<span class="line">    933</span> <span class="nop">           .          .           			} </span>
<span class="line">    934</span> <span class="nop">           .          .           			size = uintptr(class_to_size[sizeclass]) </span>
<span class="line">    935</span> <span class="nop">           .          .           			spc := makeSpanClass(sizeclass, noscan) </span>
<span class="line">    936</span> <span class="nop">           .          .           			span := c.alloc[spc] </span>
<span class="line">    937</span> <span class="nop">           .       20ms           			v := nextFreeFast(span) </span>
<span class="line">    938</span> <span class="nop">           .          .           			if v == 0 { </span>
<span class="line">    939</span> <span class="nop">        10ms      140ms           				v, span, shouldhelpgc = c.nextFree(spc) </span>
<span class="line">    940</span> <span class="nop">           .          .           			} </span>
<span class="line">    941</span> <span class="nop">           .          .           			x = unsafe.Pointer(v) </span>
<span class="line">    942</span> <span class="nop">           .          .           			if needzero &amp;&amp; span.needzero != 0 { </span>
<span class="line">    943</span> <span class="nop">           .          .           				memclrNoHeapPointers(unsafe.Pointer(v), size) </span>
<span class="line">    944</span> <span class="nop">           .          .           			} </span>
<span class="line">    945</span> <span class="nop">           .          .           		} </span>
<span class="line">    946</span> <span class="nop">           .          .           	} else { </span>
<span class="line">    947</span> <span class="nop">           .          .           		var s *mspan </span>
<span class="line">    948</span> <span class="nop">           .          .           		shouldhelpgc = true </span>
<span class="line">    949</span> <span class="nop">           .       50ms           		systemstack(func() { </span>
<span class="line">    950</span> <span class="nop">           .          .           			s = largeAlloc(size, needzero, noscan) </span>
<span class="line">    951</span> <span class="nop">           .          .           		}) </span>
<span class="line">    952</span> <span class="nop">           .          .           		s.freeindex = 1 </span>
<span class="line">    953</span> <span class="nop">           .          .           		s.allocCount = 1 </span>
<span class="line">    954</span> <span class="nop">           .          .           		x = unsafe.Pointer(s.base()) </span>
<span class="line">    955</span> <span class="nop">           .          .           		size = s.elemsize </span>
<span class="line">    956</span> <span class="nop">           .          .           	} </span>
<span class="line">    957</span> <span class="nop">           .          .            </span>
<span class="line">    958</span> <span class="nop">           .          .           	var scanSize uintptr </span>
<span class="line">    959</span> <span class="nop">           .          .           	if !noscan { </span>
<span class="line">    960</span> <span class="nop">           .          .           		// If allocating a defer+arg block, now that we've picked a malloc size </span>
<span class="line">    961</span> <span class="nop">           .          .           		// large enough to hold everything, cut the "asked for" size down to </span>
<span class="line">    962</span> <span class="nop">           .          .           		// just the defer header, so that the GC bitmap will record the arg block </span>
<span class="line">    963</span> <span class="nop">           .          .           		// as containing nothing at all (as if it were unused space at the end of </span>
<span class="line">    964</span> <span class="nop">           .          .           		// a malloc block caused by size rounding). </span>
<span class="line">    965</span> <span class="nop">           .          .           		// The defer arg areas are scanned as part of scanstack. </span>
<span class="line">    966</span> <span class="nop">           .          .           		if typ == deferType { </span>
<span class="line">    967</span> <span class="nop">           .          .           			dataSize = unsafe.Sizeof(_defer{}) </span>
<span class="line">    968</span> <span class="nop">           .          .           		} </span>
<span class="line">    969</span> <span class="nop">        20ms       60ms           		heapBitsSetType(uintptr(x), size, dataSize, typ) </span>
<span class="line">    970</span> <span class="nop">        10ms       10ms           		if dataSize &gt; typ.size { </span>
<span class="line">    971</span> <span class="nop">           .          .           			// Array allocation. If there are any </span>
<span class="line">    972</span> <span class="nop">           .          .           			// pointers, GC has to scan to the last </span>
<span class="line">    973</span> <span class="nop">           .          .           			// element. </span>
<span class="line">    974</span> <span class="nop">           .          .           			if typ.ptrdata != 0 { </span>
<span class="line">    975</span> <span class="nop">           .          .           				scanSize = dataSize - typ.size + typ.ptrdata </span>
<span class="line">    976</span> <span class="nop">           .          .           			} </span>
<span class="line">    977</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    978</span> <span class="nop">           .          .           			scanSize = typ.ptrdata </span>
<span class="line">    979</span> <span class="nop">           .          .           		} </span>
<span class="line">    980</span> <span class="nop">           .          .           		c.local_scan += scanSize </span>
<span class="line">    981</span> <span class="nop">           .          .           	} </span>
<span class="line">    982</span> <span class="nop">           .          .            </span>
<span class="line">    983</span> <span class="nop">           .          .           	// Ensure that the stores above that initialize x to </span>
<span class="line">    984</span> <span class="nop">           .          .           	// type-safe memory and set the heap bits occur before </span>
<span class="line">    985</span> <span class="nop">           .          .           	// the caller can make x observable to the garbage </span>
<span class="line">    986</span> <span class="nop">           .          .           	// collector. Otherwise, on weakly ordered machines, </span>
<span class="line">    987</span> <span class="nop">           .          .           	// the garbage collector could follow a pointer to x, </span>
<span class="line">    988</span> <span class="nop">           .          .           	// but see uninitialized memory or stale heap bits. </span>
<span class="line">    989</span> <span class="nop">           .          .           	publicationBarrier() </span>
<span class="line">    990</span> <span class="nop">           .          .            </span>
<span class="line">    991</span> <span class="nop">           .          .           	// Allocate black during GC. </span>
<span class="line">    992</span> <span class="nop">           .          .           	// All slots hold nil so no scanning is needed. </span>
<span class="line">    993</span> <span class="nop">           .          .           	// This may be racing with GC so do it atomically if there can be </span>
<span class="line">    994</span> <span class="nop">           .          .           	// a race marking the bit. </span>
<span class="line">    995</span> <span class="nop">           .          .           	if gcphase != _GCoff { </span>
<span class="line">    996</span> <span class="nop">           .          .           		gcmarknewobject(uintptr(x), size, scanSize) </span>
<span class="line">    997</span> <span class="nop">           .          .           	} </span>
<span class="line">    998</span> <span class="nop">           .          .            </span>
<span class="line">    999</span> <span class="nop">           .          .           	if raceenabled { </span>
<span class="line">   1000</span> <span class="nop">           .          .           		racemalloc(x, size) </span>
<span class="line">   1001</span> <span class="nop">           .          .           	} </span>
<span class="line">   1002</span> <span class="nop">           .          .            </span>
<span class="line">   1003</span> <span class="nop">           .          .           	if msanenabled { </span>
<span class="line">   1004</span> <span class="nop">           .          .           		msanmalloc(x, size) </span>
<span class="line">   1005</span> <span class="nop">           .          .           	} </span>
<span class="line">   1006</span> <span class="nop">           .          .            </span>
<span class="line">   1007</span> <span class="nop">           .          .           	mp.mallocing = 0 </span>
<span class="line">   1008</span> <span class="nop">           .          .           	releasem(mp) </span>
<span class="line">   1009</span> <span class="nop">           .          .            </span>
<span class="line">   1010</span> <span class="nop">           .          .           	if debug.allocfreetrace != 0 { </span>
<span class="line">   1011</span> <span class="nop">           .          .           		tracealloc(x, size, typ) </span>
<span class="line">   1012</span> <span class="nop">           .          .           	} </span>
<span class="line">   1013</span> <span class="nop">           .          .            </span>
<span class="line">   1014</span> <span class="nop">           .          .           	if rate := MemProfileRate; rate &gt; 0 { </span>
<span class="line">   1015</span> <span class="nop">           .          .           		if rate != 1 &amp;&amp; int32(size) &lt; c.next_sample { </span>
<span class="line">   1016</span> <span class="nop">           .          .           			c.next_sample -= int32(size) </span>
<span class="line">   1017</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   1018</span> <span class="nop">           .          .           			mp := acquirem() </span>
<span class="line">   1019</span> <span class="nop">           .       10ms           			profilealloc(mp, x, size) </span>
<span class="line">   1020</span> <span class="nop">           .          .           			releasem(mp) </span>
<span class="line">   1021</span> <span class="nop">           .          .           		} </span>
<span class="line">   1022</span> <span class="nop">           .          .           	} </span>
<span class="line">   1023</span> <span class="nop">           .          .            </span>
<span class="line">   1024</span> <span class="nop">           .          .           	if assistG != nil { </span>
<span class="line">   1025</span> <span class="nop">           .          .           		// Account for internal fragmentation in the assist </span>
<span class="line">   1026</span> <span class="nop">           .          .           		// debt now that we know it. </span>
<span class="line">   1027</span> <span class="nop">           .          .           		assistG.gcAssistBytes -= int64(size - dataSize) </span>
<span class="line">   1028</span> <span class="nop">           .          .           	} </span>
<span class="line">   1029</span> <span class="nop">           .          .            </span>
<span class="line">   1030</span> <span class="nop">           .          .           	if shouldhelpgc { </span>
<span class="line">   1031</span> <span class="nop">           .          .           		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() { </span>
<span class="line">   1032</span> <span class="nop">           .       10ms           			gcStart(t) </span>
<span class="line">   1033</span> <span class="nop">           .          .           		} </span>
<span class="line">   1034</span> <span class="nop">           .          .           	} </span>
<span class="line">   1035</span> <span class="nop">           .          .            </span>
<span class="line">   1036</span> <span class="nop">           .          .           	return x </span>
<span class="line">   1037</span> <span class="nop">           .          .           } </span>
</pre>
<h2>runtime.gentraceback</h2><p class="filename">C:\blockchainenv\Go\src\runtime\traceback.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        80ms      800ms (flat, cum)  6.39%
<span class="line">    178</span> <span class="nop">           .          .            </span>
<span class="line">    179</span> <span class="nop">           .          .           	var cache pcvalueCache </span>
<span class="line">    180</span> <span class="nop">           .          .            </span>
<span class="line">    181</span> <span class="nop">           .          .           	lastFuncID := funcID_normal </span>
<span class="line">    182</span> <span class="nop">           .          .           	n := 0 </span>
<span class="line">    183</span> <span class="nop">        10ms       10ms           	for n &lt; max { </span>
<span class="line">    184</span> <span class="nop">           .          .           		// Typically: </span>
<span class="line">    185</span> <span class="nop">           .          .           		//	pc is the PC of the running function. </span>
<span class="line">    186</span> <span class="nop">           .          .           		//	sp is the stack pointer at that program counter. </span>
<span class="line">    187</span> <span class="nop">           .          .           		//	fp is the frame pointer (caller's stack pointer) at that program counter, or nil if unknown. </span>
<span class="line">    188</span> <span class="nop">           .          .           		//	stk is the stack containing sp. </span>
<span class="line">    189</span> <span class="nop">           .          .           		//	The caller's program counter is lr, unless lr is zero, in which case it is *(uintptr*)sp. </span>
<span class="line">    190</span> <span class="nop">           .          .           		f = frame.fn </span>
<span class="line">    191</span> <span class="nop">        20ms       20ms           		if f.pcsp == 0 { </span>
<span class="line">    192</span> <span class="nop">           .          .           			// No frame information, must be external function, like race support. </span>
<span class="line">    193</span> <span class="nop">           .          .           			// See golang.org/issue/13568. </span>
<span class="line">    194</span> <span class="nop">           .          .           			break </span>
<span class="line">    195</span> <span class="nop">           .          .           		} </span>
<span class="line">    196</span> <span class="nop">           .          .            </span>
<span class="line">    197</span> <span class="nop">           .          .           		// Found an actual function. </span>
<span class="line">    198</span> <span class="nop">           .          .           		// Derive frame pointer and link register. </span>
<span class="line">    199</span> <span class="nop">           .          .           		if frame.fp == 0 { </span>
<span class="line">    200</span> <span class="nop">           .          .           			// Jump over system stack transitions. If we're on g0 and there's a user </span>
<span class="line">    201</span> <span class="nop">           .          .           			// goroutine, try to jump. Otherwise this is a regular call. </span>
<span class="line">    202</span> <span class="nop">           .          .           			if flags&amp;_TraceJumpStack != 0 &amp;&amp; gp == gp.m.g0 &amp;&amp; gp.m.curg != nil { </span>
<span class="line">    203</span> <span class="nop">           .          .           				switch f.funcID { </span>
<span class="line">    204</span> <span class="nop">           .          .           				case funcID_morestack: </span>
<span class="line">    205</span> <span class="nop">           .          .           					// morestack does not return normally -- newstack() </span>
<span class="line">    206</span> <span class="nop">           .          .           					// gogo's to curg.sched. Match that. </span>
<span class="line">    207</span> <span class="nop">           .          .           					// This keeps morestack() from showing up in the backtrace, </span>
<span class="line">    208</span> <span class="nop">           .          .           					// but that makes some sense since it'll never be returned </span>
<span class="line">    209</span> <span class="nop">           .          .           					// to. </span>
<span class="line">    210</span> <span class="nop">           .          .           					frame.pc = gp.m.curg.sched.pc </span>
<span class="line">    211</span> <span class="nop">           .          .           					frame.fn = findfunc(frame.pc) </span>
<span class="line">    212</span> <span class="nop">           .          .           					f = frame.fn </span>
<span class="line">    213</span> <span class="nop">           .          .           					frame.sp = gp.m.curg.sched.sp </span>
<span class="line">    214</span> <span class="nop">           .          .           					cgoCtxt = gp.m.curg.cgoCtxt </span>
<span class="line">    215</span> <span class="nop">           .          .           				case funcID_systemstack: </span>
<span class="line">    216</span> <span class="nop">           .          .           					// systemstack returns normally, so just follow the </span>
<span class="line">    217</span> <span class="nop">           .          .           					// stack transition. </span>
<span class="line">    218</span> <span class="nop">           .          .           					frame.sp = gp.m.curg.sched.sp </span>
<span class="line">    219</span> <span class="nop">           .          .           					cgoCtxt = gp.m.curg.cgoCtxt </span>
<span class="line">    220</span> <span class="nop">           .          .           				} </span>
<span class="line">    221</span> <span class="nop">           .          .           			} </span>
<span class="line">    222</span> <span class="nop">           .      180ms           			frame.fp = frame.sp + uintptr(funcspdelta(f, frame.pc, &amp;cache)) </span>
<span class="line">    223</span> <span class="nop">           .          .           			if !usesLR { </span>
<span class="line">    224</span> <span class="nop">           .          .           				// On x86, call instruction pushes return PC before entering new function. </span>
<span class="line">    225</span> <span class="nop">           .          .           				frame.fp += sys.RegSize </span>
<span class="line">    226</span> <span class="nop">           .          .           			} </span>
<span class="line">    227</span> <span class="nop">           .          .           		} </span>
<span class="line">    228</span> <span class="nop">           .          .           		var flr funcInfo </span>
<span class="line">    229</span> <span class="nop">           .          .           		if topofstack(f, gp.m != nil &amp;&amp; gp == gp.m.g0) { </span>
<span class="line">    230</span> <span class="nop">           .          .           			frame.lr = 0 </span>
<span class="line">    231</span> <span class="nop">           .          .           			flr = funcInfo{} </span>
<span class="line">    232</span> <span class="nop">           .          .           		} else if usesLR &amp;&amp; f.funcID == funcID_jmpdefer { </span>
<span class="line">    233</span> <span class="nop">           .          .           			// jmpdefer modifies SP/LR/PC non-atomically. </span>
<span class="line">    234</span> <span class="nop">           .          .           			// If a profiling interrupt arrives during jmpdefer, </span>
<span class="line">    235</span> <span class="nop">           .          .           			// the stack unwind may see a mismatched register set </span>
<span class="line">    236</span> <span class="nop">           .          .           			// and get confused. Stop if we see PC within jmpdefer </span>
<span class="line">    237</span> <span class="nop">           .          .           			// to avoid that confusion. </span>
<span class="line">    238</span> <span class="nop">           .          .           			// See golang.org/issue/8153. </span>
<span class="line">    239</span> <span class="nop">           .          .           			if callback != nil { </span>
<span class="line">    240</span> <span class="nop">           .          .           				throw("traceback_arm: found jmpdefer when tracing with callback") </span>
<span class="line">    241</span> <span class="nop">           .          .           			} </span>
<span class="line">    242</span> <span class="nop">           .          .           			frame.lr = 0 </span>
<span class="line">    243</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    244</span> <span class="nop">           .          .           			var lrPtr uintptr </span>
<span class="line">    245</span> <span class="nop">           .          .           			if usesLR { </span>
<span class="line">    246</span> <span class="nop">           .          .           				if n == 0 &amp;&amp; frame.sp &lt; frame.fp || frame.lr == 0 { </span>
<span class="line">    247</span> <span class="nop">           .          .           					lrPtr = frame.sp </span>
<span class="line">    248</span> <span class="nop">           .          .           					frame.lr = *(*uintptr)(unsafe.Pointer(lrPtr)) </span>
<span class="line">    249</span> <span class="nop">           .          .           				} </span>
<span class="line">    250</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    251</span> <span class="nop">           .          .           				if frame.lr == 0 { </span>
<span class="line">    252</span> <span class="nop">           .          .           					lrPtr = frame.fp - sys.RegSize </span>
<span class="line">    253</span> <span class="nop">           .          .           					frame.lr = uintptr(*(*sys.Uintreg)(unsafe.Pointer(lrPtr))) </span>
<span class="line">    254</span> <span class="nop">           .          .           				} </span>
<span class="line">    255</span> <span class="nop">           .          .           			} </span>
<span class="line">    256</span> <span class="nop">           .       40ms           			flr = findfunc(frame.lr) </span>
<span class="line">    257</span> <span class="nop">           .          .           			if !flr.valid() { </span>
<span class="line">    258</span> <span class="nop">           .          .           				// This happens if you get a profiling interrupt at just the wrong time. </span>
<span class="line">    259</span> <span class="nop">           .          .           				// In that context it is okay to stop early. </span>
<span class="line">    260</span> <span class="nop">           .          .           				// But if callback is set, we're doing a garbage collection and must </span>
<span class="line">    261</span> <span class="nop">           .          .           				// get everything, so crash loudly. </span>
<span class="line">    262</span> <span class="nop">           .          .           				doPrint := printing </span>
<span class="line">    263</span> <span class="nop">           .          .           				if doPrint &amp;&amp; gp.m.incgo &amp;&amp; f.funcID == funcID_sigpanic { </span>
<span class="line">    264</span> <span class="nop">           .          .           					// We can inject sigpanic </span>
<span class="line">    265</span> <span class="nop">           .          .           					// calls directly into C code, </span>
<span class="line">    266</span> <span class="nop">           .          .           					// in which case we'll see a C </span>
<span class="line">    267</span> <span class="nop">           .          .           					// return PC. Don't complain. </span>
<span class="line">    268</span> <span class="nop">           .          .           					doPrint = false </span>
<span class="line">    269</span> <span class="nop">           .          .           				} </span>
<span class="line">    270</span> <span class="nop">           .          .           				if callback != nil || doPrint { </span>
<span class="line">    271</span> <span class="nop">           .          .           					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n") </span>
<span class="line">    272</span> <span class="nop">           .          .           					tracebackHexdump(gp.stack, &amp;frame, lrPtr) </span>
<span class="line">    273</span> <span class="nop">           .          .           				} </span>
<span class="line">    274</span> <span class="nop">           .          .           				if callback != nil { </span>
<span class="line">    275</span> <span class="nop">           .          .           					throw("unknown caller pc") </span>
<span class="line">    276</span> <span class="nop">           .          .           				} </span>
<span class="line">    277</span> <span class="nop">           .          .           			} </span>
<span class="line">    278</span> <span class="nop">           .          .           		} </span>
<span class="line">    279</span> <span class="nop">           .          .            </span>
<span class="line">    280</span> <span class="nop">        10ms       10ms           		frame.varp = frame.fp </span>
<span class="line">    281</span> <span class="nop">           .          .           		if !usesLR { </span>
<span class="line">    282</span> <span class="nop">           .          .           			// On x86, call instruction pushes return PC before entering new function. </span>
<span class="line">    283</span> <span class="nop">           .          .           			frame.varp -= sys.RegSize </span>
<span class="line">    284</span> <span class="nop">           .          .           		} </span>
<span class="line">    285</span> <span class="nop">           .          .            </span>
<span class="line">    286</span> <span class="nop">           .          .           		// If framepointer_enabled and there's a frame, then </span>
<span class="line">    287</span> <span class="nop">           .          .           		// there's a saved bp here. </span>
<span class="line">    288</span> <span class="nop">           .          .           		if frame.varp &gt; frame.sp &amp;&amp; (framepointer_enabled &amp;&amp; GOARCH == "amd64" || GOARCH == "arm64") { </span>
<span class="line">    289</span> <span class="nop">           .          .           			frame.varp -= sys.RegSize </span>
<span class="line">    290</span> <span class="nop">           .          .           		} </span>
<span class="line">    291</span> <span class="nop">           .          .            </span>
<span class="line">    292</span> <span class="nop">           .          .           		// Derive size of arguments. </span>
<span class="line">    293</span> <span class="nop">           .          .           		// Most functions have a fixed-size argument block, </span>
<span class="line">    294</span> <span class="nop">           .          .           		// so we can use metadata about the function f. </span>
<span class="line">    295</span> <span class="nop">           .          .           		// Not all, though: there are some variadic functions </span>
<span class="line">    296</span> <span class="nop">           .          .           		// in package runtime and reflect, and for those we use call-specific </span>
<span class="line">    297</span> <span class="nop">           .          .           		// metadata recorded by f's caller. </span>
<span class="line">    298</span> <span class="nop">           .          .           		if callback != nil || printing { </span>
<span class="line">    299</span> <span class="nop">           .          .           			frame.argp = frame.fp + sys.MinFrameSize </span>
<span class="line">    300</span> <span class="nop">           .          .           			var ok bool </span>
<span class="line">    301</span> <span class="nop">           .          .           			frame.arglen, frame.argmap, ok = getArgInfoFast(f, callback != nil) </span>
<span class="line">    302</span> <span class="nop">           .          .           			if !ok { </span>
<span class="line">    303</span> <span class="nop">           .          .           				frame.arglen, frame.argmap = getArgInfo(&amp;frame, f, callback != nil, nil) </span>
<span class="line">    304</span> <span class="nop">           .          .           			} </span>
<span class="line">    305</span> <span class="nop">           .          .           		} </span>
<span class="line">    306</span> <span class="nop">           .          .            </span>
<span class="line">    307</span> <span class="nop">           .          .           		// Determine frame's 'continuation PC', where it can continue. </span>
<span class="line">    308</span> <span class="nop">           .          .           		// Normally this is the return address on the stack, but if sigpanic </span>
<span class="line">    309</span> <span class="nop">           .          .           		// is immediately below this function on the stack, then the frame </span>
<span class="line">    310</span> <span class="nop">           .          .           		// stopped executing due to a trap, and frame.pc is probably not </span>
<span class="line">    311</span> <span class="nop">           .          .           		// a safe point for looking up liveness information. In this panicking case, </span>
<span class="line">    312</span> <span class="nop">           .          .           		// the function either doesn't return at all (if it has no defers or if the </span>
<span class="line">    313</span> <span class="nop">           .          .           		// defers do not recover) or it returns from one of the calls to </span>
<span class="line">    314</span> <span class="nop">           .          .           		// deferproc a second time (if the corresponding deferred func recovers). </span>
<span class="line">    315</span> <span class="nop">           .          .           		// In the latter case, use a deferreturn call site as the continuation pc. </span>
<span class="line">    316</span> <span class="nop">           .          .           		frame.continpc = frame.pc </span>
<span class="line">    317</span> <span class="nop">        10ms       10ms           		if waspanic { </span>
<span class="line">    318</span> <span class="nop">           .          .           			// We match up defers with frames using the SP. </span>
<span class="line">    319</span> <span class="nop">           .          .           			// However, if the function has an empty stack </span>
<span class="line">    320</span> <span class="nop">           .          .           			// frame, then it's possible (on LR machines) </span>
<span class="line">    321</span> <span class="nop">           .          .           			// for multiple call frames to have the same </span>
<span class="line">    322</span> <span class="nop">           .          .           			// SP. But, since a function with no frame </span>
<span class="line">    323</span> <span class="nop">           .          .           			// can't push a defer, the defer can't belong </span>
<span class="line">    324</span> <span class="nop">           .          .           			// to that frame. </span>
<span class="line">    325</span> <span class="nop">           .          .           			if _defer != nil &amp;&amp; _defer.sp == frame.sp &amp;&amp; frame.sp != frame.fp { </span>
<span class="line">    326</span> <span class="nop">           .          .           				frame.continpc = frame.fn.entry + uintptr(frame.fn.deferreturn) + 1 </span>
<span class="line">    327</span> <span class="nop">           .          .           				// Note: the +1 is to offset the -1 that </span>
<span class="line">    328</span> <span class="nop">           .          .           				// stack.go:getStackMap does to back up a return </span>
<span class="line">    329</span> <span class="nop">           .          .           				// address make sure the pc is in the CALL instruction. </span>
<span class="line">    330</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    331</span> <span class="nop">           .          .           				frame.continpc = 0 </span>
<span class="line">    332</span> <span class="nop">           .          .           			} </span>
<span class="line">    333</span> <span class="nop">           .          .           		} </span>
<span class="line">    334</span> <span class="nop">           .          .            </span>
<span class="line">    335</span> <span class="nop">           .          .           		// Unwind our local defer stack past this frame. </span>
<span class="line">    336</span> <span class="nop">           .          .           		for _defer != nil &amp;&amp; ((_defer.sp == frame.sp &amp;&amp; frame.sp != frame.fp) || _defer.sp == _NoArgs) { </span>
<span class="line">    337</span> <span class="nop">           .          .           			_defer = _defer.link </span>
<span class="line">    338</span> <span class="nop">           .          .           		} </span>
<span class="line">    339</span> <span class="nop">           .          .            </span>
<span class="line">    340</span> <span class="nop">           .          .           		if callback != nil { </span>
<span class="line">    341</span> <span class="nop">           .      500ms           			if !callback((*stkframe)(noescape(unsafe.Pointer(&amp;frame))), v) { </span>
<span class="line">    342</span> <span class="nop">           .          .           				return n </span>
<span class="line">    343</span> <span class="nop">           .          .           			} </span>
<span class="line">    344</span> <span class="nop">           .          .           		} </span>
<span class="line">    345</span> <span class="nop">           .          .            </span>
<span class="line">    346</span> <span class="nop">           .          .           		if pcbuf != nil { </span>
<span class="line">    347</span> <span class="nop">           .          .           			pc := frame.pc </span>
<span class="line">    348</span> <span class="nop">           .          .           			// backup to CALL instruction to read inlining info (same logic as below) </span>
<span class="line">    349</span> <span class="nop">           .          .           			tracepc := pc </span>
<span class="line">    350</span> <span class="nop">           .          .           			if (n &gt; 0 || flags&amp;_TraceTrap == 0) &amp;&amp; frame.pc &gt; f.entry &amp;&amp; !waspanic { </span>
<span class="line">    351</span> <span class="nop">           .          .           				tracepc-- </span>
<span class="line">    352</span> <span class="nop">           .          .           			} </span>
<span class="line">    353</span> <span class="nop">           .          .            </span>
<span class="line">    354</span> <span class="nop">           .          .           			// If there is inlining info, record the inner frames. </span>
<span class="line">    355</span> <span class="nop">           .          .           			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil { </span>
<span class="line">    356</span> <span class="nop">           .          .           				inltree := (*[1 &lt;&lt; 20]inlinedCall)(inldata) </span>
<span class="line">    357</span> <span class="nop">           .          .           				for { </span>
<span class="line">    358</span> <span class="nop">           .          .           					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &amp;cache) </span>
<span class="line">    359</span> <span class="nop">           .          .           					if ix &lt; 0 { </span>
<span class="line">    360</span> <span class="nop">           .          .           						break </span>
<span class="line">    361</span> <span class="nop">           .          .           					} </span>
<span class="line">    362</span> <span class="nop">           .          .           					if inltree[ix].funcID == funcID_wrapper &amp;&amp; elideWrapperCalling(lastFuncID) { </span>
<span class="line">    363</span> <span class="nop">           .          .           						// ignore wrappers </span>
<span class="line">    364</span> <span class="nop">           .          .           					} else if skip &gt; 0 { </span>
<span class="line">    365</span> <span class="nop">           .          .           						skip-- </span>
<span class="line">    366</span> <span class="nop">           .          .           					} else if n &lt; max { </span>
<span class="line">    367</span> <span class="nop">           .          .           						(*[1 &lt;&lt; 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc </span>
<span class="line">    368</span> <span class="nop">           .          .           						n++ </span>
<span class="line">    369</span> <span class="nop">           .          .           					} </span>
<span class="line">    370</span> <span class="nop">           .          .           					lastFuncID = inltree[ix].funcID </span>
<span class="line">    371</span> <span class="nop">           .          .           					// Back up to an instruction in the "caller". </span>
<span class="line">    372</span> <span class="nop">           .          .           					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc) </span>
<span class="line">    373</span> <span class="nop">           .          .           					pc = tracepc + 1 </span>
<span class="line">    374</span> <span class="nop">           .          .           				} </span>
<span class="line">    375</span> <span class="nop">           .          .           			} </span>
<span class="line">    376</span> <span class="nop">           .          .           			// Record the main frame. </span>
<span class="line">    377</span> <span class="nop">           .          .           			if f.funcID == funcID_wrapper &amp;&amp; elideWrapperCalling(lastFuncID) { </span>
<span class="line">    378</span> <span class="nop">           .          .           				// Ignore wrapper functions (except when they trigger panics). </span>
<span class="line">    379</span> <span class="nop">           .          .           			} else if skip &gt; 0 { </span>
<span class="line">    380</span> <span class="nop">           .          .           				skip-- </span>
<span class="line">    381</span> <span class="nop">           .          .           			} else if n &lt; max { </span>
<span class="line">    382</span> <span class="nop">           .          .           				(*[1 &lt;&lt; 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc </span>
<span class="line">    383</span> <span class="nop">           .          .           				n++ </span>
<span class="line">    384</span> <span class="nop">           .          .           			} </span>
<span class="line">    385</span> <span class="nop">           .          .           			lastFuncID = f.funcID </span>
<span class="line">    386</span> <span class="nop">           .          .           			n-- // offset n++ below </span>
<span class="line">    387</span> <span class="nop">           .          .           		} </span>
<span class="line">    388</span> <span class="nop">           .          .            </span>
<span class="line">    389</span> <span class="nop">           .          .           		if printing { </span>
<span class="line">    390</span> <span class="nop">           .          .           			// assume skip=0 for printing. </span>
<span class="line">    391</span> <span class="nop">           .          .           			// </span>
<span class="line">    392</span> <span class="nop">           .          .           			// Never elide wrappers if we haven't printed </span>
<span class="line">    393</span> <span class="nop">           .          .           			// any frames. And don't elide wrappers that </span>
<span class="line">    394</span> <span class="nop">           .          .           			// called panic rather than the wrapped </span>
<span class="line">    395</span> <span class="nop">           .          .           			// function. Otherwise, leave them out. </span>
<span class="line">    396</span> <span class="nop">           .          .            </span>
<span class="line">    397</span> <span class="nop">           .          .           			// backup to CALL instruction to read inlining info (same logic as below) </span>
<span class="line">    398</span> <span class="nop">           .          .           			tracepc := frame.pc </span>
<span class="line">    399</span> <span class="nop">           .          .           			if (n &gt; 0 || flags&amp;_TraceTrap == 0) &amp;&amp; frame.pc &gt; f.entry &amp;&amp; !waspanic { </span>
<span class="line">    400</span> <span class="nop">           .          .           				tracepc-- </span>
<span class="line">    401</span> <span class="nop">           .          .           			} </span>
<span class="line">    402</span> <span class="nop">           .          .           			// If there is inlining info, print the inner frames. </span>
<span class="line">    403</span> <span class="nop">           .          .           			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil { </span>
<span class="line">    404</span> <span class="nop">           .          .           				inltree := (*[1 &lt;&lt; 20]inlinedCall)(inldata) </span>
<span class="line">    405</span> <span class="nop">           .          .           				for { </span>
<span class="line">    406</span> <span class="nop">           .          .           					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil) </span>
<span class="line">    407</span> <span class="nop">           .          .           					if ix &lt; 0 { </span>
<span class="line">    408</span> <span class="nop">           .          .           						break </span>
<span class="line">    409</span> <span class="nop">           .          .           					} </span>
<span class="line">    410</span> <span class="nop">           .          .           					if (flags&amp;_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) { </span>
<span class="line">    411</span> <span class="nop">           .          .           						name := funcnameFromNameoff(f, inltree[ix].func_) </span>
<span class="line">    412</span> <span class="nop">           .          .           						file, line := funcline(f, tracepc) </span>
<span class="line">    413</span> <span class="nop">           .          .           						print(name, "(...)\n") </span>
<span class="line">    414</span> <span class="nop">           .          .           						print("\t", file, ":", line, "\n") </span>
<span class="line">    415</span> <span class="nop">           .          .           						nprint++ </span>
<span class="line">    416</span> <span class="nop">           .          .           					} </span>
<span class="line">    417</span> <span class="nop">           .          .           					lastFuncID = inltree[ix].funcID </span>
<span class="line">    418</span> <span class="nop">           .          .           					// Back up to an instruction in the "caller". </span>
<span class="line">    419</span> <span class="nop">           .          .           					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc) </span>
<span class="line">    420</span> <span class="nop">           .          .           				} </span>
<span class="line">    421</span> <span class="nop">           .          .           			} </span>
<span class="line">    422</span> <span class="nop">           .          .           			if (flags&amp;_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) { </span>
<span class="line">    423</span> <span class="nop">           .          .           				// Print during crash. </span>
<span class="line">    424</span> <span class="nop">           .          .           				//	main(0x1, 0x2, 0x3) </span>
<span class="line">    425</span> <span class="nop">           .          .           				//		/home/rsc/go/src/runtime/x.go:23 +0xf </span>
<span class="line">    426</span> <span class="nop">           .          .           				// </span>
<span class="line">    427</span> <span class="nop">           .          .           				name := funcname(f) </span>
<span class="line">    428</span> <span class="nop">           .          .           				file, line := funcline(f, tracepc) </span>
<span class="line">    429</span> <span class="nop">           .          .           				if name == "runtime.gopanic" { </span>
<span class="line">    430</span> <span class="nop">           .          .           					name = "panic" </span>
<span class="line">    431</span> <span class="nop">           .          .           				} </span>
<span class="line">    432</span> <span class="nop">           .          .           				print(name, "(") </span>
<span class="line">    433</span> <span class="nop">           .          .           				argp := (*[100]uintptr)(unsafe.Pointer(frame.argp)) </span>
<span class="line">    434</span> <span class="nop">           .          .           				for i := uintptr(0); i &lt; frame.arglen/sys.PtrSize; i++ { </span>
<span class="line">    435</span> <span class="nop">           .          .           					if i &gt;= 10 { </span>
<span class="line">    436</span> <span class="nop">           .          .           						print(", ...") </span>
<span class="line">    437</span> <span class="nop">           .          .           						break </span>
<span class="line">    438</span> <span class="nop">           .          .           					} </span>
<span class="line">    439</span> <span class="nop">           .          .           					if i != 0 { </span>
<span class="line">    440</span> <span class="nop">           .          .           						print(", ") </span>
<span class="line">    441</span> <span class="nop">           .          .           					} </span>
<span class="line">    442</span> <span class="nop">           .          .           					print(hex(argp[i])) </span>
<span class="line">    443</span> <span class="nop">           .          .           				} </span>
<span class="line">    444</span> <span class="nop">           .          .           				print(")\n") </span>
<span class="line">    445</span> <span class="nop">           .          .           				print("\t", file, ":", line) </span>
<span class="line">    446</span> <span class="nop">           .          .           				if frame.pc &gt; f.entry { </span>
<span class="line">    447</span> <span class="nop">           .          .           					print(" +", hex(frame.pc-f.entry)) </span>
<span class="line">    448</span> <span class="nop">           .          .           				} </span>
<span class="line">    449</span> <span class="nop">           .          .           				if gp.m != nil &amp;&amp; gp.m.throwing &gt; 0 &amp;&amp; gp == gp.m.curg || level &gt;= 2 { </span>
<span class="line">    450</span> <span class="nop">           .          .           					print(" fp=", hex(frame.fp), " sp=", hex(frame.sp), " pc=", hex(frame.pc)) </span>
<span class="line">    451</span> <span class="nop">           .          .           				} </span>
<span class="line">    452</span> <span class="nop">           .          .           				print("\n") </span>
<span class="line">    453</span> <span class="nop">           .          .           				nprint++ </span>
<span class="line">    454</span> <span class="nop">           .          .           			} </span>
<span class="line">    455</span> <span class="nop">           .          .           			lastFuncID = f.funcID </span>
<span class="line">    456</span> <span class="nop">           .          .           		} </span>
<span class="line">    457</span> <span class="nop">           .          .           		n++ </span>
<span class="line">    458</span> <span class="nop">           .          .            </span>
<span class="line">    459</span> <span class="nop">        20ms       20ms           		if f.funcID == funcID_cgocallback_gofunc &amp;&amp; len(cgoCtxt) &gt; 0 { </span>
<span class="line">    460</span> <span class="nop">        10ms       10ms           			ctxt := cgoCtxt[len(cgoCtxt)-1] </span>
<span class="line">    461</span> <span class="nop">           .          .           			cgoCtxt = cgoCtxt[:len(cgoCtxt)-1] </span>
<span class="line">    462</span> <span class="nop">           .          .            </span>
<span class="line">    463</span> <span class="nop">           .          .           			// skip only applies to Go frames. </span>
<span class="line">    464</span> <span class="nop">           .          .           			// callback != nil only used when we only care </span>
<span class="line">    465</span> <span class="nop">           .          .           			// about Go frames. </span>
</pre>
<h2>regexp.(*machine).add</h2><p class="filename">C:\blockchainenv\Go\src\regexp\exec.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        80ms      310ms (flat, cum)  2.48%
<span class="line">    312</span> <span class="nop">           .          .            </span>
<span class="line">    313</span> <span class="nop">           .          .           // add adds an entry to q for pc, unless the q already has such an entry. </span>
<span class="line">    314</span> <span class="nop">           .          .           // It also recursively adds an entry for all instructions reachable from pc by following </span>
<span class="line">    315</span> <span class="nop">           .          .           // empty-width conditions satisfied by cond.  pos gives the current position </span>
<span class="line">    316</span> <span class="nop">           .          .           // in the input. </span>
<span class="line">    317</span> <span class="nop">        20ms       20ms           func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread { </span>
<span class="line">    318</span> <span class="nop">           .          .           Again: </span>
<span class="line">    319</span> <span class="nop">           .          .           	if pc == 0 { </span>
<span class="line">    320</span> <span class="nop">           .          .           		return t </span>
<span class="line">    321</span> <span class="nop">           .          .           	} </span>
<span class="line">    322</span> <span class="nop">           .          .           	if j := q.sparse[pc]; j &lt; uint32(len(q.dense)) &amp;&amp; q.dense[j].pc == pc { </span>
<span class="line">    323</span> <span class="nop">           .          .           		return t </span>
<span class="line">    324</span> <span class="nop">           .          .           	} </span>
<span class="line">    325</span> <span class="nop">           .          .            </span>
<span class="line">    326</span> <span class="nop">           .          .           	j := len(q.dense) </span>
<span class="line">    327</span> <span class="nop">           .          .           	q.dense = q.dense[:j+1] </span>
<span class="line">    328</span> <span class="nop">           .          .           	d := &amp;q.dense[j] </span>
<span class="line">    329</span> <span class="nop">           .       60ms           	d.t = nil </span>
<span class="line">    330</span> <span class="nop">           .          .           	d.pc = pc </span>
<span class="line">    331</span> <span class="nop">        10ms       10ms           	q.sparse[pc] = uint32(j) </span>
<span class="line">    332</span> <span class="nop">           .          .            </span>
<span class="line">    333</span> <span class="nop">        10ms       10ms           	i := &amp;m.p.Inst[pc] </span>
<span class="line">    334</span> <span class="nop">        30ms       30ms           	switch i.Op { </span>
<span class="line">    335</span> <span class="nop">           .          .           	default: </span>
<span class="line">    336</span> <span class="nop">           .          .           		panic("unhandled") </span>
<span class="line">    337</span> <span class="nop">           .          .           	case syntax.InstFail: </span>
<span class="line">    338</span> <span class="nop">           .          .           		// nothing </span>
<span class="line">    339</span> <span class="nop">           .          .           	case syntax.InstAlt, syntax.InstAltMatch: </span>
<span class="line">    340</span> <span class="nop">           .       20ms           		t = m.add(q, i.Out, pos, cap, cond, t) </span>
<span class="line">    341</span> <span class="nop">           .          .           		pc = i.Arg </span>
<span class="line">    342</span> <span class="nop">           .          .           		goto Again </span>
<span class="line">    343</span> <span class="nop">           .          .           	case syntax.InstEmptyWidth: </span>
<span class="line">    344</span> <span class="nop">           .          .           		if cond.match(syntax.EmptyOp(i.Arg)) { </span>
<span class="line">    345</span> <span class="nop">           .          .           			pc = i.Out </span>
<span class="line">    346</span> <span class="nop">           .          .           			goto Again </span>
<span class="line">    347</span> <span class="nop">           .          .           		} </span>
<span class="line">    348</span> <span class="nop">           .          .           	case syntax.InstNop: </span>
<span class="line">    349</span> <span class="nop">           .          .           		pc = i.Out </span>
<span class="line">    350</span> <span class="nop">           .          .           		goto Again </span>
<span class="line">    351</span> <span class="nop">           .          .           	case syntax.InstCapture: </span>
<span class="line">    352</span> <span class="nop">           .          .           		if int(i.Arg) &lt; len(cap) { </span>
<span class="line">    353</span> <span class="nop">           .          .           			opos := cap[i.Arg] </span>
<span class="line">    354</span> <span class="nop">           .          .           			cap[i.Arg] = pos </span>
<span class="line">    355</span> <span class="nop">           .          .           			m.add(q, i.Out, pos, cap, cond, nil) </span>
<span class="line">    356</span> <span class="nop">           .          .           			cap[i.Arg] = opos </span>
<span class="line">    357</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    358</span> <span class="nop">           .          .           			pc = i.Out </span>
<span class="line">    359</span> <span class="nop">           .          .           			goto Again </span>
<span class="line">    360</span> <span class="nop">           .          .           		} </span>
<span class="line">    361</span> <span class="nop">           .          .           	case syntax.InstMatch, syntax.InstRune, syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL: </span>
<span class="line">    362</span> <span class="nop">           .          .           		if t == nil { </span>
<span class="line">    363</span> <span class="nop">           .       70ms           			t = m.alloc(i) </span>
<span class="line">    364</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    365</span> <span class="nop">           .       10ms           			t.inst = i </span>
<span class="line">    366</span> <span class="nop">           .          .           		} </span>
<span class="line">    367</span> <span class="nop">           .          .           		if len(cap) &gt; 0 &amp;&amp; &amp;t.cap[0] != &amp;cap[0] { </span>
<span class="line">    368</span> <span class="nop">        10ms       30ms           			copy(t.cap, cap) </span>
<span class="line">    369</span> <span class="nop">           .          .           		} </span>
<span class="line">    370</span> <span class="nop">           .       50ms           		d.t = t </span>
<span class="line">    371</span> <span class="nop">           .          .           		t = nil </span>
<span class="line">    372</span> <span class="nop">           .          .           	} </span>
<span class="line">    373</span> <span class="nop">           .          .           	return t </span>
<span class="line">    374</span> <span class="nop">           .          .           } </span>
<span class="line">    375</span> <span class="nop">           .          .            </span>
</pre>
<h2>indexbytebody</h2><p class="filename">C:\blockchainenv\Go\src\internal\bytealg\indexbyte_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        70ms       70ms (flat, cum)  0.56%
<span class="line">    119</span> <span class="nop">           .          .           	JNE sse </span>
<span class="line">    120</span> <span class="nop">           .          .           	MOVD AX, X0 </span>
<span class="line">    121</span> <span class="nop">           .          .           	LEAQ -32(SI)(BX*1), R11 </span>
<span class="line">    122</span> <span class="nop">           .          .           	VPBROADCASTB  X0, Y1 </span>
<span class="line">    123</span> <span class="nop">           .          .           avx2_loop: </span>
<span class="line">    124</span> <span class="nop">        10ms       10ms           	VMOVDQU (DI), Y2 </span>
<span class="line">    125</span> <span class="nop">        10ms       10ms           	VPCMPEQB Y1, Y2, Y3 </span>
<span class="line">    126</span> <span class="nop">        20ms       20ms           	VPTEST Y3, Y3 </span>
<span class="line">    127</span> <span class="nop">        10ms       10ms           	JNZ avx2success </span>
<span class="line">    128</span> <span class="nop">        20ms       20ms           	ADDQ $32, DI </span>
<span class="line">    129</span> <span class="nop">           .          .           	CMPQ DI, R11 </span>
<span class="line">    130</span> <span class="nop">           .          .           	JLT avx2_loop </span>
<span class="line">    131</span> <span class="nop">           .          .           	MOVQ R11, DI </span>
<span class="line">    132</span> <span class="nop">           .          .           	VMOVDQU (DI), Y2 </span>
<span class="line">    133</span> <span class="nop">           .          .           	VPCMPEQB Y1, Y2, Y3 </span>
</pre>
<h2>runtime.markBits.isMarked</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mbitmap.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        70ms       70ms (flat, cum)  0.56%
<span class="line">    278</span> <span class="nop">           .          .           	return markBits{(*uint8)(s.gcmarkBits), uint8(1), 0} </span>
<span class="line">    279</span> <span class="nop">           .          .           } </span>
<span class="line">    280</span> <span class="nop">           .          .            </span>
<span class="line">    281</span> <span class="nop">           .          .           // isMarked reports whether mark bit m is set. </span>
<span class="line">    282</span> <span class="nop">           .          .           func (m markBits) isMarked() bool { </span>
<span class="line">    283</span> <span class="nop">        70ms       70ms           	return *m.bytep&amp;m.mask != 0 </span>
<span class="line">    284</span> <span class="nop">           .          .           } </span>
<span class="line">    285</span> <span class="nop">           .          .            </span>
<span class="line">    286</span> <span class="nop">           .          .           // setMarked sets the marked bit in the markbits, atomically. </span>
<span class="line">    287</span> <span class="nop">           .          .           func (m markBits) setMarked() { </span>
<span class="line">    288</span> <span class="nop">           .          .           	// Might be racing with other updates, so use atomic update always. </span>
</pre>
<h2>runtime.gcWriteBarrier</h2><p class="filename">C:\blockchainenv\Go\src\runtime\asm_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        70ms      230ms (flat, cum)  1.84%
<span class="line">   1357</span> <span class="nop">           .          .           // but may clobber others (e.g., SSE registers). </span>
<span class="line">   1358</span> <span class="nop">           .          .           TEXT runtime·gcWriteBarrier(SB),NOSPLIT,$120 </span>
<span class="line">   1359</span> <span class="nop">           .          .           	// Save the registers clobbered by the fast path. This is slightly </span>
<span class="line">   1360</span> <span class="nop">           .          .           	// faster than having the caller spill these. </span>
<span class="line">   1361</span> <span class="nop">           .          .           	MOVQ	R14, 104(SP) </span>
<span class="line">   1362</span> <span class="nop">        10ms       10ms           	MOVQ	R13, 112(SP) </span>
<span class="line">   1363</span> <span class="nop">           .          .           	// TODO: Consider passing g.m.p in as an argument so they can be shared </span>
<span class="line">   1364</span> <span class="nop">           .          .           	// across a sequence of write barriers. </span>
<span class="line">   1365</span> <span class="nop">           .          .           	get_tls(R13) </span>
<span class="line">   1366</span> <span class="nop">           .          .           	MOVQ	g(R13), R13 </span>
<span class="line">   1367</span> <span class="nop">           .          .           	MOVQ	g_m(R13), R13 </span>
<span class="line">   1368</span> <span class="nop">        10ms       10ms           	MOVQ	m_p(R13), R13 </span>
<span class="line">   1369</span> <span class="nop">        30ms       30ms           	MOVQ	(p_wbBuf+wbBuf_next)(R13), R14 </span>
<span class="line">   1370</span> <span class="nop">           .          .           	// Increment wbBuf.next position. </span>
<span class="line">   1371</span> <span class="nop">        20ms       20ms           	LEAQ	16(R14), R14 </span>
<span class="line">   1372</span> <span class="nop">           .          .           	MOVQ	R14, (p_wbBuf+wbBuf_next)(R13) </span>
<span class="line">   1373</span> <span class="nop">           .          .           	CMPQ	R14, (p_wbBuf+wbBuf_end)(R13) </span>
<span class="line">   1374</span> <span class="nop">           .          .           	// Record the write. </span>
<span class="line">   1375</span> <span class="nop">           .          .           	MOVQ	AX, -16(R14)	// Record value </span>
<span class="line">   1376</span> <span class="nop">           .          .           	// Note: This turns bad pointer writes into bad </span>
<span class="line">   1377</span> <span class="nop">           .          .           	// pointer reads, which could be confusing. We could avoid </span>
<span class="line">   1378</span> <span class="nop">           .          .           	// reading from obviously bad pointers, which would </span>
<span class="line">   1379</span> <span class="nop">           .          .           	// take care of the vast majority of these. We could </span>
<span class="line">   1380</span> <span class="nop">           .          .           	// patch this up in the signal handler, or use XCHG to </span>
<span class="line">   1381</span> <span class="nop">           .          .           	// combine the read and the write. </span>
<span class="line">   1382</span> <span class="nop">           .          .           	MOVQ	(DI), R13 </span>
<span class="line">   1383</span> <span class="nop">           .          .           	MOVQ	R13, -8(R14)	// Record *slot </span>
<span class="line">   1384</span> <span class="nop">           .          .           	// Is the buffer full? (flags set in CMPQ above) </span>
<span class="line">   1385</span> <span class="nop">           .          .           	JEQ	flush </span>
<span class="line">   1386</span> <span class="nop">           .          .           ret: </span>
<span class="line">   1387</span> <span class="nop">           .          .           	MOVQ	104(SP), R14 </span>
<span class="line">   1388</span> <span class="nop">           .          .           	MOVQ	112(SP), R13 </span>
<span class="line">   1389</span> <span class="nop">           .          .           	// Do the write. </span>
<span class="line">   1390</span> <span class="nop">           .          .           	MOVQ	AX, (DI) </span>
<span class="line">   1391</span> <span class="nop">           .          .           	RET </span>
<span class="line">   1392</span> <span class="nop">           .          .            </span>
<span class="line">   1393</span> <span class="nop">           .          .           flush: </span>
<span class="line">   1394</span> <span class="nop">           .          .           	// Save all general purpose registers since these could be </span>
<span class="line">   1395</span> <span class="nop">           .          .           	// clobbered by wbBufFlush and were not saved by the caller. </span>
<span class="line">   1396</span> <span class="nop">           .          .           	// It is possible for wbBufFlush to clobber other registers </span>
<span class="line">   1397</span> <span class="nop">           .          .           	// (e.g., SSE registers), but the compiler takes care of saving </span>
<span class="line">   1398</span> <span class="nop">           .          .           	// those in the caller if necessary. This strikes a balance </span>
<span class="line">   1399</span> <span class="nop">           .          .           	// with registers that are likely to be used. </span>
<span class="line">   1400</span> <span class="nop">           .          .           	// </span>
<span class="line">   1401</span> <span class="nop">           .          .           	// We don't have type information for these, but all code under </span>
<span class="line">   1402</span> <span class="nop">           .          .           	// here is NOSPLIT, so nothing will observe these. </span>
<span class="line">   1403</span> <span class="nop">           .          .           	// </span>
<span class="line">   1404</span> <span class="nop">           .          .           	// TODO: We could strike a different balance; e.g., saving X0 </span>
<span class="line">   1405</span> <span class="nop">           .          .           	// and not saving GP registers that are less likely to be used. </span>
<span class="line">   1406</span> <span class="nop">           .          .           	MOVQ	DI, 0(SP)	// Also first argument to wbBufFlush </span>
<span class="line">   1407</span> <span class="nop">           .          .           	MOVQ	AX, 8(SP)	// Also second argument to wbBufFlush </span>
<span class="line">   1408</span> <span class="nop">           .          .           	MOVQ	BX, 16(SP) </span>
<span class="line">   1409</span> <span class="nop">           .          .           	MOVQ	CX, 24(SP) </span>
<span class="line">   1410</span> <span class="nop">           .          .           	MOVQ	DX, 32(SP) </span>
<span class="line">   1411</span> <span class="nop">           .          .           	// DI already saved </span>
<span class="line">   1412</span> <span class="nop">           .          .           	MOVQ	SI, 40(SP) </span>
<span class="line">   1413</span> <span class="nop">           .          .           	MOVQ	BP, 48(SP) </span>
<span class="line">   1414</span> <span class="nop">           .          .           	MOVQ	R8, 56(SP) </span>
<span class="line">   1415</span> <span class="nop">           .          .           	MOVQ	R9, 64(SP) </span>
<span class="line">   1416</span> <span class="nop">           .          .           	MOVQ	R10, 72(SP) </span>
<span class="line">   1417</span> <span class="nop">           .          .           	MOVQ	R11, 80(SP) </span>
<span class="line">   1418</span> <span class="nop">           .          .           	MOVQ	R12, 88(SP) </span>
<span class="line">   1419</span> <span class="nop">           .          .           	// R13 already saved </span>
<span class="line">   1420</span> <span class="nop">           .          .           	// R14 already saved </span>
<span class="line">   1421</span> <span class="nop">           .          .           	MOVQ	R15, 96(SP) </span>
<span class="line">   1422</span> <span class="nop">           .          .            </span>
<span class="line">   1423</span> <span class="nop">           .          .           	// This takes arguments DI and AX </span>
<span class="line">   1424</span> <span class="nop">           .      160ms           	CALL	runtime·wbBufFlush(SB) </span>
<span class="line">   1425</span> <span class="nop">           .          .            </span>
<span class="line">   1426</span> <span class="nop">           .          .           	MOVQ	0(SP), DI </span>
<span class="line">   1427</span> <span class="nop">           .          .           	MOVQ	8(SP), AX </span>
<span class="line">   1428</span> <span class="nop">           .          .           	MOVQ	16(SP), BX </span>
<span class="line">   1429</span> <span class="nop">           .          .           	MOVQ	24(SP), CX </span>
</pre>
<h2>runtime.getStackMap</h2><p class="filename">C:\blockchainenv\Go\src\runtime\stack.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        60ms      330ms (flat, cum)  2.64%
<span class="line">   1187</span> <span class="nop">           .          .           		// Back up to the CALL. If we're at the function entry </span>
<span class="line">   1188</span> <span class="nop">           .          .           		// point, we want to use the entry map (-1), even if </span>
<span class="line">   1189</span> <span class="nop">           .          .           		// the first instruction of the function changes the </span>
<span class="line">   1190</span> <span class="nop">           .          .           		// stack map. </span>
<span class="line">   1191</span> <span class="nop">           .          .           		targetpc-- </span>
<span class="line">   1192</span> <span class="nop">           .      260ms           		pcdata = pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache) </span>
<span class="line">   1193</span> <span class="nop">           .          .           	} </span>
<span class="line">   1194</span> <span class="nop">           .          .           	if pcdata == -1 { </span>
<span class="line">   1195</span> <span class="nop">           .          .           		// We do not have a valid pcdata value but there might be a </span>
<span class="line">   1196</span> <span class="nop">           .          .           		// stackmap for this function. It is likely that we are looking </span>
<span class="line">   1197</span> <span class="nop">           .          .           		// at the function prologue, assume so and hope for the best. </span>
<span class="line">   1198</span> <span class="nop">           .          .           		pcdata = 0 </span>
<span class="line">   1199</span> <span class="nop">           .          .           	} </span>
<span class="line">   1200</span> <span class="nop">           .          .            </span>
<span class="line">   1201</span> <span class="nop">           .          .           	// Local variables. </span>
<span class="line">   1202</span> <span class="nop">           .          .           	size := frame.varp - frame.sp </span>
<span class="line">   1203</span> <span class="nop">           .          .           	var minsize uintptr </span>
<span class="line">   1204</span> <span class="nop">           .          .           	switch sys.ArchFamily { </span>
<span class="line">   1205</span> <span class="nop">           .          .           	case sys.ARM64: </span>
<span class="line">   1206</span> <span class="nop">           .          .           		minsize = sys.SpAlign </span>
<span class="line">   1207</span> <span class="nop">           .          .           	default: </span>
<span class="line">   1208</span> <span class="nop">           .          .           		minsize = sys.MinFrameSize </span>
<span class="line">   1209</span> <span class="nop">           .          .           	} </span>
<span class="line">   1210</span> <span class="nop">           .          .           	if size &gt; minsize { </span>
<span class="line">   1211</span> <span class="nop">           .          .           		var stkmap *stackmap </span>
<span class="line">   1212</span> <span class="nop">           .          .           		stackid := pcdata </span>
<span class="line">   1213</span> <span class="nop">           .          .           		if f.funcID != funcID_debugCallV1 { </span>
<span class="line">   1214</span> <span class="nop">           .          .           			stkmap = (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps)) </span>
<span class="line">   1215</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   1216</span> <span class="nop">           .          .           			// debugCallV1's stack map is the register map </span>
<span class="line">   1217</span> <span class="nop">           .          .           			// at its call site. </span>
<span class="line">   1218</span> <span class="nop">           .          .           			callerPC := frame.lr </span>
<span class="line">   1219</span> <span class="nop">           .          .           			caller := findfunc(callerPC) </span>
<span class="line">   1220</span> <span class="nop">           .          .           			if !caller.valid() { </span>
<span class="line">   1221</span> <span class="nop">           .          .           				println("runtime: debugCallV1 called by unknown caller", hex(callerPC)) </span>
<span class="line">   1222</span> <span class="nop">           .          .           				throw("bad debugCallV1") </span>
<span class="line">   1223</span> <span class="nop">           .          .           			} </span>
<span class="line">   1224</span> <span class="nop">           .          .           			stackid = int32(-1) </span>
<span class="line">   1225</span> <span class="nop">           .          .           			if callerPC != caller.entry { </span>
<span class="line">   1226</span> <span class="nop">           .          .           				callerPC-- </span>
<span class="line">   1227</span> <span class="nop">           .          .           				stackid = pcdatavalue(caller, _PCDATA_RegMapIndex, callerPC, cache) </span>
<span class="line">   1228</span> <span class="nop">           .          .           			} </span>
<span class="line">   1229</span> <span class="nop">           .          .           			if stackid == -1 { </span>
<span class="line">   1230</span> <span class="nop">           .          .           				stackid = 0 // in prologue </span>
<span class="line">   1231</span> <span class="nop">           .          .           			} </span>
<span class="line">   1232</span> <span class="nop">           .          .           			stkmap = (*stackmap)(funcdata(caller, _FUNCDATA_RegPointerMaps)) </span>
<span class="line">   1233</span> <span class="nop">           .          .           		} </span>
<span class="line">   1234</span> <span class="nop">        30ms       30ms           		if stkmap == nil || stkmap.n &lt;= 0 { </span>
<span class="line">   1235</span> <span class="nop">           .          .           			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n") </span>
<span class="line">   1236</span> <span class="nop">           .          .           			throw("missing stackmap") </span>
<span class="line">   1237</span> <span class="nop">           .          .           		} </span>
<span class="line">   1238</span> <span class="nop">           .          .           		// If nbit == 0, there's no work to do. </span>
<span class="line">   1239</span> <span class="nop">           .          .           		if stkmap.nbit &gt; 0 { </span>
<span class="line">   1240</span> <span class="nop">           .          .           			if stackid &lt; 0 || stackid &gt;= stkmap.n { </span>
<span class="line">   1241</span> <span class="nop">           .          .           				// don't know where we are </span>
<span class="line">   1242</span> <span class="nop">           .          .           				print("runtime: pcdata is ", stackid, " and ", stkmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n") </span>
<span class="line">   1243</span> <span class="nop">           .          .           				throw("bad symbol table") </span>
<span class="line">   1244</span> <span class="nop">           .          .           			} </span>
<span class="line">   1245</span> <span class="nop">           .          .           			locals = stackmapdata(stkmap, stackid) </span>
<span class="line">   1246</span> <span class="nop">           .          .           			if stackDebug &gt;= 3 &amp;&amp; debug { </span>
<span class="line">   1247</span> <span class="nop">           .          .           				print("      locals ", stackid, "/", stkmap.n, " ", locals.n, " words ", locals.bytedata, "\n") </span>
<span class="line">   1248</span> <span class="nop">           .          .           			} </span>
<span class="line">   1249</span> <span class="nop">           .          .           		} else if stackDebug &gt;= 3 &amp;&amp; debug { </span>
<span class="line">   1250</span> <span class="nop">           .          .           			print("      no locals to adjust\n") </span>
<span class="line">   1251</span> <span class="nop">           .          .           		} </span>
<span class="line">   1252</span> <span class="nop">           .          .           	} </span>
<span class="line">   1253</span> <span class="nop">           .          .            </span>
<span class="line">   1254</span> <span class="nop">           .          .           	// Arguments. </span>
<span class="line">   1255</span> <span class="nop">           .          .           	if frame.arglen &gt; 0 { </span>
<span class="line">   1256</span> <span class="nop">           .          .           		if frame.argmap != nil { </span>
<span class="line">   1257</span> <span class="nop">           .          .           			// argmap is set when the function is reflect.makeFuncStub or reflect.methodValueCall. </span>
<span class="line">   1258</span> <span class="nop">           .          .           			// In this case, arglen specifies how much of the args section is actually live. </span>
<span class="line">   1259</span> <span class="nop">           .          .           			// (It could be either all the args + results, or just the args.) </span>
<span class="line">   1260</span> <span class="nop">           .          .           			args = *frame.argmap </span>
<span class="line">   1261</span> <span class="nop">           .          .           			n := int32(frame.arglen / sys.PtrSize) </span>
<span class="line">   1262</span> <span class="nop">           .          .           			if n &lt; args.n { </span>
<span class="line">   1263</span> <span class="nop">           .          .           				args.n = n // Don't use more of the arguments than arglen. </span>
<span class="line">   1264</span> <span class="nop">           .          .           			} </span>
<span class="line">   1265</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   1266</span> <span class="nop">           .       10ms           			stackmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps)) </span>
<span class="line">   1267</span> <span class="nop">        10ms       10ms           			if stackmap == nil || stackmap.n &lt;= 0 { </span>
<span class="line">   1268</span> <span class="nop">           .          .           				print("runtime: frame ", funcname(f), " untyped args ", hex(frame.argp), "+", hex(frame.arglen), "\n") </span>
<span class="line">   1269</span> <span class="nop">           .          .           				throw("missing stackmap") </span>
<span class="line">   1270</span> <span class="nop">           .          .           			} </span>
<span class="line">   1271</span> <span class="nop">           .          .           			if pcdata &lt; 0 || pcdata &gt;= stackmap.n { </span>
<span class="line">   1272</span> <span class="nop">           .          .           				// don't know where we are </span>
<span class="line">   1273</span> <span class="nop">           .          .           				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n") </span>
<span class="line">   1274</span> <span class="nop">           .          .           				throw("bad symbol table") </span>
<span class="line">   1275</span> <span class="nop">           .          .           			} </span>
<span class="line">   1276</span> <span class="nop">           .          .           			if stackmap.nbit &gt; 0 { </span>
<span class="line">   1277</span> <span class="nop">           .          .           				args = stackmapdata(stackmap, pcdata) </span>
<span class="line">   1278</span> <span class="nop">           .          .           			} </span>
<span class="line">   1279</span> <span class="nop">           .          .           		} </span>
<span class="line">   1280</span> <span class="nop">           .          .           	} </span>
<span class="line">   1281</span> <span class="nop">           .          .            </span>
<span class="line">   1282</span> <span class="nop">           .          .           	// stack objects. </span>
<span class="line">   1283</span> <span class="nop">           .          .           	p := funcdata(f, _FUNCDATA_StackObjects) </span>
<span class="line">   1284</span> <span class="nop">           .          .           	if p != nil { </span>
<span class="line">   1285</span> <span class="nop">           .          .           		n := *(*uintptr)(p) </span>
<span class="line">   1286</span> <span class="nop">        20ms       20ms           		p = add(p, sys.PtrSize) </span>
<span class="line">   1287</span> <span class="nop">           .          .           		*(*slice)(unsafe.Pointer(&amp;objs)) = slice{array: noescape(p), len: int(n), cap: int(n)} </span>
<span class="line">   1288</span> <span class="nop">           .          .           		// Note: the noescape above is needed to keep </span>
<span class="line">   1289</span> <span class="nop">           .          .           		// getStackMap from "leaking param content: </span>
<span class="line">   1290</span> <span class="nop">           .          .           		// frame".  That leak propagates up to getgcmask, then </span>
<span class="line">   1291</span> <span class="nop">           .          .           		// GCMask, then verifyGCInfo, which converts the stack </span>
</pre>
<h2>runtime.selectgo</h2><p class="filename">C:\blockchainenv\Go\src\runtime\select.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        50ms      120ms (flat, cum)  0.96%
<span class="line">    167</span> <span class="nop">           .          .           			lockorder[j] = lockorder[k] </span>
<span class="line">    168</span> <span class="nop">           .          .           			j = k </span>
<span class="line">    169</span> <span class="nop">           .          .           		} </span>
<span class="line">    170</span> <span class="nop">           .          .           		lockorder[j] = pollorder[i] </span>
<span class="line">    171</span> <span class="nop">           .          .           	} </span>
<span class="line">    172</span> <span class="nop">        10ms       10ms           	for i := ncases - 1; i &gt;= 0; i-- { </span>
<span class="line">    173</span> <span class="nop">           .          .           		o := lockorder[i] </span>
<span class="line">    174</span> <span class="nop">           .          .           		c := scases[o].c </span>
<span class="line">    175</span> <span class="nop">           .          .           		lockorder[i] = lockorder[0] </span>
<span class="line">    176</span> <span class="nop">           .          .           		j := 0 </span>
<span class="line">    177</span> <span class="nop">           .          .           		for { </span>
<span class="line">    178</span> <span class="nop">           .          .           			k := j*2 + 1 </span>
<span class="line">    179</span> <span class="nop">           .          .           			if k &gt;= i { </span>
<span class="line">    180</span> <span class="nop">           .          .           				break </span>
<span class="line">    181</span> <span class="nop">           .          .           			} </span>
<span class="line">    182</span> <span class="nop">           .          .           			if k+1 &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+1]].c.sortkey() { </span>
<span class="line">    183</span> <span class="nop">           .          .           				k++ </span>
<span class="line">    184</span> <span class="nop">           .          .           			} </span>
<span class="line">    185</span> <span class="nop">           .          .           			if c.sortkey() &lt; scases[lockorder[k]].c.sortkey() { </span>
<span class="line">    186</span> <span class="nop">           .          .           				lockorder[j] = lockorder[k] </span>
<span class="line">    187</span> <span class="nop">           .          .           				j = k </span>
<span class="line">    188</span> <span class="nop">           .          .           				continue </span>
<span class="line">    189</span> <span class="nop">           .          .           			} </span>
<span class="line">    190</span> <span class="nop">           .          .           			break </span>
<span class="line">    191</span> <span class="nop">           .          .           		} </span>
<span class="line">    192</span> <span class="nop">           .          .           		lockorder[j] = o </span>
<span class="line">    193</span> <span class="nop">           .          .           	} </span>
<span class="line">    194</span> <span class="nop">           .          .            </span>
<span class="line">    195</span> <span class="nop">           .          .           	if debugSelect { </span>
<span class="line">    196</span> <span class="nop">           .          .           		for i := 0; i+1 &lt; ncases; i++ { </span>
<span class="line">    197</span> <span class="nop">           .          .           			if scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+1]].c.sortkey() { </span>
<span class="line">    198</span> <span class="nop">           .          .           				print("i=", i, " x=", lockorder[i], " y=", lockorder[i+1], "\n") </span>
<span class="line">    199</span> <span class="nop">           .          .           				throw("select: broken sort") </span>
<span class="line">    200</span> <span class="nop">           .          .           			} </span>
<span class="line">    201</span> <span class="nop">           .          .           		} </span>
<span class="line">    202</span> <span class="nop">           .          .           	} </span>
<span class="line">    203</span> <span class="nop">           .          .            </span>
<span class="line">    204</span> <span class="nop">           .          .           	// lock all the channels involved in the select </span>
<span class="line">    205</span> <span class="nop">           .       20ms           	sellock(scases, lockorder) </span>
<span class="line">    206</span> <span class="nop">           .          .            </span>
<span class="line">    207</span> <span class="nop">           .          .           	var ( </span>
<span class="line">    208</span> <span class="nop">           .          .           		gp     *g </span>
<span class="line">    209</span> <span class="nop">           .          .           		sg     *sudog </span>
<span class="line">    210</span> <span class="nop">           .          .           		c      *hchan </span>
<span class="line">    211</span> <span class="nop">           .          .           		k      *scase </span>
<span class="line">    212</span> <span class="nop">           .          .           		sglist *sudog </span>
<span class="line">    213</span> <span class="nop">           .          .           		sgnext *sudog </span>
<span class="line">    214</span> <span class="nop">           .          .           		qp     unsafe.Pointer </span>
<span class="line">    215</span> <span class="nop">           .          .           		nextp  **sudog </span>
<span class="line">    216</span> <span class="nop">           .          .           	) </span>
<span class="line">    217</span> <span class="nop">           .          .            </span>
<span class="line">    218</span> <span class="nop">           .          .           loop: </span>
<span class="line">    219</span> <span class="nop">           .          .           	// pass 1 - look for something already waiting </span>
<span class="line">    220</span> <span class="nop">           .          .           	var dfli int </span>
<span class="line">    221</span> <span class="nop">           .          .           	var dfl *scase </span>
<span class="line">    222</span> <span class="nop">           .          .           	var casi int </span>
<span class="line">    223</span> <span class="nop">           .          .           	var cas *scase </span>
<span class="line">    224</span> <span class="nop">           .          .           	var recvOK bool </span>
<span class="line">    225</span> <span class="nop">           .          .           	for i := 0; i &lt; ncases; i++ { </span>
<span class="line">    226</span> <span class="nop">           .          .           		casi = int(pollorder[i]) </span>
<span class="line">    227</span> <span class="nop">           .          .           		cas = &amp;scases[casi] </span>
<span class="line">    228</span> <span class="nop">           .          .           		c = cas.c </span>
<span class="line">    229</span> <span class="nop">           .          .            </span>
<span class="line">    230</span> <span class="nop">           .          .           		switch cas.kind { </span>
<span class="line">    231</span> <span class="nop">           .          .           		case caseNil: </span>
<span class="line">    232</span> <span class="nop">           .          .           			continue </span>
<span class="line">    233</span> <span class="nop">           .          .            </span>
<span class="line">    234</span> <span class="nop">           .          .           		case caseRecv: </span>
<span class="line">    235</span> <span class="nop">           .       10ms           			sg = c.sendq.dequeue() </span>
<span class="line">    236</span> <span class="nop">           .          .           			if sg != nil { </span>
<span class="line">    237</span> <span class="nop">           .          .           				goto recv </span>
<span class="line">    238</span> <span class="nop">           .          .           			} </span>
<span class="line">    239</span> <span class="nop">           .          .           			if c.qcount &gt; 0 { </span>
<span class="line">    240</span> <span class="nop">           .          .           				goto bufrecv </span>
<span class="line">    241</span> <span class="nop">           .          .           			} </span>
<span class="line">    242</span> <span class="nop">           .          .           			if c.closed != 0 { </span>
<span class="line">    243</span> <span class="nop">           .          .           				goto rclose </span>
<span class="line">    244</span> <span class="nop">           .          .           			} </span>
<span class="line">    245</span> <span class="nop">           .          .            </span>
<span class="line">    246</span> <span class="nop">           .          .           		case caseSend: </span>
<span class="line">    247</span> <span class="nop">           .          .           			if raceenabled { </span>
<span class="line">    248</span> <span class="nop">           .          .           				racereadpc(c.raceaddr(), cas.pc, chansendpc) </span>
<span class="line">    249</span> <span class="nop">           .          .           			} </span>
<span class="line">    250</span> <span class="nop">           .          .           			if c.closed != 0 { </span>
<span class="line">    251</span> <span class="nop">           .          .           				goto sclose </span>
<span class="line">    252</span> <span class="nop">           .          .           			} </span>
<span class="line">    253</span> <span class="nop">           .          .           			sg = c.recvq.dequeue() </span>
<span class="line">    254</span> <span class="nop">           .          .           			if sg != nil { </span>
<span class="line">    255</span> <span class="nop">           .          .           				goto send </span>
<span class="line">    256</span> <span class="nop">           .          .           			} </span>
<span class="line">    257</span> <span class="nop">           .          .           			if c.qcount &lt; c.dataqsiz { </span>
<span class="line">    258</span> <span class="nop">           .          .           				goto bufsend </span>
<span class="line">    259</span> <span class="nop">           .          .           			} </span>
<span class="line">    260</span> <span class="nop">           .          .            </span>
<span class="line">    261</span> <span class="nop">           .          .           		case caseDefault: </span>
<span class="line">    262</span> <span class="nop">           .          .           			dfli = casi </span>
<span class="line">    263</span> <span class="nop">           .          .           			dfl = cas </span>
<span class="line">    264</span> <span class="nop">           .          .           		} </span>
<span class="line">    265</span> <span class="nop">           .          .           	} </span>
<span class="line">    266</span> <span class="nop">           .          .            </span>
<span class="line">    267</span> <span class="nop">        10ms       10ms           	if dfl != nil { </span>
<span class="line">    268</span> <span class="nop">           .          .           		selunlock(scases, lockorder) </span>
<span class="line">    269</span> <span class="nop">           .          .           		casi = dfli </span>
<span class="line">    270</span> <span class="nop">           .          .           		cas = dfl </span>
<span class="line">    271</span> <span class="nop">           .          .           		goto retc </span>
<span class="line">    272</span> <span class="nop">           .          .           	} </span>
<span class="line">    273</span> <span class="nop">           .          .            </span>
<span class="line">    274</span> <span class="nop">           .          .           	// pass 2 - enqueue on all chans </span>
<span class="line">    275</span> <span class="nop">           .          .           	gp = getg() </span>
<span class="line">    276</span> <span class="nop">           .          .           	if gp.waiting != nil { </span>
<span class="line">    277</span> <span class="nop">           .          .           		throw("gp.waiting != nil") </span>
<span class="line">    278</span> <span class="nop">           .          .           	} </span>
<span class="line">    279</span> <span class="nop">           .          .           	nextp = &amp;gp.waiting </span>
<span class="line">    280</span> <span class="nop">        10ms       10ms           	for _, casei := range lockorder { </span>
<span class="line">    281</span> <span class="nop">           .          .           		casi = int(casei) </span>
<span class="line">    282</span> <span class="nop">           .          .           		cas = &amp;scases[casi] </span>
<span class="line">    283</span> <span class="nop">           .          .           		if cas.kind == caseNil { </span>
<span class="line">    284</span> <span class="nop">           .          .           			continue </span>
<span class="line">    285</span> <span class="nop">           .          .           		} </span>
<span class="line">    286</span> <span class="nop">           .          .           		c = cas.c </span>
<span class="line">    287</span> <span class="nop">           .          .           		sg := acquireSudog() </span>
<span class="line">    288</span> <span class="nop">           .          .           		sg.g = gp </span>
<span class="line">    289</span> <span class="nop">           .          .           		sg.isSelect = true </span>
<span class="line">    290</span> <span class="nop">           .          .           		// No stack splits between assigning elem and enqueuing </span>
<span class="line">    291</span> <span class="nop">           .          .           		// sg on gp.waiting where copystack can find it. </span>
<span class="line">    292</span> <span class="nop">           .          .           		sg.elem = cas.elem </span>
<span class="line">    293</span> <span class="nop">           .          .           		sg.releasetime = 0 </span>
<span class="line">    294</span> <span class="nop">           .          .           		if t0 != 0 { </span>
<span class="line">    295</span> <span class="nop">           .          .           			sg.releasetime = -1 </span>
<span class="line">    296</span> <span class="nop">           .          .           		} </span>
<span class="line">    297</span> <span class="nop">           .          .           		sg.c = c </span>
<span class="line">    298</span> <span class="nop">           .          .           		// Construct waiting list in lock order. </span>
<span class="line">    299</span> <span class="nop">           .          .           		*nextp = sg </span>
<span class="line">    300</span> <span class="nop">           .          .           		nextp = &amp;sg.waitlink </span>
<span class="line">    301</span> <span class="nop">           .          .            </span>
<span class="line">    302</span> <span class="nop">           .          .           		switch cas.kind { </span>
<span class="line">    303</span> <span class="nop">           .          .           		case caseRecv: </span>
<span class="line">    304</span> <span class="nop">           .          .           			c.recvq.enqueue(sg) </span>
<span class="line">    305</span> <span class="nop">           .          .            </span>
<span class="line">    306</span> <span class="nop">           .          .           		case caseSend: </span>
<span class="line">    307</span> <span class="nop">           .          .           			c.sendq.enqueue(sg) </span>
<span class="line">    308</span> <span class="nop">           .          .           		} </span>
<span class="line">    309</span> <span class="nop">           .          .           	} </span>
<span class="line">    310</span> <span class="nop">           .          .            </span>
<span class="line">    311</span> <span class="nop">           .          .           	// wait for someone to wake us up </span>
<span class="line">    312</span> <span class="nop">           .          .           	gp.param = nil </span>
<span class="line">    313</span> <span class="nop">           .          .           	gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1) </span>
<span class="line">    314</span> <span class="nop">           .          .            </span>
<span class="line">    315</span> <span class="nop">           .       10ms           	sellock(scases, lockorder) </span>
<span class="line">    316</span> <span class="nop">           .          .            </span>
<span class="line">    317</span> <span class="nop">           .          .           	gp.selectDone = 0 </span>
<span class="line">    318</span> <span class="nop">           .          .           	sg = (*sudog)(gp.param) </span>
<span class="line">    319</span> <span class="nop">           .          .           	gp.param = nil </span>
<span class="line">    320</span> <span class="nop">           .          .            </span>
<span class="line">    321</span> <span class="nop">           .          .           	// pass 3 - dequeue from unsuccessful chans </span>
<span class="line">    322</span> <span class="nop">           .          .           	// otherwise they stack up on quiet channels </span>
<span class="line">    323</span> <span class="nop">           .          .           	// record the successful case, if any. </span>
<span class="line">    324</span> <span class="nop">           .          .           	// We singly-linked up the SudoGs in lock order. </span>
<span class="line">    325</span> <span class="nop">           .          .           	casi = -1 </span>
<span class="line">    326</span> <span class="nop">           .          .           	cas = nil </span>
<span class="line">    327</span> <span class="nop">           .          .           	sglist = gp.waiting </span>
<span class="line">    328</span> <span class="nop">           .          .           	// Clear all elem before unlinking from gp.waiting. </span>
<span class="line">    329</span> <span class="nop">           .          .           	for sg1 := gp.waiting; sg1 != nil; sg1 = sg1.waitlink { </span>
<span class="line">    330</span> <span class="nop">        10ms       10ms           		sg1.isSelect = false </span>
<span class="line">    331</span> <span class="nop">        10ms       10ms           		sg1.elem = nil </span>
<span class="line">    332</span> <span class="nop">           .          .           		sg1.c = nil </span>
<span class="line">    333</span> <span class="nop">           .          .           	} </span>
<span class="line">    334</span> <span class="nop">           .          .           	gp.waiting = nil </span>
<span class="line">    335</span> <span class="nop">           .          .            </span>
<span class="line">    336</span> <span class="nop">           .          .           	for _, casei := range lockorder { </span>
<span class="line">    337</span> <span class="nop">           .          .           		k = &amp;scases[casei] </span>
<span class="line">    338</span> <span class="nop">           .          .           		if k.kind == caseNil { </span>
<span class="line">    339</span> <span class="nop">           .          .           			continue </span>
<span class="line">    340</span> <span class="nop">           .          .           		} </span>
<span class="line">    341</span> <span class="nop">           .          .           		if sglist.releasetime &gt; 0 { </span>
<span class="line">    342</span> <span class="nop">           .          .           			k.releasetime = sglist.releasetime </span>
<span class="line">    343</span> <span class="nop">           .          .           		} </span>
<span class="line">    344</span> <span class="nop">           .          .           		if sg == sglist { </span>
<span class="line">    345</span> <span class="nop">           .          .           			// sg has already been dequeued by the G that woke us up. </span>
<span class="line">    346</span> <span class="nop">           .          .           			casi = int(casei) </span>
<span class="line">    347</span> <span class="nop">           .          .           			cas = k </span>
<span class="line">    348</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    349</span> <span class="nop">           .          .           			c = k.c </span>
<span class="line">    350</span> <span class="nop">           .          .           			if k.kind == caseSend { </span>
<span class="line">    351</span> <span class="nop">           .          .           				c.sendq.dequeueSudoG(sglist) </span>
<span class="line">    352</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    353</span> <span class="nop">           .       10ms           				c.recvq.dequeueSudoG(sglist) </span>
<span class="line">    354</span> <span class="nop">           .          .           			} </span>
<span class="line">    355</span> <span class="nop">           .          .           		} </span>
<span class="line">    356</span> <span class="nop">           .          .           		sgnext = sglist.waitlink </span>
<span class="line">    357</span> <span class="nop">           .          .           		sglist.waitlink = nil </span>
<span class="line">    358</span> <span class="nop">           .          .           		releaseSudog(sglist) </span>
<span class="line">    359</span> <span class="nop">           .          .           		sglist = sgnext </span>
<span class="line">    360</span> <span class="nop">           .          .           	} </span>
<span class="line">    361</span> <span class="nop">           .          .            </span>
<span class="line">    362</span> <span class="nop">           .          .           	if cas == nil { </span>
<span class="line">    363</span> <span class="nop">           .          .           		// We can wake up with gp.param == nil (so cas == nil) </span>
<span class="line">    364</span> <span class="nop">           .          .           		// when a channel involved in the select has been closed. </span>
<span class="line">    365</span> <span class="nop">           .          .           		// It is easiest to loop and re-run the operation; </span>
<span class="line">    366</span> <span class="nop">           .          .           		// we'll see that it's now closed. </span>
<span class="line">    367</span> <span class="nop">           .          .           		// Maybe some day we can signal the close explicitly, </span>
<span class="line">    368</span> <span class="nop">           .          .           		// but we'd have to distinguish close-on-reader from close-on-writer. </span>
<span class="line">    369</span> <span class="nop">           .          .           		// It's easiest not to duplicate the code and just recheck above. </span>
<span class="line">    370</span> <span class="nop">           .          .           		// We know that something closed, and things never un-close, </span>
<span class="line">    371</span> <span class="nop">           .          .           		// so we won't block again. </span>
<span class="line">    372</span> <span class="nop">           .          .           		goto loop </span>
<span class="line">    373</span> <span class="nop">           .          .           	} </span>
<span class="line">    374</span> <span class="nop">           .          .            </span>
<span class="line">    375</span> <span class="nop">           .          .           	c = cas.c </span>
<span class="line">    376</span> <span class="nop">           .          .            </span>
<span class="line">    377</span> <span class="nop">           .          .           	if debugSelect { </span>
<span class="line">    378</span> <span class="nop">           .          .           		print("wait-return: cas0=", cas0, " c=", c, " cas=", cas, " kind=", cas.kind, "\n") </span>
<span class="line">    379</span> <span class="nop">           .          .           	} </span>
<span class="line">    380</span> <span class="nop">           .          .            </span>
<span class="line">    381</span> <span class="nop">           .          .           	if cas.kind == caseRecv { </span>
<span class="line">    382</span> <span class="nop">           .          .           		recvOK = true </span>
<span class="line">    383</span> <span class="nop">           .          .           	} </span>
<span class="line">    384</span> <span class="nop">           .          .            </span>
<span class="line">    385</span> <span class="nop">           .          .           	if raceenabled { </span>
<span class="line">    386</span> <span class="nop">           .          .           		if cas.kind == caseRecv &amp;&amp; cas.elem != nil { </span>
<span class="line">    387</span> <span class="nop">           .          .           			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc) </span>
<span class="line">    388</span> <span class="nop">           .          .           		} else if cas.kind == caseSend { </span>
<span class="line">    389</span> <span class="nop">           .          .           			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc) </span>
<span class="line">    390</span> <span class="nop">           .          .           		} </span>
<span class="line">    391</span> <span class="nop">           .          .           	} </span>
<span class="line">    392</span> <span class="nop">           .          .           	if msanenabled { </span>
<span class="line">    393</span> <span class="nop">           .          .           		if cas.kind == caseRecv &amp;&amp; cas.elem != nil { </span>
<span class="line">    394</span> <span class="nop">           .          .           			msanwrite(cas.elem, c.elemtype.size) </span>
<span class="line">    395</span> <span class="nop">           .          .           		} else if cas.kind == caseSend { </span>
<span class="line">    396</span> <span class="nop">           .          .           			msanread(cas.elem, c.elemtype.size) </span>
<span class="line">    397</span> <span class="nop">           .          .           		} </span>
<span class="line">    398</span> <span class="nop">           .          .           	} </span>
<span class="line">    399</span> <span class="nop">           .          .            </span>
<span class="line">    400</span> <span class="nop">           .       20ms           	selunlock(scases, lockorder) </span>
<span class="line">    401</span> <span class="nop">           .          .           	goto retc </span>
<span class="line">    402</span> <span class="nop">           .          .            </span>
<span class="line">    403</span> <span class="nop">           .          .           bufrecv: </span>
<span class="line">    404</span> <span class="nop">           .          .           	// can receive from buffer </span>
<span class="line">    405</span> <span class="nop">           .          .           	if raceenabled { </span>
</pre>
<h2>bytes.Index</h2><p class="filename">C:\blockchainenv\Go\src\bytes\bytes.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        50ms      170ms (flat, cum)  1.36%
<span class="line">    884</span> <span class="nop">           .          .           		fails := 0 </span>
<span class="line">    885</span> <span class="nop">           .          .           		for i &lt; t { </span>
<span class="line">    886</span> <span class="nop">           .          .           			if s[i] != c0 { </span>
<span class="line">    887</span> <span class="nop">           .          .           				// IndexByte is faster than bytealg.Index, so use it as long as </span>
<span class="line">    888</span> <span class="nop">           .          .           				// we're not getting lots of false positives. </span>
<span class="line">    889</span> <span class="nop">        20ms      100ms           				o := IndexByte(s[i:t], c0) </span>
<span class="line">    890</span> <span class="nop">           .          .           				if o &lt; 0 { </span>
<span class="line">    891</span> <span class="nop">           .          .           					return -1 </span>
<span class="line">    892</span> <span class="nop">           .          .           				} </span>
<span class="line">    893</span> <span class="nop">           .          .           				i += o </span>
<span class="line">    894</span> <span class="nop">           .          .           			} </span>
<span class="line">    895</span> <span class="nop">        30ms       40ms           			if s[i+1] == c1 &amp;&amp; Equal(s[i:i+n], sep) { </span>
<span class="line">    896</span> <span class="nop">           .          .           				return i </span>
<span class="line">    897</span> <span class="nop">           .          .           			} </span>
<span class="line">    898</span> <span class="nop">           .          .           			fails++ </span>
<span class="line">    899</span> <span class="nop">           .          .           			i++ </span>
<span class="line">    900</span> <span class="nop">           .          .           			// Switch to bytealg.Index when IndexByte produces too many false positives. </span>
<span class="line">    901</span> <span class="nop">           .       30ms           			if fails &gt; bytealg.Cutover(i) { </span>
<span class="line">    902</span> <span class="nop">           .          .           				r := bytealg.Index(s[i:], sep) </span>
<span class="line">    903</span> <span class="nop">           .          .           				if r &gt;= 0 { </span>
<span class="line">    904</span> <span class="nop">           .          .           					return r + i </span>
<span class="line">    905</span> <span class="nop">           .          .           				} </span>
<span class="line">    906</span> <span class="nop">           .          .           				return -1 </span>
</pre>
<h2>runtime.heapBitsSetType</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mbitmap.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms       40ms (flat, cum)  0.32%
<span class="line">    969</span> <span class="nop">           .          .           	// Heap bitmap bits for 2-word object are only 4 bits, </span>
<span class="line">    970</span> <span class="nop">           .          .           	// so also shared with objects next to it. </span>
<span class="line">    971</span> <span class="nop">           .          .           	// This is called out as a special case primarily for 32-bit systems, </span>
<span class="line">    972</span> <span class="nop">           .          .           	// so that on 32-bit systems the code below can assume all objects </span>
<span class="line">    973</span> <span class="nop">           .          .           	// are 4-word aligned (because they're all 16-byte aligned). </span>
<span class="line">    974</span> <span class="nop">        10ms       10ms           	if size == 2*sys.PtrSize { </span>
<span class="line">    975</span> <span class="nop">           .          .           		if typ.size == sys.PtrSize { </span>
<span class="line">    976</span> <span class="nop">           .          .           			// We're allocating a block big enough to hold two pointers. </span>
<span class="line">    977</span> <span class="nop">           .          .           			// On 64-bit, that means the actual object must be two pointers, </span>
<span class="line">    978</span> <span class="nop">           .          .           			// or else we'd have used the one-pointer-sized block. </span>
<span class="line">    979</span> <span class="nop">           .          .           			// On 32-bit, however, this is the 8-byte block, the smallest one. </span>
<span class="line">    980</span> <span class="nop">           .          .           			// So it could be that we're allocating one pointer and this was </span>
<span class="line">    981</span> <span class="nop">           .          .           			// just the smallest block available. Distinguish by checking dataSize. </span>
<span class="line">    982</span> <span class="nop">           .          .           			// (In general the number of instances of typ being allocated is </span>
<span class="line">    983</span> <span class="nop">           .          .           			// dataSize/typ.size.) </span>
<span class="line">    984</span> <span class="nop">           .          .           			if sys.PtrSize == 4 &amp;&amp; dataSize == sys.PtrSize { </span>
<span class="line">    985</span> <span class="nop">           .          .           				// 1 pointer object. On 32-bit machines clear the bit for the </span>
<span class="line">    986</span> <span class="nop">           .          .           				// unused second word. </span>
<span class="line">    987</span> <span class="nop">           .          .           				*h.bitp &amp;^= (bitPointer | bitScan | ((bitPointer | bitScan) &lt;&lt; heapBitsShift)) &lt;&lt; h.shift </span>
<span class="line">    988</span> <span class="nop">           .          .           				*h.bitp |= (bitPointer | bitScan) &lt;&lt; h.shift </span>
<span class="line">    989</span> <span class="nop">           .          .           			} else { </span>
<span class="line">    990</span> <span class="nop">           .          .           				// 2-element slice of pointer. </span>
<span class="line">    991</span> <span class="nop">           .          .           				*h.bitp |= (bitPointer | bitScan | bitPointer&lt;&lt;heapBitsShift) &lt;&lt; h.shift </span>
<span class="line">    992</span> <span class="nop">           .          .           			} </span>
<span class="line">    993</span> <span class="nop">           .          .           			return </span>
<span class="line">    994</span> <span class="nop">           .          .           		} </span>
<span class="line">    995</span> <span class="nop">           .          .           		// Otherwise typ.size must be 2*sys.PtrSize, </span>
<span class="line">    996</span> <span class="nop">           .          .           		// and typ.kind&amp;kindGCProg == 0. </span>
<span class="line">    997</span> <span class="nop">           .          .           		if doubleCheck { </span>
<span class="line">    998</span> <span class="nop">           .          .           			if typ.size != 2*sys.PtrSize || typ.kind&amp;kindGCProg != 0 { </span>
<span class="line">    999</span> <span class="nop">           .          .           				print("runtime: heapBitsSetType size=", size, " but typ.size=", typ.size, " gcprog=", typ.kind&amp;kindGCProg != 0, "\n") </span>
<span class="line">   1000</span> <span class="nop">           .          .           				throw("heapBitsSetType") </span>
<span class="line">   1001</span> <span class="nop">           .          .           			} </span>
<span class="line">   1002</span> <span class="nop">           .          .           		} </span>
<span class="line">   1003</span> <span class="nop">           .          .           		b := uint32(*ptrmask) </span>
<span class="line">   1004</span> <span class="nop">           .          .           		hb := (b &amp; 3) | bitScan </span>
<span class="line">   1005</span> <span class="nop">           .          .           		// bitPointer == 1, bitScan is 1 &lt;&lt; 4, heapBitsShift is 1. </span>
<span class="line">   1006</span> <span class="nop">           .          .           		// 110011 is shifted h.shift and complemented. </span>
<span class="line">   1007</span> <span class="nop">           .          .           		// This clears out the bits that are about to be </span>
<span class="line">   1008</span> <span class="nop">           .          .           		// ored into *h.hbitp in the next instructions. </span>
<span class="line">   1009</span> <span class="nop">           .          .           		*h.bitp &amp;^= (bitPointer | bitScan | ((bitPointer | bitScan) &lt;&lt; heapBitsShift)) &lt;&lt; h.shift </span>
<span class="line">   1010</span> <span class="nop">           .          .           		*h.bitp |= uint8(hb &lt;&lt; h.shift) </span>
<span class="line">   1011</span> <span class="nop">           .          .           		return </span>
<span class="line">   1012</span> <span class="nop">           .          .           	} </span>
<span class="line">   1013</span> <span class="nop">           .          .            </span>
<span class="line">   1014</span> <span class="nop">           .          .           	// Copy from 1-bit ptrmask into 2-bit bitmap. </span>
<span class="line">   1015</span> <span class="nop">           .          .           	// The basic approach is to use a single uintptr as a bit buffer, </span>
<span class="line">   1016</span> <span class="nop">           .          .           	// alternating between reloading the buffer and writing bitmap bytes. </span>
<span class="line">   1017</span> <span class="nop">           .          .           	// In general, one load can supply two bitmap byte writes. </span>
<span class="line">   1018</span> <span class="nop">           .          .           	// This is a lot of lines of code, but it compiles into relatively few </span>
<span class="line">   1019</span> <span class="nop">           .          .           	// machine instructions. </span>
<span class="line">   1020</span> <span class="nop">           .          .            </span>
<span class="line">   1021</span> <span class="nop">           .          .           	outOfPlace := false </span>
<span class="line">   1022</span> <span class="nop">        10ms       10ms           	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck &amp;&amp; fastrand()%2 == 0) { </span>
<span class="line">   1023</span> <span class="nop">           .          .           		// This object spans heap arenas, so the bitmap may be </span>
<span class="line">   1024</span> <span class="nop">           .          .           		// discontiguous. Unroll it into the object instead </span>
<span class="line">   1025</span> <span class="nop">           .          .           		// and then copy it out. </span>
<span class="line">   1026</span> <span class="nop">           .          .           		// </span>
<span class="line">   1027</span> <span class="nop">           .          .           		// In doubleCheck mode, we randomly do this anyway to </span>
<span class="line">   1028</span> <span class="nop">           .          .           		// stress test the bitmap copying path. </span>
<span class="line">   1029</span> <span class="nop">           .          .           		outOfPlace = true </span>
<span class="line">   1030</span> <span class="nop">           .          .           		h.bitp = (*uint8)(unsafe.Pointer(x)) </span>
<span class="line">   1031</span> <span class="nop">           .          .           		h.last = nil </span>
<span class="line">   1032</span> <span class="nop">           .          .           	} </span>
<span class="line">   1033</span> <span class="nop">           .          .            </span>
<span class="line">   1034</span> <span class="nop">           .          .           	var ( </span>
<span class="line">   1035</span> <span class="nop">           .          .           		// Ptrmask input. </span>
<span class="line">   1036</span> <span class="nop">           .          .           		p     *byte   // last ptrmask byte read </span>
<span class="line">   1037</span> <span class="nop">           .          .           		b     uintptr // ptrmask bits already loaded </span>
<span class="line">   1038</span> <span class="nop">           .          .           		nb    uintptr // number of bits in b at next read </span>
<span class="line">   1039</span> <span class="nop">           .          .           		endp  *byte   // final ptrmask byte to read (then repeat) </span>
<span class="line">   1040</span> <span class="nop">           .          .           		endnb uintptr // number of valid bits in *endp </span>
<span class="line">   1041</span> <span class="nop">           .          .           		pbits uintptr // alternate source of bits </span>
<span class="line">   1042</span> <span class="nop">           .          .            </span>
<span class="line">   1043</span> <span class="nop">           .          .           		// Heap bitmap output. </span>
<span class="line">   1044</span> <span class="nop">           .          .           		w     uintptr // words processed </span>
<span class="line">   1045</span> <span class="nop">           .          .           		nw    uintptr // number of words to process </span>
<span class="line">   1046</span> <span class="nop">           .          .           		hbitp *byte   // next heap bitmap byte to write </span>
<span class="line">   1047</span> <span class="nop">           .          .           		hb    uintptr // bits being prepared for *hbitp </span>
<span class="line">   1048</span> <span class="nop">           .          .           	) </span>
<span class="line">   1049</span> <span class="nop">           .          .            </span>
<span class="line">   1050</span> <span class="nop">           .          .           	hbitp = h.bitp </span>
<span class="line">   1051</span> <span class="nop">           .          .            </span>
<span class="line">   1052</span> <span class="nop">           .          .           	// Handle GC program. Delayed until this part of the code </span>
<span class="line">   1053</span> <span class="nop">           .          .           	// so that we can use the same double-checking mechanism </span>
<span class="line">   1054</span> <span class="nop">           .          .           	// as the 1-bit case. Nothing above could have encountered </span>
<span class="line">   1055</span> <span class="nop">           .          .           	// GC programs: the cases were all too small. </span>
<span class="line">   1056</span> <span class="nop">           .          .           	if typ.kind&amp;kindGCProg != 0 { </span>
<span class="line">   1057</span> <span class="nop">           .          .           		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4)) </span>
<span class="line">   1058</span> <span class="nop">           .          .           		if doubleCheck { </span>
<span class="line">   1059</span> <span class="nop">           .          .           			// Double-check the heap bits written by GC program </span>
<span class="line">   1060</span> <span class="nop">           .          .           			// by running the GC program to create a 1-bit pointer mask </span>
<span class="line">   1061</span> <span class="nop">           .          .           			// and then jumping to the double-check code below. </span>
<span class="line">   1062</span> <span class="nop">           .          .           			// This doesn't catch bugs shared between the 1-bit and 4-bit </span>
<span class="line">   1063</span> <span class="nop">           .          .           			// GC program execution, but it does catch mistakes specific </span>
<span class="line">   1064</span> <span class="nop">           .          .           			// to just one of those and bugs in heapBitsSetTypeGCProg's </span>
<span class="line">   1065</span> <span class="nop">           .          .           			// implementation of arrays. </span>
<span class="line">   1066</span> <span class="nop">           .          .           			lock(&amp;debugPtrmask.lock) </span>
<span class="line">   1067</span> <span class="nop">           .          .           			if debugPtrmask.data == nil { </span>
<span class="line">   1068</span> <span class="nop">           .          .           				debugPtrmask.data = (*byte)(persistentalloc(1&lt;&lt;20, 1, &amp;memstats.other_sys)) </span>
<span class="line">   1069</span> <span class="nop">           .          .           			} </span>
<span class="line">   1070</span> <span class="nop">           .          .           			ptrmask = debugPtrmask.data </span>
<span class="line">   1071</span> <span class="nop">           .          .           			runGCProg(addb(typ.gcdata, 4), nil, ptrmask, 1) </span>
<span class="line">   1072</span> <span class="nop">           .          .           		} </span>
<span class="line">   1073</span> <span class="nop">           .          .           		goto Phase4 </span>
<span class="line">   1074</span> <span class="nop">           .          .           	} </span>
<span class="line">   1075</span> <span class="nop">           .          .            </span>
<span class="line">   1076</span> <span class="nop">           .          .           	// Note about sizes: </span>
<span class="line">   1077</span> <span class="nop">           .          .           	// </span>
<span class="line">   1078</span> <span class="nop">           .          .           	// typ.size is the number of words in the object, </span>
<span class="line">   1079</span> <span class="nop">           .          .           	// and typ.ptrdata is the number of words in the prefix </span>
<span class="line">   1080</span> <span class="nop">           .          .           	// of the object that contains pointers. That is, the final </span>
<span class="line">   1081</span> <span class="nop">           .          .           	// typ.size - typ.ptrdata words contain no pointers. </span>
<span class="line">   1082</span> <span class="nop">           .          .           	// This allows optimization of a common pattern where </span>
<span class="line">   1083</span> <span class="nop">           .          .           	// an object has a small header followed by a large scalar </span>
<span class="line">   1084</span> <span class="nop">           .          .           	// buffer. If we know the pointers are over, we don't have </span>
<span class="line">   1085</span> <span class="nop">           .          .           	// to scan the buffer's heap bitmap at all. </span>
<span class="line">   1086</span> <span class="nop">           .          .           	// The 1-bit ptrmasks are sized to contain only bits for </span>
<span class="line">   1087</span> <span class="nop">           .          .           	// the typ.ptrdata prefix, zero padded out to a full byte </span>
<span class="line">   1088</span> <span class="nop">           .          .           	// of bitmap. This code sets nw (below) so that heap bitmap </span>
<span class="line">   1089</span> <span class="nop">           .          .           	// bits are only written for the typ.ptrdata prefix; if there is </span>
<span class="line">   1090</span> <span class="nop">           .          .           	// more room in the allocated object, the next heap bitmap </span>
<span class="line">   1091</span> <span class="nop">           .          .           	// entry is a 00, indicating that there are no more pointers </span>
<span class="line">   1092</span> <span class="nop">           .          .           	// to scan. So only the ptrmask for the ptrdata bytes is needed. </span>
<span class="line">   1093</span> <span class="nop">           .          .           	// </span>
<span class="line">   1094</span> <span class="nop">           .          .           	// Replicated copies are not as nice: if there is an array of </span>
<span class="line">   1095</span> <span class="nop">           .          .           	// objects with scalar tails, all but the last tail does have to </span>
<span class="line">   1096</span> <span class="nop">           .          .           	// be initialized, because there is no way to say "skip forward". </span>
<span class="line">   1097</span> <span class="nop">           .          .           	// However, because of the possibility of a repeated type with </span>
<span class="line">   1098</span> <span class="nop">           .          .           	// size not a multiple of 4 pointers (one heap bitmap byte), </span>
<span class="line">   1099</span> <span class="nop">           .          .           	// the code already must handle the last ptrmask byte specially </span>
<span class="line">   1100</span> <span class="nop">           .          .           	// by treating it as containing only the bits for endnb pointers, </span>
<span class="line">   1101</span> <span class="nop">           .          .           	// where endnb &lt;= 4. We represent large scalar tails that must </span>
<span class="line">   1102</span> <span class="nop">           .          .           	// be expanded in the replication by setting endnb larger than 4. </span>
<span class="line">   1103</span> <span class="nop">           .          .           	// This will have the effect of reading many bits out of b, </span>
<span class="line">   1104</span> <span class="nop">           .          .           	// but once the real bits are shifted out, b will supply as many </span>
<span class="line">   1105</span> <span class="nop">           .          .           	// zero bits as we try to read, which is exactly what we need. </span>
<span class="line">   1106</span> <span class="nop">           .          .            </span>
<span class="line">   1107</span> <span class="nop">           .          .           	p = ptrmask </span>
<span class="line">   1108</span> <span class="nop">           .          .           	if typ.size &lt; dataSize { </span>
<span class="line">   1109</span> <span class="nop">           .          .           		// Filling in bits for an array of typ. </span>
<span class="line">   1110</span> <span class="nop">           .          .           		// Set up for repetition of ptrmask during main loop. </span>
<span class="line">   1111</span> <span class="nop">           .          .           		// Note that ptrmask describes only a prefix of </span>
<span class="line">   1112</span> <span class="nop">           .          .           		const maxBits = sys.PtrSize*8 - 7 </span>
<span class="line">   1113</span> <span class="nop">           .          .           		if typ.ptrdata/sys.PtrSize &lt;= maxBits { </span>
<span class="line">   1114</span> <span class="nop">           .          .           			// Entire ptrmask fits in uintptr with room for a byte fragment. </span>
<span class="line">   1115</span> <span class="nop">           .          .           			// Load into pbits and never read from ptrmask again. </span>
<span class="line">   1116</span> <span class="nop">           .          .           			// This is especially important when the ptrmask has </span>
<span class="line">   1117</span> <span class="nop">           .          .           			// fewer than 8 bits in it; otherwise the reload in the middle </span>
<span class="line">   1118</span> <span class="nop">           .          .           			// of the Phase 2 loop would itself need to loop to gather </span>
<span class="line">   1119</span> <span class="nop">           .          .           			// at least 8 bits. </span>
<span class="line">   1120</span> <span class="nop">           .          .            </span>
<span class="line">   1121</span> <span class="nop">           .          .           			// Accumulate ptrmask into b. </span>
<span class="line">   1122</span> <span class="nop">           .          .           			// ptrmask is sized to describe only typ.ptrdata, but we record </span>
<span class="line">   1123</span> <span class="nop">           .          .           			// it as describing typ.size bytes, since all the high bits are zero. </span>
<span class="line">   1124</span> <span class="nop">           .          .           			nb = typ.ptrdata / sys.PtrSize </span>
<span class="line">   1125</span> <span class="nop">           .          .           			for i := uintptr(0); i &lt; nb; i += 8 { </span>
<span class="line">   1126</span> <span class="nop">           .          .           				b |= uintptr(*p) &lt;&lt; i </span>
<span class="line">   1127</span> <span class="nop">           .          .           				p = add1(p) </span>
<span class="line">   1128</span> <span class="nop">           .          .           			} </span>
<span class="line">   1129</span> <span class="nop">           .          .           			nb = typ.size / sys.PtrSize </span>
<span class="line">   1130</span> <span class="nop">           .          .            </span>
<span class="line">   1131</span> <span class="nop">           .          .           			// Replicate ptrmask to fill entire pbits uintptr. </span>
<span class="line">   1132</span> <span class="nop">           .          .           			// Doubling and truncating is fewer steps than </span>
<span class="line">   1133</span> <span class="nop">           .          .           			// iterating by nb each time. (nb could be 1.) </span>
<span class="line">   1134</span> <span class="nop">           .          .           			// Since we loaded typ.ptrdata/sys.PtrSize bits </span>
<span class="line">   1135</span> <span class="nop">           .          .           			// but are pretending to have typ.size/sys.PtrSize, </span>
<span class="line">   1136</span> <span class="nop">           .          .           			// there might be no replication necessary/possible. </span>
<span class="line">   1137</span> <span class="nop">           .          .           			pbits = b </span>
<span class="line">   1138</span> <span class="nop">           .          .           			endnb = nb </span>
<span class="line">   1139</span> <span class="nop">           .          .           			if nb+nb &lt;= maxBits { </span>
<span class="line">   1140</span> <span class="nop">           .          .           				for endnb &lt;= sys.PtrSize*8 { </span>
<span class="line">   1141</span> <span class="nop">           .          .           					pbits |= pbits &lt;&lt; endnb </span>
<span class="line">   1142</span> <span class="nop">           .          .           					endnb += endnb </span>
<span class="line">   1143</span> <span class="nop">           .          .           				} </span>
<span class="line">   1144</span> <span class="nop">           .          .           				// Truncate to a multiple of original ptrmask. </span>
<span class="line">   1145</span> <span class="nop">           .          .           				// Because nb+nb &lt;= maxBits, nb fits in a byte. </span>
<span class="line">   1146</span> <span class="nop">           .          .           				// Byte division is cheaper than uintptr division. </span>
<span class="line">   1147</span> <span class="nop">           .          .           				endnb = uintptr(maxBits/byte(nb)) * nb </span>
<span class="line">   1148</span> <span class="nop">           .          .           				pbits &amp;= 1&lt;&lt;endnb - 1 </span>
<span class="line">   1149</span> <span class="nop">           .          .           				b = pbits </span>
<span class="line">   1150</span> <span class="nop">           .          .           				nb = endnb </span>
<span class="line">   1151</span> <span class="nop">           .          .           			} </span>
<span class="line">   1152</span> <span class="nop">           .          .            </span>
<span class="line">   1153</span> <span class="nop">           .          .           			// Clear p and endp as sentinel for using pbits. </span>
<span class="line">   1154</span> <span class="nop">           .          .           			// Checked during Phase 2 loop. </span>
<span class="line">   1155</span> <span class="nop">           .          .           			p = nil </span>
<span class="line">   1156</span> <span class="nop">           .          .           			endp = nil </span>
<span class="line">   1157</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   1158</span> <span class="nop">           .          .           			// Ptrmask is larger. Read it multiple times. </span>
<span class="line">   1159</span> <span class="nop">           .          .           			n := (typ.ptrdata/sys.PtrSize+7)/8 - 1 </span>
<span class="line">   1160</span> <span class="nop">           .          .           			endp = addb(ptrmask, n) </span>
<span class="line">   1161</span> <span class="nop">           .          .           			endnb = typ.size/sys.PtrSize - n*8 </span>
<span class="line">   1162</span> <span class="nop">           .          .           		} </span>
<span class="line">   1163</span> <span class="nop">           .          .           	} </span>
<span class="line">   1164</span> <span class="nop">           .          .           	if p != nil { </span>
<span class="line">   1165</span> <span class="nop">           .          .           		b = uintptr(*p) </span>
<span class="line">   1166</span> <span class="nop">           .          .           		p = add1(p) </span>
<span class="line">   1167</span> <span class="nop">           .          .           		nb = 8 </span>
<span class="line">   1168</span> <span class="nop">           .          .           	} </span>
<span class="line">   1169</span> <span class="nop">           .          .            </span>
<span class="line">   1170</span> <span class="nop">           .          .           	if typ.size == dataSize { </span>
<span class="line">   1171</span> <span class="nop">           .          .           		// Single entry: can stop once we reach the non-pointer data. </span>
<span class="line">   1172</span> <span class="nop">           .          .           		nw = typ.ptrdata / sys.PtrSize </span>
<span class="line">   1173</span> <span class="nop">           .          .           	} else { </span>
<span class="line">   1174</span> <span class="nop">           .          .           		// Repeated instances of typ in an array. </span>
<span class="line">   1175</span> <span class="nop">           .          .           		// Have to process first N-1 entries in full, but can stop </span>
<span class="line">   1176</span> <span class="nop">           .          .           		// once we reach the non-pointer data in the final entry. </span>
<span class="line">   1177</span> <span class="nop">           .          .           		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize </span>
<span class="line">   1178</span> <span class="nop">           .          .           	} </span>
<span class="line">   1179</span> <span class="nop">           .          .           	if nw == 0 { </span>
<span class="line">   1180</span> <span class="nop">           .          .           		// No pointers! Caller was supposed to check. </span>
<span class="line">   1181</span> <span class="nop">           .          .           		println("runtime: invalid type ", typ.string()) </span>
<span class="line">   1182</span> <span class="nop">           .          .           		throw("heapBitsSetType: called with non-pointer type") </span>
<span class="line">   1183</span> <span class="nop">           .          .           		return </span>
<span class="line">   1184</span> <span class="nop">           .          .           	} </span>
<span class="line">   1185</span> <span class="nop">           .          .           	if nw &lt; 2 { </span>
<span class="line">   1186</span> <span class="nop">           .          .           		// Must write at least 2 words, because the "no scan" </span>
<span class="line">   1187</span> <span class="nop">           .          .           		// encoding doesn't take effect until the third word. </span>
<span class="line">   1188</span> <span class="nop">           .          .           		nw = 2 </span>
<span class="line">   1189</span> <span class="nop">           .          .           	} </span>
<span class="line">   1190</span> <span class="nop">           .          .            </span>
<span class="line">   1191</span> <span class="nop">           .          .           	// Phase 1: Special case for leading byte (shift==0) or half-byte (shift==2). </span>
<span class="line">   1192</span> <span class="nop">           .          .           	// The leading byte is special because it contains the bits for word 1, </span>
<span class="line">   1193</span> <span class="nop">           .          .           	// which does not have the scan bit set. </span>
<span class="line">   1194</span> <span class="nop">           .          .           	// The leading half-byte is special because it's a half a byte, </span>
<span class="line">   1195</span> <span class="nop">           .          .           	// so we have to be careful with the bits already there. </span>
<span class="line">   1196</span> <span class="nop">           .          .           	switch { </span>
<span class="line">   1197</span> <span class="nop">           .          .           	default: </span>
<span class="line">   1198</span> <span class="nop">           .          .           		throw("heapBitsSetType: unexpected shift") </span>
<span class="line">   1199</span> <span class="nop">           .          .            </span>
<span class="line">   1200</span> <span class="nop">           .          .           	case h.shift == 0: </span>
<span class="line">   1201</span> <span class="nop">           .          .           		// Ptrmask and heap bitmap are aligned. </span>
<span class="line">   1202</span> <span class="nop">           .          .           		// Handle first byte of bitmap specially. </span>
<span class="line">   1203</span> <span class="nop">           .          .           		// </span>
<span class="line">   1204</span> <span class="nop">           .          .           		// The first byte we write out covers the first four </span>
<span class="line">   1205</span> <span class="nop">           .          .           		// words of the object. The scan/dead bit on the first </span>
<span class="line">   1206</span> <span class="nop">           .          .           		// word must be set to scan since there are pointers </span>
<span class="line">   1207</span> <span class="nop">           .          .           		// somewhere in the object. The scan/dead bit on the </span>
<span class="line">   1208</span> <span class="nop">           .          .           		// second word is the checkmark, so we don't set it. </span>
<span class="line">   1209</span> <span class="nop">           .          .           		// In all following words, we set the scan/dead </span>
<span class="line">   1210</span> <span class="nop">           .          .           		// appropriately to indicate that the object contains </span>
<span class="line">   1211</span> <span class="nop">           .          .           		// to the next 2-bit entry in the bitmap. </span>
<span class="line">   1212</span> <span class="nop">           .          .           		// </span>
<span class="line">   1213</span> <span class="nop">           .          .           		// TODO: It doesn't matter if we set the checkmark, so </span>
<span class="line">   1214</span> <span class="nop">           .          .           		// maybe this case isn't needed any more. </span>
<span class="line">   1215</span> <span class="nop">           .          .           		hb = b &amp; bitPointerAll </span>
<span class="line">   1216</span> <span class="nop">           .          .           		hb |= bitScan | bitScan&lt;&lt;(2*heapBitsShift) | bitScan&lt;&lt;(3*heapBitsShift) </span>
<span class="line">   1217</span> <span class="nop">           .          .           		if w += 4; w &gt;= nw { </span>
<span class="line">   1218</span> <span class="nop">           .          .           			goto Phase3 </span>
<span class="line">   1219</span> <span class="nop">           .          .           		} </span>
<span class="line">   1220</span> <span class="nop">           .          .           		*hbitp = uint8(hb) </span>
<span class="line">   1221</span> <span class="nop">           .          .           		hbitp = add1(hbitp) </span>
<span class="line">   1222</span> <span class="nop">           .          .           		b &gt;&gt;= 4 </span>
<span class="line">   1223</span> <span class="nop">           .          .           		nb -= 4 </span>
<span class="line">   1224</span> <span class="nop">           .          .            </span>
<span class="line">   1225</span> <span class="nop">           .          .           	case sys.PtrSize == 8 &amp;&amp; h.shift == 2: </span>
<span class="line">   1226</span> <span class="nop">           .          .           		// Ptrmask and heap bitmap are misaligned. </span>
<span class="line">   1227</span> <span class="nop">           .          .           		// The bits for the first two words are in a byte shared </span>
<span class="line">   1228</span> <span class="nop">           .          .           		// with another object, so we must be careful with the bits </span>
<span class="line">   1229</span> <span class="nop">           .          .           		// already there. </span>
<span class="line">   1230</span> <span class="nop">           .          .           		// We took care of 1-word and 2-word objects above, </span>
<span class="line">   1231</span> <span class="nop">           .          .           		// so this is at least a 6-word object. </span>
<span class="line">   1232</span> <span class="nop">           .          .           		hb = (b &amp; (bitPointer | bitPointer&lt;&lt;heapBitsShift)) &lt;&lt; (2 * heapBitsShift) </span>
<span class="line">   1233</span> <span class="nop">           .          .           		// This is not noscan, so set the scan bit in the </span>
<span class="line">   1234</span> <span class="nop">           .          .           		// first word. </span>
<span class="line">   1235</span> <span class="nop">           .          .           		hb |= bitScan &lt;&lt; (2 * heapBitsShift) </span>
<span class="line">   1236</span> <span class="nop">           .          .           		b &gt;&gt;= 2 </span>
<span class="line">   1237</span> <span class="nop">           .          .           		nb -= 2 </span>
<span class="line">   1238</span> <span class="nop">           .          .           		// Note: no bitScan for second word because that's </span>
<span class="line">   1239</span> <span class="nop">           .          .           		// the checkmark. </span>
<span class="line">   1240</span> <span class="nop">           .          .           		*hbitp &amp;^= uint8((bitPointer | bitScan | (bitPointer &lt;&lt; heapBitsShift)) &lt;&lt; (2 * heapBitsShift)) </span>
<span class="line">   1241</span> <span class="nop">           .          .           		*hbitp |= uint8(hb) </span>
<span class="line">   1242</span> <span class="nop">        10ms       10ms           		hbitp = add1(hbitp) </span>
<span class="line">   1243</span> <span class="nop">           .          .           		if w += 2; w &gt;= nw { </span>
<span class="line">   1244</span> <span class="nop">           .          .           			// We know that there is more data, because we handled 2-word objects above. </span>
<span class="line">   1245</span> <span class="nop">           .          .           			// This must be at least a 6-word object. If we're out of pointer words, </span>
<span class="line">   1246</span> <span class="nop">           .          .           			// mark no scan in next bitmap byte and finish. </span>
<span class="line">   1247</span> <span class="nop">           .          .           			hb = 0 </span>
<span class="line">   1248</span> <span class="nop">           .          .           			w += 4 </span>
<span class="line">   1249</span> <span class="nop">           .          .           			goto Phase3 </span>
<span class="line">   1250</span> <span class="nop">           .          .           		} </span>
<span class="line">   1251</span> <span class="nop">           .          .           	} </span>
<span class="line">   1252</span> <span class="nop">           .          .            </span>
<span class="line">   1253</span> <span class="nop">           .          .           	// Phase 2: Full bytes in bitmap, up to but not including write to last byte (full or partial) in bitmap. </span>
<span class="line">   1254</span> <span class="nop">           .          .           	// The loop computes the bits for that last write but does not execute the write; </span>
<span class="line">   1255</span> <span class="nop">           .          .           	// it leaves the bits in hb for processing by phase 3. </span>
<span class="line">   1256</span> <span class="nop">           .          .           	// To avoid repeated adjustment of nb, we subtract out the 4 bits we're going to </span>
<span class="line">   1257</span> <span class="nop">           .          .           	// use in the first half of the loop right now, and then we only adjust nb explicitly </span>
<span class="line">   1258</span> <span class="nop">           .          .           	// if the 8 bits used by each iteration isn't balanced by 8 bits loaded mid-loop. </span>
<span class="line">   1259</span> <span class="nop">           .          .           	nb -= 4 </span>
<span class="line">   1260</span> <span class="nop">           .          .           	for { </span>
<span class="line">   1261</span> <span class="nop">           .          .           		// Emit bitmap byte. </span>
<span class="line">   1262</span> <span class="nop">           .          .           		// b has at least nb+4 bits, with one exception: </span>
<span class="line">   1263</span> <span class="nop">           .          .           		// if w+4 &gt;= nw, then b has only nw-w bits, </span>
<span class="line">   1264</span> <span class="nop">           .          .           		// but we'll stop at the break and then truncate </span>
<span class="line">   1265</span> <span class="nop">           .          .           		// appropriately in Phase 3. </span>
<span class="line">   1266</span> <span class="nop">           .          .           		hb = b &amp; bitPointerAll </span>
<span class="line">   1267</span> <span class="nop">           .          .           		hb |= bitScanAll </span>
<span class="line">   1268</span> <span class="nop">           .          .           		if w += 4; w &gt;= nw { </span>
<span class="line">   1269</span> <span class="nop">           .          .           			break </span>
<span class="line">   1270</span> <span class="nop">           .          .           		} </span>
<span class="line">   1271</span> <span class="nop">           .          .           		*hbitp = uint8(hb) </span>
<span class="line">   1272</span> <span class="nop">           .          .           		hbitp = add1(hbitp) </span>
<span class="line">   1273</span> <span class="nop">           .          .           		b &gt;&gt;= 4 </span>
<span class="line">   1274</span> <span class="nop">           .          .            </span>
<span class="line">   1275</span> <span class="nop">           .          .           		// Load more bits. b has nb right now. </span>
<span class="line">   1276</span> <span class="nop">           .          .           		if p != endp { </span>
<span class="line">   1277</span> <span class="nop">           .          .           			// Fast path: keep reading from ptrmask. </span>
<span class="line">   1278</span> <span class="nop">           .          .           			// nb unmodified: we just loaded 8 bits, </span>
<span class="line">   1279</span> <span class="nop">           .          .           			// and the next iteration will consume 8 bits, </span>
<span class="line">   1280</span> <span class="nop">           .          .           			// leaving us with the same nb the next time we're here. </span>
<span class="line">   1281</span> <span class="nop">           .          .           			if nb &lt; 8 { </span>
<span class="line">   1282</span> <span class="nop">           .          .           				b |= uintptr(*p) &lt;&lt; nb </span>
<span class="line">   1283</span> <span class="nop">           .          .           				p = add1(p) </span>
<span class="line">   1284</span> <span class="nop">           .          .           			} else { </span>
<span class="line">   1285</span> <span class="nop">           .          .           				// Reduce the number of bits in b. </span>
<span class="line">   1286</span> <span class="nop">           .          .           				// This is important if we skipped </span>
<span class="line">   1287</span> <span class="nop">           .          .           				// over a scalar tail, since nb could </span>
<span class="line">   1288</span> <span class="nop">           .          .           				// be larger than the bit width of b. </span>
<span class="line">   1289</span> <span class="nop">           .          .           				nb -= 8 </span>
<span class="line">   1290</span> <span class="nop">           .          .           			} </span>
<span class="line">   1291</span> <span class="nop">           .          .           		} else if p == nil { </span>
<span class="line">   1292</span> <span class="nop">           .          .           			// Almost as fast path: track bit count and refill from pbits. </span>
<span class="line">   1293</span> <span class="nop">           .          .           			// For short repetitions. </span>
<span class="line">   1294</span> <span class="nop">           .          .           			if nb &lt; 8 { </span>
<span class="line">   1295</span> <span class="nop">           .          .           				b |= pbits &lt;&lt; nb </span>
<span class="line">   1296</span> <span class="nop">           .          .           				nb += endnb </span>
<span class="line">   1297</span> <span class="nop">           .          .           			} </span>
<span class="line">   1298</span> <span class="nop">           .          .           			nb -= 8 // for next iteration </span>
<span class="line">   1299</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   1300</span> <span class="nop">           .          .           			// Slow path: reached end of ptrmask. </span>
<span class="line">   1301</span> <span class="nop">           .          .           			// Process final partial byte and rewind to start. </span>
<span class="line">   1302</span> <span class="nop">           .          .           			b |= uintptr(*p) &lt;&lt; nb </span>
<span class="line">   1303</span> <span class="nop">           .          .           			nb += endnb </span>
<span class="line">   1304</span> <span class="nop">           .          .           			if nb &lt; 8 { </span>
<span class="line">   1305</span> <span class="nop">           .          .           				b |= uintptr(*ptrmask) &lt;&lt; nb </span>
<span class="line">   1306</span> <span class="nop">           .          .           				p = add1(ptrmask) </span>
<span class="line">   1307</span> <span class="nop">           .          .           			} else { </span>
<span class="line">   1308</span> <span class="nop">           .          .           				nb -= 8 </span>
<span class="line">   1309</span> <span class="nop">           .          .           				p = ptrmask </span>
<span class="line">   1310</span> <span class="nop">           .          .           			} </span>
<span class="line">   1311</span> <span class="nop">           .          .           		} </span>
<span class="line">   1312</span> <span class="nop">           .          .            </span>
<span class="line">   1313</span> <span class="nop">           .          .           		// Emit bitmap byte. </span>
<span class="line">   1314</span> <span class="nop">           .          .           		hb = b &amp; bitPointerAll </span>
<span class="line">   1315</span> <span class="nop">           .          .           		hb |= bitScanAll </span>
<span class="line">   1316</span> <span class="nop">           .          .           		if w += 4; w &gt;= nw { </span>
<span class="line">   1317</span> <span class="nop">           .          .           			break </span>
<span class="line">   1318</span> <span class="nop">           .          .           		} </span>
<span class="line">   1319</span> <span class="nop">           .          .           		*hbitp = uint8(hb) </span>
<span class="line">   1320</span> <span class="nop">           .          .           		hbitp = add1(hbitp) </span>
<span class="line">   1321</span> <span class="nop">           .          .           		b &gt;&gt;= 4 </span>
<span class="line">   1322</span> <span class="nop">           .          .           	} </span>
<span class="line">   1323</span> <span class="nop">           .          .            </span>
<span class="line">   1324</span> <span class="nop">           .          .           Phase3: </span>
<span class="line">   1325</span> <span class="nop">           .          .           	// Phase 3: Write last byte or partial byte and zero the rest of the bitmap entries. </span>
<span class="line">   1326</span> <span class="nop">           .          .           	if w &gt; nw { </span>
<span class="line">   1327</span> <span class="nop">           .          .           		// Counting the 4 entries in hb not yet written to memory, </span>
<span class="line">   1328</span> <span class="nop">           .          .           		// there are more entries than possible pointer slots. </span>
<span class="line">   1329</span> <span class="nop">           .          .           		// Discard the excess entries (can't be more than 3). </span>
<span class="line">   1330</span> <span class="nop">           .          .           		mask := uintptr(1)&lt;&lt;(4-(w-nw)) - 1 </span>
<span class="line">   1331</span> <span class="nop">           .          .           		hb &amp;= mask | mask&lt;&lt;4 // apply mask to both pointer bits and scan bits </span>
<span class="line">   1332</span> <span class="nop">           .          .           	} </span>
<span class="line">   1333</span> <span class="nop">           .          .            </span>
<span class="line">   1334</span> <span class="nop">           .          .           	// Change nw from counting possibly-pointer words to total words in allocation. </span>
<span class="line">   1335</span> <span class="nop">           .          .           	nw = size / sys.PtrSize </span>
<span class="line">   1336</span> <span class="nop">           .          .            </span>
<span class="line">   1337</span> <span class="nop">           .          .           	// Write whole bitmap bytes. </span>
<span class="line">   1338</span> <span class="nop">           .          .           	// The first is hb, the rest are zero. </span>
<span class="line">   1339</span> <span class="nop">           .          .           	if w &lt;= nw { </span>
<span class="line">   1340</span> <span class="nop">           .          .           		*hbitp = uint8(hb) </span>
<span class="line">   1341</span> <span class="nop">           .          .           		hbitp = add1(hbitp) </span>
<span class="line">   1342</span> <span class="nop">           .          .           		hb = 0 // for possible final half-byte below </span>
<span class="line">   1343</span> <span class="nop">           .          .           		for w += 4; w &lt;= nw; w += 4 { </span>
<span class="line">   1344</span> <span class="nop">           .          .           			*hbitp = 0 </span>
<span class="line">   1345</span> <span class="nop">           .          .           			hbitp = add1(hbitp) </span>
<span class="line">   1346</span> <span class="nop">           .          .           		} </span>
<span class="line">   1347</span> <span class="nop">           .          .           	} </span>
<span class="line">   1348</span> <span class="nop">           .          .            </span>
<span class="line">   1349</span> <span class="nop">           .          .           	// Write final partial bitmap byte if any. </span>
<span class="line">   1350</span> <span class="nop">           .          .           	// We know w &gt; nw, or else we'd still be in the loop above. </span>
<span class="line">   1351</span> <span class="nop">           .          .           	// It can be bigger only due to the 4 entries in hb that it counts. </span>
<span class="line">   1352</span> <span class="nop">           .          .           	// If w == nw+4 then there's nothing left to do: we wrote all nw entries </span>
<span class="line">   1353</span> <span class="nop">           .          .           	// and can discard the 4 sitting in hb. </span>
<span class="line">   1354</span> <span class="nop">           .          .           	// But if w == nw+2, we need to write first two in hb. </span>
<span class="line">   1355</span> <span class="nop">           .          .           	// The byte is shared with the next object, so be careful with </span>
<span class="line">   1356</span> <span class="nop">           .          .           	// existing bits. </span>
<span class="line">   1357</span> <span class="nop">        10ms       10ms           	if w == nw+2 { </span>
<span class="line">   1358</span> <span class="nop">           .          .           		*hbitp = *hbitp&amp;^(bitPointer|bitScan|(bitPointer|bitScan)&lt;&lt;heapBitsShift) | uint8(hb) </span>
<span class="line">   1359</span> <span class="nop">           .          .           	} </span>
<span class="line">   1360</span> <span class="nop">           .          .            </span>
<span class="line">   1361</span> <span class="nop">           .          .           Phase4: </span>
<span class="line">   1362</span> <span class="nop">           .          .           	// Phase 4: Copy unrolled bitmap to per-arena bitmaps, if necessary. </span>
</pre>
<h2>runtime.scanframeworker</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mgcmark.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms      440ms (flat, cum)  3.52%
<span class="line">    789</span> <span class="nop">           .          .           func scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork) { </span>
<span class="line">    790</span> <span class="nop">           .          .           	if _DebugGC &gt; 1 &amp;&amp; frame.continpc != 0 { </span>
<span class="line">    791</span> <span class="nop">           .          .           		print("scanframe ", funcname(frame.fn), "\n") </span>
<span class="line">    792</span> <span class="nop">           .          .           	} </span>
<span class="line">    793</span> <span class="nop">           .          .            </span>
<span class="line">    794</span> <span class="nop">        10ms      310ms           	locals, args, objs := getStackMap(frame, &amp;state.cache, false) </span>
<span class="line">    795</span> <span class="nop">           .          .            </span>
<span class="line">    796</span> <span class="nop">           .          .           	// Scan local variables if stack frame has been allocated. </span>
<span class="line">    797</span> <span class="nop">           .          .           	if locals.n &gt; 0 { </span>
<span class="line">    798</span> <span class="nop">           .          .           		size := uintptr(locals.n) * sys.PtrSize </span>
<span class="line">    799</span> <span class="nop">        10ms       70ms           		scanblock(frame.varp-size, size, locals.bytedata, gcw, state) </span>
<span class="line">    800</span> <span class="nop">           .          .           	} </span>
<span class="line">    801</span> <span class="nop">           .          .            </span>
<span class="line">    802</span> <span class="nop">           .          .           	// Scan arguments. </span>
<span class="line">    803</span> <span class="nop">           .          .           	if args.n &gt; 0 { </span>
<span class="line">    804</span> <span class="nop">           .       40ms           		scanblock(frame.argp, uintptr(args.n)*sys.PtrSize, args.bytedata, gcw, state) </span>
<span class="line">    805</span> <span class="nop">           .          .           	} </span>
<span class="line">    806</span> <span class="nop">           .          .            </span>
<span class="line">    807</span> <span class="nop">           .          .           	// Add all stack objects to the stack object list. </span>
<span class="line">    808</span> <span class="nop">        10ms       10ms           	if frame.varp != 0 { </span>
<span class="line">    809</span> <span class="nop">           .          .           		// varp is 0 for defers, where there are no locals. </span>
<span class="line">    810</span> <span class="nop">           .          .           		// In that case, there can't be a pointer to its args, either. </span>
<span class="line">    811</span> <span class="nop">           .          .           		// (And all args would be scanned above anyway.) </span>
<span class="line">    812</span> <span class="nop">        10ms       10ms           		for _, obj := range objs { </span>
<span class="line">    813</span> <span class="nop">           .          .           			off := obj.off </span>
<span class="line">    814</span> <span class="nop">           .          .           			base := frame.varp // locals base pointer </span>
<span class="line">    815</span> <span class="nop">           .          .           			if off &gt;= 0 { </span>
<span class="line">    816</span> <span class="nop">           .          .           				base = frame.argp // arguments and return values base pointer </span>
<span class="line">    817</span> <span class="nop">           .          .           			} </span>
</pre>
<h2>runtime.findfunc</h2><p class="filename">C:\blockchainenv\Go\src\runtime\symtab.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms       40ms (flat, cum)  0.32%
<span class="line">    565</span> <span class="nop">           .          .           	x := pc - datap.minpc </span>
<span class="line">    566</span> <span class="nop">           .          .           	b := x / pcbucketsize </span>
<span class="line">    567</span> <span class="nop">           .          .           	i := x % pcbucketsize / (pcbucketsize / nsub) </span>
<span class="line">    568</span> <span class="nop">           .          .            </span>
<span class="line">    569</span> <span class="nop">           .          .           	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{}))) </span>
<span class="line">    570</span> <span class="nop">        10ms       10ms           	idx := ffb.idx + uint32(ffb.subbuckets[i]) </span>
<span class="line">    571</span> <span class="nop">           .          .            </span>
<span class="line">    572</span> <span class="nop">           .          .           	// If the idx is beyond the end of the ftab, set it to the end of the table and search backward. </span>
<span class="line">    573</span> <span class="nop">           .          .           	// This situation can occur if multiple text sections are generated to handle large text sections </span>
<span class="line">    574</span> <span class="nop">           .          .           	// and the linker has inserted jump tables between them. </span>
<span class="line">    575</span> <span class="nop">           .          .            </span>
<span class="line">    576</span> <span class="nop">           .          .           	if idx &gt;= uint32(len(datap.ftab)) { </span>
<span class="line">    577</span> <span class="nop">           .          .           		idx = uint32(len(datap.ftab) - 1) </span>
<span class="line">    578</span> <span class="nop">           .          .           	} </span>
<span class="line">    579</span> <span class="nop">        10ms       10ms           	if pc &lt; datap.ftab[idx].entry { </span>
<span class="line">    580</span> <span class="nop">           .          .           		// With multiple text sections, the idx might reference a function address that </span>
<span class="line">    581</span> <span class="nop">           .          .           		// is higher than the pc being searched, so search backward until the matching address is found. </span>
<span class="line">    582</span> <span class="nop">           .          .            </span>
<span class="line">    583</span> <span class="nop">           .          .           		for datap.ftab[idx].entry &gt; pc &amp;&amp; idx &gt; 0 { </span>
<span class="line">    584</span> <span class="nop">           .          .           			idx-- </span>
<span class="line">    585</span> <span class="nop">           .          .           		} </span>
<span class="line">    586</span> <span class="nop">           .          .           		if idx == 0 { </span>
<span class="line">    587</span> <span class="nop">           .          .           			throw("findfunc: bad findfunctab entry idx") </span>
<span class="line">    588</span> <span class="nop">           .          .           		} </span>
<span class="line">    589</span> <span class="nop">           .          .           	} else { </span>
<span class="line">    590</span> <span class="nop">           .          .           		// linear search to find func with pc &gt;= entry. </span>
<span class="line">    591</span> <span class="nop">           .          .           		for datap.ftab[idx+1].entry &lt;= pc { </span>
<span class="line">    592</span> <span class="nop">           .          .           			idx++ </span>
<span class="line">    593</span> <span class="nop">           .          .           		} </span>
<span class="line">    594</span> <span class="nop">           .          .           	} </span>
<span class="line">    595</span> <span class="nop">        20ms       20ms           	return funcInfo{(*_func)(unsafe.Pointer(&amp;datap.pclntable[datap.ftab[idx].funcoff])), datap} </span>
<span class="line">    596</span> <span class="nop">           .          .           } </span>
<span class="line">    597</span> <span class="nop">           .          .            </span>
<span class="line">    598</span> <span class="nop">           .          .           type pcvalueCache struct { </span>
<span class="line">    599</span> <span class="nop">           .          .           	entries [2][8]pcvalueCacheEnt </span>
<span class="line">    600</span> <span class="nop">           .          .           } </span>
</pre>
<h2>runtime.jmpdefer</h2><p class="filename">C:\blockchainenv\Go\src\runtime\asm_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms       40ms (flat, cum)  0.32%
<span class="line">    568</span> <span class="nop">           .          .           	MOVQ	argp+8(FP), BX	// caller sp </span>
<span class="line">    569</span> <span class="nop">           .          .           	LEAQ	-8(BX), SP	// caller sp after CALL </span>
<span class="line">    570</span> <span class="nop">           .          .           	MOVQ	-8(SP), BP	// restore BP as if deferreturn returned (harmless if framepointers not in use) </span>
<span class="line">    571</span> <span class="nop">           .          .           	SUBQ	$5, (SP)	// return to CALL again </span>
<span class="line">    572</span> <span class="nop">           .          .           	MOVQ	0(DX), BX </span>
<span class="line">    573</span> <span class="nop">        40ms       40ms           	JMP	BX	// but first run the deferred function </span>
<span class="line">    574</span> <span class="nop">           .          .            </span>
<span class="line">    575</span> <span class="nop">           .          .           // Save state of caller into g-&gt;sched. Smashes R8, R9. </span>
<span class="line">    576</span> <span class="nop">           .          .           TEXT gosave&lt;&gt;(SB),NOSPLIT,$0 </span>
<span class="line">    577</span> <span class="nop">           .          .           	get_tls(R8) </span>
<span class="line">    578</span> <span class="nop">           .          .           	MOVQ	g(R8), R8 </span>
</pre>
<h2>vendor/golang.org/x/text/transform.(*Reader).Read</h2><p class="filename">C:\blockchainenv\githubProj\go-crawler\src\vendor\golang.org\x\text\transform\transform.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms      2.03s (flat, cum) 16.23%
<span class="line">    105</span> <span class="nop">           .          .           // Read implements the io.Reader interface. </span>
<span class="line">    106</span> <span class="nop">           .          .           func (r *Reader) Read(p []byte) (int, error) { </span>
<span class="line">    107</span> <span class="nop">           .          .           	n, err := 0, error(nil) </span>
<span class="line">    108</span> <span class="nop">           .          .           	for { </span>
<span class="line">    109</span> <span class="nop">           .          .           		// Copy out any transformed bytes and return the final error if we are done. </span>
<span class="line">    110</span> <span class="nop">        10ms       10ms           		if r.dst0 != r.dst1 { </span>
<span class="line">    111</span> <span class="nop">        10ms       10ms           			n = copy(p, r.dst[r.dst0:r.dst1]) </span>
<span class="line">    112</span> <span class="nop">           .          .           			r.dst0 += n </span>
<span class="line">    113</span> <span class="nop">           .          .           			if r.dst0 == r.dst1 &amp;&amp; r.transformComplete { </span>
<span class="line">    114</span> <span class="nop">           .          .           				return n, r.err </span>
<span class="line">    115</span> <span class="nop">           .          .           			} </span>
<span class="line">    116</span> <span class="nop">           .          .           			return n, nil </span>
<span class="line">    117</span> <span class="nop">           .          .           		} else if r.transformComplete { </span>
<span class="line">    118</span> <span class="nop">           .          .           			return 0, r.err </span>
<span class="line">    119</span> <span class="nop">           .          .           		} </span>
<span class="line">    120</span> <span class="nop">           .          .            </span>
<span class="line">    121</span> <span class="nop">           .          .           		// Try to transform some source bytes, or to flush the transformer if we </span>
<span class="line">    122</span> <span class="nop">           .          .           		// are out of source bytes. We do this even if r.r.Read returned an error. </span>
<span class="line">    123</span> <span class="nop">           .          .           		// As the io.Reader documentation says, "process the n &gt; 0 bytes returned </span>
<span class="line">    124</span> <span class="nop">           .          .           		// before considering the error". </span>
<span class="line">    125</span> <span class="nop">           .          .           		if r.src0 != r.src1 || r.err != nil { </span>
<span class="line">    126</span> <span class="nop">           .          .           			r.dst0 = 0 </span>
<span class="line">    127</span> <span class="nop">        20ms      520ms           			r.dst1, n, err = r.t.Transform(r.dst, r.src[r.src0:r.src1], r.err == io.EOF) </span>
<span class="line">    128</span> <span class="nop">           .          .           			r.src0 += n </span>
<span class="line">    129</span> <span class="nop">           .          .            </span>
<span class="line">    130</span> <span class="nop">           .          .           			switch { </span>
<span class="line">    131</span> <span class="nop">           .          .           			case err == nil: </span>
<span class="line">    132</span> <span class="nop">           .          .           				if r.src0 != r.src1 { </span>
<span class="line">    133</span> <span class="nop">           .          .           					r.err = errInconsistentByteCount </span>
<span class="line">    134</span> <span class="nop">           .          .           				} </span>
<span class="line">    135</span> <span class="nop">           .          .           				// The Transform call was successful; we are complete if we </span>
<span class="line">    136</span> <span class="nop">           .          .           				// cannot read more bytes into src. </span>
<span class="line">    137</span> <span class="nop">           .          .           				r.transformComplete = r.err != nil </span>
<span class="line">    138</span> <span class="nop">           .          .           				continue </span>
<span class="line">    139</span> <span class="nop">           .          .           			case err == ErrShortDst &amp;&amp; (r.dst1 != 0 || n != 0): </span>
<span class="line">    140</span> <span class="nop">           .          .           				// Make room in dst by copying out, and try again. </span>
<span class="line">    141</span> <span class="nop">           .          .           				continue </span>
<span class="line">    142</span> <span class="nop">           .          .           			case err == ErrShortSrc &amp;&amp; r.src1-r.src0 != len(r.src) &amp;&amp; r.err == nil: </span>
<span class="line">    143</span> <span class="nop">           .          .           				// Read more bytes into src via the code below, and try again. </span>
<span class="line">    144</span> <span class="nop">           .          .           			default: </span>
<span class="line">    145</span> <span class="nop">           .          .           				r.transformComplete = true </span>
<span class="line">    146</span> <span class="nop">           .          .           				// The reader error (r.err) takes precedence over the </span>
<span class="line">    147</span> <span class="nop">           .          .           				// transformer error (err) unless r.err is nil or io.EOF. </span>
<span class="line">    148</span> <span class="nop">           .          .           				if r.err == nil || r.err == io.EOF { </span>
<span class="line">    149</span> <span class="nop">           .          .           					r.err = err </span>
<span class="line">    150</span> <span class="nop">           .          .           				} </span>
<span class="line">    151</span> <span class="nop">           .          .           				continue </span>
<span class="line">    152</span> <span class="nop">           .          .           			} </span>
<span class="line">    153</span> <span class="nop">           .          .           		} </span>
<span class="line">    154</span> <span class="nop">           .          .            </span>
<span class="line">    155</span> <span class="nop">           .          .           		// Move any untransformed source bytes to the start of the buffer </span>
<span class="line">    156</span> <span class="nop">           .          .           		// and read more bytes. </span>
<span class="line">    157</span> <span class="nop">           .          .           		if r.src0 != 0 { </span>
<span class="line">    158</span> <span class="nop">           .          .           			r.src0, r.src1 = 0, copy(r.src, r.src[r.src0:r.src1]) </span>
<span class="line">    159</span> <span class="nop">           .          .           		} </span>
<span class="line">    160</span> <span class="nop">           .      1.49s           		n, r.err = r.r.Read(r.src[r.src1:]) </span>
<span class="line">    161</span> <span class="nop">           .          .           		r.src1 += n </span>
<span class="line">    162</span> <span class="nop">           .          .           	} </span>
<span class="line">    163</span> <span class="nop">           .          .           } </span>
<span class="line">    164</span> <span class="nop">           .          .            </span>
<span class="line">    165</span> <span class="nop">           .          .           // TODO: implement ReadByte (and ReadRune??). </span>
</pre>
<h2>regexp.(*machine).match</h2><p class="filename">C:\blockchainenv\Go\src\regexp\exec.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        40ms      720ms (flat, cum)  5.76%
<span class="line">    204</span> <span class="nop">           .          .           				// Have match; finished exploring alternatives. </span>
<span class="line">    205</span> <span class="nop">           .          .           				break </span>
<span class="line">    206</span> <span class="nop">           .          .           			} </span>
<span class="line">    207</span> <span class="nop">           .          .           			if len(m.re.prefix) &gt; 0 &amp;&amp; r1 != m.re.prefixRune &amp;&amp; i.canCheckPrefix() { </span>
<span class="line">    208</span> <span class="nop">           .          .           				// Match requires literal prefix; fast search for it. </span>
<span class="line">    209</span> <span class="nop">           .      170ms           				advance := i.index(m.re, pos) </span>
<span class="line">    210</span> <span class="nop">           .          .           				if advance &lt; 0 { </span>
<span class="line">    211</span> <span class="nop">           .          .           					break </span>
<span class="line">    212</span> <span class="nop">           .          .           				} </span>
<span class="line">    213</span> <span class="nop">           .          .           				pos += advance </span>
<span class="line">    214</span> <span class="nop">           .          .           				r, width = i.step(pos) </span>
<span class="line">    215</span> <span class="nop">           .          .           				r1, width1 = i.step(pos + width) </span>
<span class="line">    216</span> <span class="nop">           .          .           			} </span>
<span class="line">    217</span> <span class="nop">           .          .           		} </span>
<span class="line">    218</span> <span class="nop">           .          .           		if !m.matched { </span>
<span class="line">    219</span> <span class="nop">           .          .           			if len(m.matchcap) &gt; 0 { </span>
<span class="line">    220</span> <span class="nop">           .          .           				m.matchcap[0] = pos </span>
<span class="line">    221</span> <span class="nop">           .          .           			} </span>
<span class="line">    222</span> <span class="nop">        10ms      150ms           			m.add(runq, uint32(m.p.Start), pos, m.matchcap, &amp;flag, nil) </span>
<span class="line">    223</span> <span class="nop">           .          .           		} </span>
<span class="line">    224</span> <span class="nop">           .          .           		flag = newLazyFlag(r, r1) </span>
<span class="line">    225</span> <span class="nop">        20ms      360ms           		m.step(runq, nextq, pos, pos+width, r, &amp;flag) </span>
<span class="line">    226</span> <span class="nop">           .          .           		if width == 0 { </span>
<span class="line">    227</span> <span class="nop">           .          .           			break </span>
<span class="line">    228</span> <span class="nop">           .          .           		} </span>
<span class="line">    229</span> <span class="nop">           .          .           		if len(m.matchcap) == 0 &amp;&amp; m.matched { </span>
<span class="line">    230</span> <span class="nop">           .          .           			// Found a match and not paying attention </span>
<span class="line">    231</span> <span class="nop">           .          .           			// to where it is, so any match will do. </span>
<span class="line">    232</span> <span class="nop">           .          .           			break </span>
<span class="line">    233</span> <span class="nop">           .          .           		} </span>
<span class="line">    234</span> <span class="nop">           .          .           		pos += width </span>
<span class="line">    235</span> <span class="nop">           .          .           		r, width = r1, width1 </span>
<span class="line">    236</span> <span class="nop">           .          .           		if r != endOfText { </span>
<span class="line">    237</span> <span class="nop">        10ms       40ms           			r1, width1 = i.step(pos + width) </span>
<span class="line">    238</span> <span class="nop">           .          .           		} </span>
<span class="line">    239</span> <span class="nop">           .          .           		runq, nextq = nextq, runq </span>
<span class="line">    240</span> <span class="nop">           .          .           	} </span>
<span class="line">    241</span> <span class="nop">           .          .           	m.clear(nextq) </span>
<span class="line">    242</span> <span class="nop">           .          .           	return m.matched </span>
</pre>
<h2>runtime.nextFreeFast</h2><p class="filename">C:\blockchainenv\Go\src\runtime\malloc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">    745</span> <span class="nop">           .          .           var zerobase uintptr </span>
<span class="line">    746</span> <span class="nop">           .          .            </span>
<span class="line">    747</span> <span class="nop">           .          .           // nextFreeFast returns the next free object if one is quickly available. </span>
<span class="line">    748</span> <span class="nop">           .          .           // Otherwise it returns 0. </span>
<span class="line">    749</span> <span class="nop">           .          .           func nextFreeFast(s *mspan) gclinkptr { </span>
<span class="line">    750</span> <span class="nop">        30ms       30ms           	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache? </span>
<span class="line">    751</span> <span class="nop">           .          .           	if theBit &lt; 64 { </span>
<span class="line">    752</span> <span class="nop">           .          .           		result := s.freeindex + uintptr(theBit) </span>
<span class="line">    753</span> <span class="nop">           .          .           		if result &lt; s.nelems { </span>
<span class="line">    754</span> <span class="nop">           .          .           			freeidx := result + 1 </span>
<span class="line">    755</span> <span class="nop">           .          .           			if freeidx%64 == 0 &amp;&amp; freeidx != s.nelems { </span>
</pre>
<h2>runtime.mapaccess1_faststr</h2><p class="filename">C:\blockchainenv\Go\src\runtime\map_faststr.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">     12</span> <span class="nop">           .          .           func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer { </span>
<span class="line">     13</span> <span class="nop">           .          .           	if raceenabled &amp;&amp; h != nil { </span>
<span class="line">     14</span> <span class="nop">           .          .           		callerpc := getcallerpc() </span>
<span class="line">     15</span> <span class="nop">           .          .           		racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess1_faststr)) </span>
<span class="line">     16</span> <span class="nop">           .          .           	} </span>
<span class="line">     17</span> <span class="nop">        10ms       10ms           	if h == nil || h.count == 0 { </span>
<span class="line">     18</span> <span class="nop">           .          .           		return unsafe.Pointer(&amp;zeroVal[0]) </span>
<span class="line">     19</span> <span class="nop">           .          .           	} </span>
<span class="line">     20</span> <span class="nop">           .          .           	if h.flags&amp;hashWriting != 0 { </span>
<span class="line">     21</span> <span class="nop">           .          .           		throw("concurrent map read and map write") </span>
<span class="line">     22</span> <span class="nop">           .          .           	} </span>
<span class="line">     23</span> <span class="nop">           .          .           	key := stringStructOf(&amp;ky) </span>
<span class="line">     24</span> <span class="nop">           .          .           	if h.B == 0 { </span>
<span class="line">     25</span> <span class="nop">           .          .           		// One-bucket table. </span>
<span class="line">     26</span> <span class="nop">           .          .           		b := (*bmap)(h.buckets) </span>
<span class="line">     27</span> <span class="nop">           .          .           		if key.len &lt; 32 { </span>
<span class="line">     28</span> <span class="nop">           .          .           			// short key, doing lots of comparisons is ok </span>
<span class="line">     29</span> <span class="nop">           .          .           			for i, kptr := uintptr(0), b.keys(); i &lt; bucketCnt; i, kptr = i+1, add(kptr, 2*sys.PtrSize) { </span>
<span class="line">     30</span> <span class="nop">           .          .           				k := (*stringStruct)(kptr) </span>
<span class="line">     31</span> <span class="nop">           .          .           				if k.len != key.len || isEmpty(b.tophash[i]) { </span>
<span class="line">     32</span> <span class="nop">        10ms       10ms           					if b.tophash[i] == emptyRest { </span>
<span class="line">     33</span> <span class="nop">           .          .           						break </span>
<span class="line">     34</span> <span class="nop">           .          .           					} </span>
<span class="line">     35</span> <span class="nop">           .          .           					continue </span>
<span class="line">     36</span> <span class="nop">           .          .           				} </span>
<span class="line">     37</span> <span class="nop">           .          .           				if k.str == key.str || memequal(k.str, key.str, uintptr(key.len)) { </span>
<span class="line">     38</span> <span class="nop">           .          .           					return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)) </span>
<span class="line">     39</span> <span class="nop">           .          .           				} </span>
<span class="line">     40</span> <span class="nop">           .          .           			} </span>
<span class="line">     41</span> <span class="nop">           .          .           			return unsafe.Pointer(&amp;zeroVal[0]) </span>
<span class="line">     42</span> <span class="nop">           .          .           		} </span>
<span class="line">     43</span> <span class="nop">           .          .           		// long key, try not to do more comparisons than necessary </span>
<span class="line">     44</span> <span class="nop">           .          .           		keymaybe := uintptr(bucketCnt) </span>
<span class="line">     45</span> <span class="nop">           .          .           		for i, kptr := uintptr(0), b.keys(); i &lt; bucketCnt; i, kptr = i+1, add(kptr, 2*sys.PtrSize) { </span>
<span class="line">     46</span> <span class="nop">           .          .           			k := (*stringStruct)(kptr) </span>
<span class="line">     47</span> <span class="nop">           .          .           			if k.len != key.len || isEmpty(b.tophash[i]) { </span>
<span class="line">     48</span> <span class="nop">           .          .           				if b.tophash[i] == emptyRest { </span>
<span class="line">     49</span> <span class="nop">           .          .           					break </span>
<span class="line">     50</span> <span class="nop">           .          .           				} </span>
<span class="line">     51</span> <span class="nop">           .          .           				continue </span>
<span class="line">     52</span> <span class="nop">           .          .           			} </span>
<span class="line">     53</span> <span class="nop">           .          .           			if k.str == key.str { </span>
<span class="line">     54</span> <span class="nop">           .          .           				return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)) </span>
<span class="line">     55</span> <span class="nop">           .          .           			} </span>
<span class="line">     56</span> <span class="nop">           .          .           			// check first 4 bytes </span>
<span class="line">     57</span> <span class="nop">           .          .           			if *((*[4]byte)(key.str)) != *((*[4]byte)(k.str)) { </span>
<span class="line">     58</span> <span class="nop">           .          .           				continue </span>
<span class="line">     59</span> <span class="nop">           .          .           			} </span>
<span class="line">     60</span> <span class="nop">           .          .           			// check last 4 bytes </span>
<span class="line">     61</span> <span class="nop">           .          .           			if *((*[4]byte)(add(key.str, uintptr(key.len)-4))) != *((*[4]byte)(add(k.str, uintptr(key.len)-4))) { </span>
<span class="line">     62</span> <span class="nop">           .          .           				continue </span>
<span class="line">     63</span> <span class="nop">           .          .           			} </span>
<span class="line">     64</span> <span class="nop">           .          .           			if keymaybe != bucketCnt { </span>
<span class="line">     65</span> <span class="nop">           .          .           				// Two keys are potential matches. Use hash to distinguish them. </span>
<span class="line">     66</span> <span class="nop">           .          .           				goto dohash </span>
<span class="line">     67</span> <span class="nop">           .          .           			} </span>
<span class="line">     68</span> <span class="nop">           .          .           			keymaybe = i </span>
<span class="line">     69</span> <span class="nop">           .          .           		} </span>
<span class="line">     70</span> <span class="nop">           .          .           		if keymaybe != bucketCnt { </span>
<span class="line">     71</span> <span class="nop">           .          .           			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+keymaybe*2*sys.PtrSize)) </span>
<span class="line">     72</span> <span class="nop">           .          .           			if memequal(k.str, key.str, uintptr(key.len)) { </span>
<span class="line">     73</span> <span class="nop">           .          .           				return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+keymaybe*uintptr(t.valuesize)) </span>
<span class="line">     74</span> <span class="nop">           .          .           			} </span>
<span class="line">     75</span> <span class="nop">           .          .           		} </span>
<span class="line">     76</span> <span class="nop">           .          .           		return unsafe.Pointer(&amp;zeroVal[0]) </span>
<span class="line">     77</span> <span class="nop">           .          .           	} </span>
<span class="line">     78</span> <span class="nop">           .          .           dohash: </span>
<span class="line">     79</span> <span class="nop">        10ms       10ms           	hash := t.key.alg.hash(noescape(unsafe.Pointer(&amp;ky)), uintptr(h.hash0)) </span>
<span class="line">     80</span> <span class="nop">           .          .           	m := bucketMask(h.B) </span>
<span class="line">     81</span> <span class="nop">           .          .           	b := (*bmap)(add(h.buckets, (hash&amp;m)*uintptr(t.bucketsize))) </span>
<span class="line">     82</span> <span class="nop">           .          .           	if c := h.oldbuckets; c != nil { </span>
<span class="line">     83</span> <span class="nop">           .          .           		if !h.sameSizeGrow() { </span>
<span class="line">     84</span> <span class="nop">           .          .           			// There used to be half as many buckets; mask down one more power of two. </span>
</pre>
<h2>runtime.(*mcentral).cacheSpan</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mcentral.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms      120ms (flat, cum)  0.96%
<span class="line">     37</span> <span class="nop">           .          .           } </span>
<span class="line">     38</span> <span class="nop">           .          .            </span>
<span class="line">     39</span> <span class="nop">           .          .           // Allocate a span to use in an mcache. </span>
<span class="line">     40</span> <span class="nop">           .          .           func (c *mcentral) cacheSpan() *mspan { </span>
<span class="line">     41</span> <span class="nop">           .          .           	// Deduct credit for this span allocation and sweep if necessary. </span>
<span class="line">     42</span> <span class="nop">        10ms       10ms           	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize </span>
<span class="line">     43</span> <span class="nop">           .          .           	deductSweepCredit(spanBytes, 0) </span>
<span class="line">     44</span> <span class="nop">           .          .            </span>
<span class="line">     45</span> <span class="nop">           .          .           	lock(&amp;c.lock) </span>
<span class="line">     46</span> <span class="nop">           .          .           	traceDone := false </span>
<span class="line">     47</span> <span class="nop">           .          .           	if trace.enabled { </span>
<span class="line">     48</span> <span class="nop">           .          .           		traceGCSweepStart() </span>
<span class="line">     49</span> <span class="nop">           .          .           	} </span>
<span class="line">     50</span> <span class="nop">           .          .           	sg := mheap_.sweepgen </span>
<span class="line">     51</span> <span class="nop">           .          .           retry: </span>
<span class="line">     52</span> <span class="nop">           .          .           	var s *mspan </span>
<span class="line">     53</span> <span class="nop">           .          .           	for s = c.nonempty.first; s != nil; s = s.next { </span>
<span class="line">     54</span> <span class="nop">           .          .           		if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) { </span>
<span class="line">     55</span> <span class="nop">           .          .           			c.nonempty.remove(s) </span>
<span class="line">     56</span> <span class="nop">           .          .           			c.empty.insertBack(s) </span>
<span class="line">     57</span> <span class="nop">           .          .           			unlock(&amp;c.lock) </span>
<span class="line">     58</span> <span class="nop">           .          .           			s.sweep(true) </span>
<span class="line">     59</span> <span class="nop">           .          .           			goto havespan </span>
<span class="line">     60</span> <span class="nop">           .          .           		} </span>
<span class="line">     61</span> <span class="nop">           .          .           		if s.sweepgen == sg-1 { </span>
<span class="line">     62</span> <span class="nop">           .          .           			// the span is being swept by background sweeper, skip </span>
<span class="line">     63</span> <span class="nop">           .          .           			continue </span>
<span class="line">     64</span> <span class="nop">           .          .           		} </span>
<span class="line">     65</span> <span class="nop">           .          .           		// we have a nonempty span that does not require sweeping, allocate from it </span>
<span class="line">     66</span> <span class="nop">           .          .           		c.nonempty.remove(s) </span>
<span class="line">     67</span> <span class="nop">           .          .           		c.empty.insertBack(s) </span>
<span class="line">     68</span> <span class="nop">           .          .           		unlock(&amp;c.lock) </span>
<span class="line">     69</span> <span class="nop">           .          .           		goto havespan </span>
<span class="line">     70</span> <span class="nop">           .          .           	} </span>
<span class="line">     71</span> <span class="nop">           .          .            </span>
<span class="line">     72</span> <span class="nop">           .          .           	for s = c.empty.first; s != nil; s = s.next { </span>
<span class="line">     73</span> <span class="nop">           .          .           		if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) { </span>
<span class="line">     74</span> <span class="nop">           .          .           			// we have an empty span that requires sweeping, </span>
<span class="line">     75</span> <span class="nop">           .          .           			// sweep it and see if we can free some space in it </span>
<span class="line">     76</span> <span class="nop">           .          .           			c.empty.remove(s) </span>
<span class="line">     77</span> <span class="nop">           .          .           			// swept spans are at the end of the list </span>
<span class="line">     78</span> <span class="nop">           .          .           			c.empty.insertBack(s) </span>
<span class="line">     79</span> <span class="nop">           .          .           			unlock(&amp;c.lock) </span>
<span class="line">     80</span> <span class="nop">           .          .           			s.sweep(true) </span>
<span class="line">     81</span> <span class="nop">           .          .           			freeIndex := s.nextFreeIndex() </span>
<span class="line">     82</span> <span class="nop">           .          .           			if freeIndex != s.nelems { </span>
<span class="line">     83</span> <span class="nop">           .          .           				s.freeindex = freeIndex </span>
<span class="line">     84</span> <span class="nop">           .          .           				goto havespan </span>
<span class="line">     85</span> <span class="nop">           .          .           			} </span>
<span class="line">     86</span> <span class="nop">           .          .           			lock(&amp;c.lock) </span>
<span class="line">     87</span> <span class="nop">           .          .           			// the span is still empty after sweep </span>
<span class="line">     88</span> <span class="nop">           .          .           			// it is already in the empty list, so just retry </span>
<span class="line">     89</span> <span class="nop">           .          .           			goto retry </span>
<span class="line">     90</span> <span class="nop">           .          .           		} </span>
<span class="line">     91</span> <span class="nop">        10ms       10ms           		if s.sweepgen == sg-1 { </span>
<span class="line">     92</span> <span class="nop">           .          .           			// the span is being swept by background sweeper, skip </span>
<span class="line">     93</span> <span class="nop">           .          .           			continue </span>
<span class="line">     94</span> <span class="nop">           .          .           		} </span>
<span class="line">     95</span> <span class="nop">           .          .           		// already swept empty span, </span>
<span class="line">     96</span> <span class="nop">           .          .           		// all subsequent ones must also be either swept or in process of sweeping </span>
<span class="line">     97</span> <span class="nop">           .          .           		break </span>
<span class="line">     98</span> <span class="nop">           .          .           	} </span>
<span class="line">     99</span> <span class="nop">           .          .           	if trace.enabled { </span>
<span class="line">    100</span> <span class="nop">           .          .           		traceGCSweepDone() </span>
<span class="line">    101</span> <span class="nop">           .          .           		traceDone = true </span>
<span class="line">    102</span> <span class="nop">           .          .           	} </span>
<span class="line">    103</span> <span class="nop">           .          .           	unlock(&amp;c.lock) </span>
<span class="line">    104</span> <span class="nop">           .          .            </span>
<span class="line">    105</span> <span class="nop">           .          .           	// Replenish central list if empty. </span>
<span class="line">    106</span> <span class="nop">           .       90ms           	s = c.grow() </span>
<span class="line">    107</span> <span class="nop">           .          .           	if s == nil { </span>
<span class="line">    108</span> <span class="nop">           .          .           		return nil </span>
<span class="line">    109</span> <span class="nop">           .          .           	} </span>
<span class="line">    110</span> <span class="nop">        10ms       10ms           	lock(&amp;c.lock) </span>
<span class="line">    111</span> <span class="nop">           .          .           	c.empty.insertBack(s) </span>
<span class="line">    112</span> <span class="nop">           .          .           	unlock(&amp;c.lock) </span>
<span class="line">    113</span> <span class="nop">           .          .            </span>
<span class="line">    114</span> <span class="nop">           .          .           	// At this point s is a non-empty span, queued at the end of the empty list, </span>
<span class="line">    115</span> <span class="nop">           .          .           	// c is unlocked. </span>
</pre>
<h2>runtime.(*mTreap).find</h2><p class="filename">C:\blockchainenv\Go\src\runtime\mgclarge.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">    299</span> <span class="nop">           .          .           // smallest span that can hold npages. If no span has at least npages </span>
<span class="line">    300</span> <span class="nop">           .          .           // it returns nil. </span>
<span class="line">    301</span> <span class="nop">           .          .           // This is slightly more complicated than a simple binary tree search </span>
<span class="line">    302</span> <span class="nop">           .          .           // since if an exact match is not found the next larger node is </span>
<span class="line">    303</span> <span class="nop">           .          .           // returned. </span>
<span class="line">    304</span> <span class="nop">        10ms       10ms           func (root *mTreap) find(npages uintptr) *treapNode { </span>
<span class="line">    305</span> <span class="nop">           .          .           	t := root.treap </span>
<span class="line">    306</span> <span class="nop">        10ms       10ms           	for t != nil { </span>
<span class="line">    307</span> <span class="nop">        10ms       10ms           		if t.spanKey == nil { </span>
<span class="line">    308</span> <span class="nop">           .          .           			throw("treap node with nil spanKey found") </span>
<span class="line">    309</span> <span class="nop">           .          .           		} </span>
<span class="line">    310</span> <span class="nop">           .          .           		if t.npagesKey &lt; npages { </span>
<span class="line">    311</span> <span class="nop">           .          .           			t = t.right </span>
<span class="line">    312</span> <span class="nop">           .          .           		} else if t.left != nil &amp;&amp; t.left.npagesKey &gt;= npages { </span>
</pre>
<h2>runtime.stdcall2</h2><p class="filename">C:\blockchainenv\Go\src\runtime\os_windows.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">    779</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    780</span> <span class="nop">           .          .           func stdcall2(fn stdFunction, a0, a1 uintptr) uintptr { </span>
<span class="line">    781</span> <span class="nop">           .          .           	mp := getg().m </span>
<span class="line">    782</span> <span class="nop">           .          .           	mp.libcall.n = 2 </span>
<span class="line">    783</span> <span class="nop">           .          .           	mp.libcall.args = uintptr(noescape(unsafe.Pointer(&amp;a0))) </span>
<span class="line">    784</span> <span class="nop">        30ms       30ms           	return stdcall(fn) </span>
<span class="line">    785</span> <span class="nop">           .          .           } </span>
<span class="line">    786</span> <span class="nop">           .          .            </span>
<span class="line">    787</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    788</span> <span class="nop">           .          .           func stdcall3(fn stdFunction, a0, a1, a2 uintptr) uintptr { </span>
<span class="line">    789</span> <span class="nop">           .          .           	mp := getg().m </span>
</pre>
<h2>runtime.stdcall4</h2><p class="filename">C:\blockchainenv\Go\src\runtime\os_windows.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">    795</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    796</span> <span class="nop">           .          .           func stdcall4(fn stdFunction, a0, a1, a2, a3 uintptr) uintptr { </span>
<span class="line">    797</span> <span class="nop">           .          .           	mp := getg().m </span>
<span class="line">    798</span> <span class="nop">           .          .           	mp.libcall.n = 4 </span>
<span class="line">    799</span> <span class="nop">           .          .           	mp.libcall.args = uintptr(noescape(unsafe.Pointer(&amp;a0))) </span>
<span class="line">    800</span> <span class="nop">        30ms       30ms           	return stdcall(fn) </span>
<span class="line">    801</span> <span class="nop">           .          .           } </span>
<span class="line">    802</span> <span class="nop">           .          .            </span>
<span class="line">    803</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    804</span> <span class="nop">           .          .           func stdcall5(fn stdFunction, a0, a1, a2, a3, a4 uintptr) uintptr { </span>
<span class="line">    805</span> <span class="nop">           .          .           	mp := getg().m </span>
</pre>
<h2>runtime.deferreturn</h2><p class="filename">C:\blockchainenv\Go\src\runtime\panic.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       50ms (flat, cum)   0.4%
<span class="line">    340</span> <span class="nop">           .          .           // call the deferred function. </span>
<span class="line">    341</span> <span class="nop">           .          .            </span>
<span class="line">    342</span> <span class="nop">           .          .           // The single argument isn't actually used - it just has its address </span>
<span class="line">    343</span> <span class="nop">           .          .           // taken so it can be matched against pending defers. </span>
<span class="line">    344</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    345</span> <span class="nop">        10ms       10ms           func deferreturn(arg0 uintptr) { </span>
<span class="line">    346</span> <span class="nop">           .          .           	gp := getg() </span>
<span class="line">    347</span> <span class="nop">           .          .           	d := gp._defer </span>
<span class="line">    348</span> <span class="nop">           .          .           	if d == nil { </span>
<span class="line">    349</span> <span class="nop">           .          .           		return </span>
<span class="line">    350</span> <span class="nop">           .          .           	} </span>
<span class="line">    351</span> <span class="nop">           .          .           	sp := getcallersp() </span>
<span class="line">    352</span> <span class="nop">           .          .           	if d.sp != sp { </span>
<span class="line">    353</span> <span class="nop">        10ms       10ms           		return </span>
<span class="line">    354</span> <span class="nop">           .          .           	} </span>
<span class="line">    355</span> <span class="nop">           .          .            </span>
<span class="line">    356</span> <span class="nop">           .          .           	// Moving arguments around. </span>
<span class="line">    357</span> <span class="nop">           .          .           	// </span>
<span class="line">    358</span> <span class="nop">           .          .           	// Everything called after this point must be recursively </span>
<span class="line">    359</span> <span class="nop">           .          .           	// nosplit because the garbage collector won't know the form </span>
<span class="line">    360</span> <span class="nop">           .          .           	// of the arguments until the jmpdefer can flip the PC over to </span>
<span class="line">    361</span> <span class="nop">           .          .           	// fn. </span>
<span class="line">    362</span> <span class="nop">           .          .           	switch d.siz { </span>
<span class="line">    363</span> <span class="nop">        10ms       10ms           	case 0: </span>
<span class="line">    364</span> <span class="nop">           .          .           		// Do nothing. </span>
<span class="line">    365</span> <span class="nop">           .          .           	case sys.PtrSize: </span>
<span class="line">    366</span> <span class="nop">           .          .           		*(*uintptr)(unsafe.Pointer(&amp;arg0)) = *(*uintptr)(deferArgs(d)) </span>
<span class="line">    367</span> <span class="nop">           .          .           	default: </span>
<span class="line">    368</span> <span class="nop">           .          .           		memmove(unsafe.Pointer(&amp;arg0), deferArgs(d), uintptr(d.siz)) </span>
<span class="line">    369</span> <span class="nop">           .          .           	} </span>
<span class="line">    370</span> <span class="nop">           .          .           	fn := d.fn </span>
<span class="line">    371</span> <span class="nop">           .       10ms           	d.fn = nil </span>
<span class="line">    372</span> <span class="nop">           .          .           	gp._defer = d.link </span>
<span class="line">    373</span> <span class="nop">           .       10ms           	freedefer(d) </span>
<span class="line">    374</span> <span class="nop">           .          .           	jmpdefer(fn, uintptr(unsafe.Pointer(&amp;arg0))) </span>
<span class="line">    375</span> <span class="nop">           .          .           } </span>
<span class="line">    376</span> <span class="nop">           .          .            </span>
<span class="line">    377</span> <span class="nop">           .          .           // Goexit terminates the goroutine that calls it. No other goroutine is affected. </span>
<span class="line">    378</span> <span class="nop">           .          .           // Goexit runs all deferred calls before terminating the goroutine. Because Goexit </span>
</pre>
<h2>runtime.schedule</h2><p class="filename">C:\blockchainenv\Go\src\runtime\proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms      550ms (flat, cum)  4.40%
<span class="line">   2484</span> <span class="nop">           .          .           		throw("schedule: in cgo") </span>
<span class="line">   2485</span> <span class="nop">           .          .           	} </span>
<span class="line">   2486</span> <span class="nop">           .          .            </span>
<span class="line">   2487</span> <span class="nop">           .          .           top: </span>
<span class="line">   2488</span> <span class="nop">           .          .           	if sched.gcwaiting != 0 { </span>
<span class="line">   2489</span> <span class="nop">           .       20ms           		gcstopm() </span>
<span class="line">   2490</span> <span class="nop">           .          .           		goto top </span>
<span class="line">   2491</span> <span class="nop">           .          .           	} </span>
<span class="line">   2492</span> <span class="nop">           .          .           	if _g_.m.p.ptr().runSafePointFn != 0 { </span>
<span class="line">   2493</span> <span class="nop">           .       20ms           		runSafePointFn() </span>
<span class="line">   2494</span> <span class="nop">           .          .           	} </span>
<span class="line">   2495</span> <span class="nop">           .          .            </span>
<span class="line">   2496</span> <span class="nop">           .          .           	var gp *g </span>
<span class="line">   2497</span> <span class="nop">           .          .           	var inheritTime bool </span>
<span class="line">   2498</span> <span class="nop">           .          .           	if trace.enabled || trace.shutdown { </span>
<span class="line">   2499</span> <span class="nop">           .          .           		gp = traceReader() </span>
<span class="line">   2500</span> <span class="nop">           .          .           		if gp != nil { </span>
<span class="line">   2501</span> <span class="nop">           .          .           			casgstatus(gp, _Gwaiting, _Grunnable) </span>
<span class="line">   2502</span> <span class="nop">           .          .           			traceGoUnpark(gp, 0) </span>
<span class="line">   2503</span> <span class="nop">           .          .           		} </span>
<span class="line">   2504</span> <span class="nop">           .          .           	} </span>
<span class="line">   2505</span> <span class="nop">           .          .           	if gp == nil &amp;&amp; gcBlackenEnabled != 0 { </span>
<span class="line">   2506</span> <span class="nop">           .          .           		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr()) </span>
<span class="line">   2507</span> <span class="nop">           .          .           	} </span>
<span class="line">   2508</span> <span class="nop">           .          .           	if gp == nil { </span>
<span class="line">   2509</span> <span class="nop">           .          .           		// Check the global runnable queue once in a while to ensure fairness. </span>
<span class="line">   2510</span> <span class="nop">           .          .           		// Otherwise two goroutines can completely occupy the local runqueue </span>
<span class="line">   2511</span> <span class="nop">           .          .           		// by constantly respawning each other. </span>
<span class="line">   2512</span> <span class="nop">        10ms       10ms           		if _g_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 { </span>
<span class="line">   2513</span> <span class="nop">           .          .           			lock(&amp;sched.lock) </span>
<span class="line">   2514</span> <span class="nop">           .          .           			gp = globrunqget(_g_.m.p.ptr(), 1) </span>
<span class="line">   2515</span> <span class="nop">           .          .           			unlock(&amp;sched.lock) </span>
<span class="line">   2516</span> <span class="nop">           .          .           		} </span>
<span class="line">   2517</span> <span class="nop">           .          .           	} </span>
<span class="line">   2518</span> <span class="nop">           .          .           	if gp == nil { </span>
<span class="line">   2519</span> <span class="nop">        10ms       40ms           		gp, inheritTime = runqget(_g_.m.p.ptr()) </span>
<span class="line">   2520</span> <span class="nop">           .          .           		if gp != nil &amp;&amp; _g_.m.spinning { </span>
<span class="line">   2521</span> <span class="nop">           .          .           			throw("schedule: spinning with local work") </span>
<span class="line">   2522</span> <span class="nop">           .          .           		} </span>
<span class="line">   2523</span> <span class="nop">           .          .           	} </span>
<span class="line">   2524</span> <span class="nop">           .          .           	if gp == nil { </span>
<span class="line">   2525</span> <span class="nop">           .      410ms           		gp, inheritTime = findrunnable() // blocks until work is available </span>
<span class="line">   2526</span> <span class="nop">           .          .           	} </span>
<span class="line">   2527</span> <span class="nop">           .          .            </span>
<span class="line">   2528</span> <span class="nop">           .          .           	// This thread is going to run a goroutine and is not spinning anymore, </span>
<span class="line">   2529</span> <span class="nop">           .          .           	// so if it was marked as spinning we need to reset it now and potentially </span>
<span class="line">   2530</span> <span class="nop">           .          .           	// start a new spinning M. </span>
<span class="line">   2531</span> <span class="nop">           .          .           	if _g_.m.spinning { </span>
<span class="line">   2532</span> <span class="nop">           .       30ms           		resetspinning() </span>
<span class="line">   2533</span> <span class="nop">           .          .           	} </span>
<span class="line">   2534</span> <span class="nop">           .          .            </span>
<span class="line">   2535</span> <span class="nop">           .          .           	if sched.disable.user &amp;&amp; !schedEnabled(gp) { </span>
<span class="line">   2536</span> <span class="nop">           .          .           		// Scheduling of this goroutine is disabled. Put it on </span>
<span class="line">   2537</span> <span class="nop">           .          .           		// the list of pending runnable goroutines for when we </span>
<span class="line">   2538</span> <span class="nop">           .          .           		// re-enable user scheduling and look again. </span>
<span class="line">   2539</span> <span class="nop">           .          .           		lock(&amp;sched.lock) </span>
<span class="line">   2540</span> <span class="nop">           .          .           		if schedEnabled(gp) { </span>
<span class="line">   2541</span> <span class="nop">           .          .           			// Something re-enabled scheduling while we </span>
<span class="line">   2542</span> <span class="nop">           .          .           			// were acquiring the lock. </span>
<span class="line">   2543</span> <span class="nop">           .          .           			unlock(&amp;sched.lock) </span>
<span class="line">   2544</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   2545</span> <span class="nop">           .          .           			sched.disable.runnable.pushBack(gp) </span>
<span class="line">   2546</span> <span class="nop">           .          .           			sched.disable.n++ </span>
<span class="line">   2547</span> <span class="nop">           .          .           			unlock(&amp;sched.lock) </span>
<span class="line">   2548</span> <span class="nop">           .          .           			goto top </span>
<span class="line">   2549</span> <span class="nop">           .          .           		} </span>
<span class="line">   2550</span> <span class="nop">           .          .           	} </span>
<span class="line">   2551</span> <span class="nop">           .          .            </span>
<span class="line">   2552</span> <span class="nop">        10ms       10ms           	if gp.lockedm != 0 { </span>
<span class="line">   2553</span> <span class="nop">           .          .           		// Hands off own p to the locked m, </span>
<span class="line">   2554</span> <span class="nop">           .          .           		// then blocks waiting for a new p. </span>
<span class="line">   2555</span> <span class="nop">           .          .           		startlockedm(gp) </span>
<span class="line">   2556</span> <span class="nop">           .          .           		goto top </span>
<span class="line">   2557</span> <span class="nop">           .          .           	} </span>
<span class="line">   2558</span> <span class="nop">           .          .            </span>
<span class="line">   2559</span> <span class="nop">           .       10ms           	execute(gp, inheritTime) </span>
<span class="line">   2560</span> <span class="nop">           .          .           } </span>
<span class="line">   2561</span> <span class="nop">           .          .            </span>
<span class="line">   2562</span> <span class="nop">           .          .           // dropg removes the association between m and the current goroutine m-&gt;curg (gp for short). </span>
<span class="line">   2563</span> <span class="nop">           .          .           // Typically a caller sets gp's status away from Grunning and then </span>
<span class="line">   2564</span> <span class="nop">           .          .           // immediately calls dropg to finish the job. The caller is also responsible </span>
</pre>
<h2>runtime.mcall</h2><p class="filename">C:\blockchainenv\Go\src\runtime\asm_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms      600ms (flat, cum)  4.80%
<span class="line">    272</span> <span class="nop">           .          .           // Fn must never return. It should gogo(&amp;g-&gt;sched) </span>
<span class="line">    273</span> <span class="nop">           .          .           // to keep running g. </span>
<span class="line">    274</span> <span class="nop">           .          .           TEXT runtime·mcall(SB), NOSPLIT, $0-8 </span>
<span class="line">    275</span> <span class="nop">           .          .           	MOVQ	fn+0(FP), DI </span>
<span class="line">    276</span> <span class="nop">           .          .            </span>
<span class="line">    277</span> <span class="nop">        10ms       10ms           	get_tls(CX) </span>
<span class="line">    278</span> <span class="nop">           .          .           	MOVQ	g(CX), AX	// save state in g-&gt;sched </span>
<span class="line">    279</span> <span class="nop">           .          .           	MOVQ	0(SP), BX	// caller's PC </span>
<span class="line">    280</span> <span class="nop">           .          .           	MOVQ	BX, (g_sched+gobuf_pc)(AX) </span>
<span class="line">    281</span> <span class="nop">           .          .           	LEAQ	fn+0(FP), BX	// caller's SP </span>
<span class="line">    282</span> <span class="nop">           .          .           	MOVQ	BX, (g_sched+gobuf_sp)(AX) </span>
<span class="line">    283</span> <span class="nop">           .          .           	MOVQ	AX, (g_sched+gobuf_g)(AX) </span>
<span class="line">    284</span> <span class="nop">           .          .           	MOVQ	BP, (g_sched+gobuf_bp)(AX) </span>
<span class="line">    285</span> <span class="nop">           .          .            </span>
<span class="line">    286</span> <span class="nop">           .          .           	// switch to m-&gt;g0 &amp; its stack, call fn </span>
<span class="line">    287</span> <span class="nop">           .          .           	MOVQ	g(CX), BX </span>
<span class="line">    288</span> <span class="nop">           .          .           	MOVQ	g_m(BX), BX </span>
<span class="line">    289</span> <span class="nop">           .          .           	MOVQ	m_g0(BX), SI </span>
<span class="line">    290</span> <span class="nop">           .          .           	CMPQ	SI, AX	// if g == m-&gt;g0 call badmcall </span>
<span class="line">    291</span> <span class="nop">           .          .           	JNE	3(PC) </span>
<span class="line">    292</span> <span class="nop">           .          .           	MOVQ	$runtime·badmcall(SB), AX </span>
<span class="line">    293</span> <span class="nop">           .          .           	JMP	AX </span>
<span class="line">    294</span> <span class="nop">           .          .           	MOVQ	SI, g(CX)	// g = m-&gt;g0 </span>
<span class="line">    295</span> <span class="nop">           .          .           	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&gt;g0-&gt;sched.sp </span>
<span class="line">    296</span> <span class="nop">           .          .           	PUSHQ	AX </span>
<span class="line">    297</span> <span class="nop">        10ms       10ms           	MOVQ	DI, DX </span>
<span class="line">    298</span> <span class="nop">           .          .           	MOVQ	0(DI), DI </span>
<span class="line">    299</span> <span class="nop">        10ms      580ms           	CALL	DI </span>
<span class="line">    300</span> <span class="nop">           .          .           	POPQ	AX </span>
<span class="line">    301</span> <span class="nop">           .          .           	MOVQ	$runtime·badmcall2(SB), AX </span>
<span class="line">    302</span> <span class="nop">           .          .           	JMP	AX </span>
<span class="line">    303</span> <span class="nop">           .          .           	RET </span>
<span class="line">    304</span> <span class="nop">           .          .            </span>
</pre>
<h2>runtime.procyield</h2><p class="filename">C:\blockchainenv\Go\src\runtime\asm_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">    545</span> <span class="nop">           .          .            </span>
<span class="line">    546</span> <span class="nop">           .          .           TEXT runtime·procyield(SB),NOSPLIT,$0-0 </span>
<span class="line">    547</span> <span class="nop">           .          .           	MOVL	cycles+0(FP), AX </span>
<span class="line">    548</span> <span class="nop">           .          .           again: </span>
<span class="line">    549</span> <span class="nop">           .          .           	PAUSE </span>
<span class="line">    550</span> <span class="nop">        30ms       30ms           	SUBL	$1, AX </span>
<span class="line">    551</span> <span class="nop">           .          .           	JNZ	again </span>
<span class="line">    552</span> <span class="nop">           .          .           	RET </span>
<span class="line">    553</span> <span class="nop">           .          .            </span>
<span class="line">    554</span> <span class="nop">           .          .            </span>
<span class="line">    555</span> <span class="nop">           .          .           TEXT ·publicationBarrier(SB),NOSPLIT,$0-0 </span>
</pre>
<h2>internal/bytealg.Cutover</h2><p class="filename">C:\blockchainenv\Go\src\internal\bytealg\index_amd64.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       30ms (flat, cum)  0.24%
<span class="line">     20</span> <span class="nop">           .          .           // before switching over to Index. </span>
<span class="line">     21</span> <span class="nop">           .          .           // n is the number of bytes processed so far. </span>
<span class="line">     22</span> <span class="nop">           .          .           // See the bytes.Index implementation for details. </span>
<span class="line">     23</span> <span class="nop">           .          .           func Cutover(n int) int { </span>
<span class="line">     24</span> <span class="nop">           .          .           	// 1 error per 8 characters, plus a few slop to start. </span>
<span class="line">     25</span> <span class="nop">        30ms       30ms           	return (n + 16) / 8 </span>
<span class="line">     26</span> <span class="nop">           .          .           } </span>
</pre>
<h2>bufio.(*Reader).fill</h2><p class="filename">C:\blockchainenv\Go\src\bufio\bufio.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms      2.20s (flat, cum) 17.59%
<span class="line">     81</span> <span class="nop">           .          .           } </span>
<span class="line">     82</span> <span class="nop">           .          .            </span>
<span class="line">     83</span> <span class="nop">           .          .           var errNegativeRead = errors.New("bufio: reader returned negative count from Read") </span>
<span class="line">     84</span> <span class="nop">           .          .            </span>
<span class="line">     85</span> <span class="nop">           .          .           // fill reads a new chunk into the buffer. </span>
<span class="line">     86</span> <span class="nop">        10ms       10ms           func (b *Reader) fill() { </span>
<span class="line">     87</span> <span class="nop">           .          .           	// Slide existing data to beginning. </span>
<span class="line">     88</span> <span class="nop">           .          .           	if b.r &gt; 0 { </span>
<span class="line">     89</span> <span class="nop">           .          .           		copy(b.buf, b.buf[b.r:b.w]) </span>
<span class="line">     90</span> <span class="nop">           .          .           		b.w -= b.r </span>
<span class="line">     91</span> <span class="nop">           .          .           		b.r = 0 </span>
<span class="line">     92</span> <span class="nop">           .          .           	} </span>
<span class="line">     93</span> <span class="nop">           .          .            </span>
<span class="line">     94</span> <span class="nop">           .          .           	if b.w &gt;= len(b.buf) { </span>
<span class="line">     95</span> <span class="nop">           .          .           		panic("bufio: tried to fill full buffer") </span>
<span class="line">     96</span> <span class="nop">           .          .           	} </span>
<span class="line">     97</span> <span class="nop">           .          .            </span>
<span class="line">     98</span> <span class="nop">           .          .           	// Read new data: try a limited number of times. </span>
<span class="line">     99</span> <span class="nop">           .          .           	for i := maxConsecutiveEmptyReads; i &gt; 0; i-- { </span>
<span class="line">    100</span> <span class="nop">        10ms      2.18s           		n, err := b.rd.Read(b.buf[b.w:]) </span>
<span class="line">    101</span> <span class="nop">           .          .           		if n &lt; 0 { </span>
<span class="line">    102</span> <span class="nop">           .          .           			panic(errNegativeRead) </span>
<span class="line">    103</span> <span class="nop">           .          .           		} </span>
<span class="line">    104</span> <span class="nop">           .          .           		b.w += n </span>
<span class="line">    105</span> <span class="nop">        10ms       10ms           		if err != nil { </span>
<span class="line">    106</span> <span class="nop">           .          .           			b.err = err </span>
<span class="line">    107</span> <span class="nop">           .          .           			return </span>
<span class="line">    108</span> <span class="nop">           .          .           		} </span>
<span class="line">    109</span> <span class="nop">           .          .           		if n &gt; 0 { </span>
<span class="line">    110</span> <span class="nop">           .          .           			return </span>
</pre>
<h2>compress/flate.(*huffmanDecoder).init</h2><p class="filename">C:\blockchainenv\Go\src\compress\flate\inflate.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:        30ms       50ms (flat, cum)   0.4%
<span class="line">    126</span> <span class="nop">           .          .           	// Count number of codes of each length, </span>
<span class="line">    127</span> <span class="nop">           .          .           	// compute min and max length. </span>
<span class="line">    128</span> <span class="nop">           .          .           	var count [maxCodeLen]int </span>
<span class="line">    129</span> <span class="nop">           .          .           	var min, max int </span>
<span class="line">    130</span> <span class="nop">           .          .           	for _, n := range lengths { </span>
<span class="line">    131</span> <span class="nop">        10ms       10ms           		if n == 0 { </span>
<span class="line">    132</span> <span class="nop">           .          .           			continue </span>
<span class="line">    133</span> <span class="nop">           .          .           		} </span>
<span class="line">    134</span> <span class="nop">           .          .           		if min == 0 || n &lt; min { </span>
<span class="line">    135</span> <span class="nop">           .          .           			min = n </span>
<span class="line">    136</span> <span class="nop">           .          .           		} </span>
<span class="line">    137</span> <span class="nop">           .          .           		if n &gt; max { </span>
<span class="line">    138</span> <span class="nop">           .          .           			max = n </span>
<span class="line">    139</span> <span class="nop">           .          .           		} </span>
<span class="line">    140</span> <span class="nop">           .          .           		count[n]++ </span>
<span class="line">    141</span> <span class="nop">           .          .           	} </span>
<span class="line">    142</span> <span class="nop">           .          .            </span>
<span class="line">    143</span> <span class="nop">           .          .           	// Empty tree. The decompressor.huffSym function will fail later if the tree </span>
<span class="line">    144</span> <span class="nop">           .          .           	// is used. Technically, an empty tree is only valid for the HDIST tree and </span>
<span class="line">    145</span> <span class="nop">           .          .           	// not the HCLEN and HLIT tree. However, a stream with an empty HCLEN tree </span>
<span class="line">    146</span> <span class="nop">           .          .           	// is guaranteed to fail since it will attempt to use the tree to decode the </span>
<span class="line">    147</span> <span class="nop">           .          .           	// codes for the HLIT and HDIST trees. Similarly, an empty HLIT tree is </span>
<span class="line">    148</span> <span class="nop">           .          .           	// guaranteed to fail later since the compressed data section must be </span>
<span class="line">    149</span> <span class="nop">           .          .           	// composed of at least one symbol (the end-of-block marker). </span>
<span class="line">    150</span> <span class="nop">           .          .           	if max == 0 { </span>
<span class="line">    151</span> <span class="nop">           .          .           		return true </span>
<span class="line">    152</span> <span class="nop">           .          .           	} </span>
<span class="line">    153</span> <span class="nop">           .          .            </span>
<span class="line">    154</span> <span class="nop">           .          .           	code := 0 </span>
<span class="line">    155</span> <span class="nop">           .          .           	var nextcode [maxCodeLen]int </span>
<span class="line">    156</span> <span class="nop">           .          .           	for i := min; i &lt;= max; i++ { </span>
<span class="line">    157</span> <span class="nop">           .          .           		code &lt;&lt;= 1 </span>
<span class="line">    158</span> <span class="nop">           .          .           		nextcode[i] = code </span>
<span class="line">    159</span> <span class="nop">           .          .           		code += count[i] </span>
<span class="line">    160</span> <span class="nop">           .          .           	} </span>
<span class="line">    161</span> <span class="nop">           .          .            </span>
<span class="line">    162</span> <span class="nop">           .          .           	// Check that the coding is complete (i.e., that we've </span>
<span class="line">    163</span> <span class="nop">           .          .           	// assigned all 2-to-the-max possible bit sequences). </span>
<span class="line">    164</span> <span class="nop">           .          .           	// Exception: To be compatible with zlib, we also need to </span>
<span class="line">    165</span> <span class="nop">           .          .           	// accept degenerate single-code codings. See also </span>
<span class="line">    166</span> <span class="nop">           .          .           	// TestDegenerateHuffmanCoding. </span>
<span class="line">    167</span> <span class="nop">           .          .           	if code != 1&lt;&lt;uint(max) &amp;&amp; !(code == 1 &amp;&amp; max == 1) { </span>
<span class="line">    168</span> <span class="nop">           .          .           		return false </span>
<span class="line">    169</span> <span class="nop">           .          .           	} </span>
<span class="line">    170</span> <span class="nop">           .          .            </span>
<span class="line">    171</span> <span class="nop">           .          .           	h.min = min </span>
<span class="line">    172</span> <span class="nop">           .          .           	if max &gt; huffmanChunkBits { </span>
<span class="line">    173</span> <span class="nop">           .          .           		numLinks := 1 &lt;&lt; (uint(max) - huffmanChunkBits) </span>
<span class="line">    174</span> <span class="nop">           .          .           		h.linkMask = uint32(numLinks - 1) </span>
<span class="line">    175</span> <span class="nop">           .          .            </span>
<span class="line">    176</span> <span class="nop">           .          .           		// create link tables </span>
<span class="line">    177</span> <span class="nop">           .          .           		link := nextcode[huffmanChunkBits+1] &gt;&gt; 1 </span>
<span class="line">    178</span> <span class="nop">           .       10ms           		h.links = make([][]uint32, huffmanNumChunks-link) </span>
<span class="line">    179</span> <span class="nop">           .          .           		for j := uint(link); j &lt; huffmanNumChunks; j++ { </span>
<span class="line">    180</span> <span class="nop">           .          .           			reverse := int(bits.Reverse16(uint16(j))) </span>
<span class="line">    181</span> <span class="nop">           .          .           			reverse &gt;&gt;= uint(16 - huffmanChunkBits) </span>
<span class="line">    182</span> <span class="nop">           .          .           			off := j - uint(link) </span>
<span class="line">    183</span> <span class="nop">           .          .           			if sanity &amp;&amp; h.chunks[reverse] != 0 { </span>
<span class="line">    184</span> <span class="nop">           .          .           				panic("impossible: overwriting existing chunk") </span>
<span class="line">    185</span> <span class="nop">           .          .           			} </span>
<span class="line">    186</span> <span class="nop">           .          .           			h.chunks[reverse] = uint32(off&lt;&lt;huffmanValueShift | (huffmanChunkBits + 1)) </span>
<span class="line">    187</span> <span class="nop">           .       10ms           			h.links[off] = make([]uint32, numLinks) </span>
<span class="line">    188</span> <span class="nop">           .          .           		} </span>
<span class="line">    189</span> <span class="nop">           .          .           	} </span>
<span class="line">    190</span> <span class="nop">           .          .            </span>
<span class="line">    191</span> <span class="nop">           .          .           	for i, n := range lengths { </span>
<span class="line">    192</span> <span class="nop">           .          .           		if n == 0 { </span>
<span class="line">    193</span> <span class="nop">           .          .           			continue </span>
<span class="line">    194</span> <span class="nop">           .          .           		} </span>
<span class="line">    195</span> <span class="nop">           .          .           		code := nextcode[n] </span>
<span class="line">    196</span> <span class="nop">           .          .           		nextcode[n]++ </span>
<span class="line">    197</span> <span class="nop">           .          .           		chunk := uint32(i&lt;&lt;huffmanValueShift | n) </span>
<span class="line">    198</span> <span class="nop">           .          .           		reverse := int(bits.Reverse16(uint16(code))) </span>
<span class="line">    199</span> <span class="nop">           .          .           		reverse &gt;&gt;= uint(16 - n) </span>
<span class="line">    200</span> <span class="nop">           .          .           		if n &lt;= huffmanChunkBits { </span>
<span class="line">    201</span> <span class="nop">        10ms       10ms           			for off := reverse; off &lt; len(h.chunks); off += 1 &lt;&lt; uint(n) { </span>
<span class="line">    202</span> <span class="nop">           .          .           				// We should never need to overwrite </span>
<span class="line">    203</span> <span class="nop">           .          .           				// an existing chunk. Also, 0 is </span>
<span class="line">    204</span> <span class="nop">           .          .           				// never a valid chunk, because the </span>
<span class="line">    205</span> <span class="nop">           .          .           				// lower 4 "count" bits should be </span>
<span class="line">    206</span> <span class="nop">           .          .           				// between 1 and 15. </span>
<span class="line">    207</span> <span class="nop">           .          .           				if sanity &amp;&amp; h.chunks[off] != 0 { </span>
<span class="line">    208</span> <span class="nop">           .          .           					panic("impossible: overwriting existing chunk") </span>
<span class="line">    209</span> <span class="nop">           .          .           				} </span>
<span class="line">    210</span> <span class="nop">        10ms       10ms           				h.chunks[off] = chunk </span>
<span class="line">    211</span> <span class="nop">           .          .           			} </span>
<span class="line">    212</span> <span class="nop">           .          .           		} else { </span>
<span class="line">    213</span> <span class="nop">           .          .           			j := reverse &amp; (huffmanNumChunks - 1) </span>
<span class="line">    214</span> <span class="nop">           .          .           			if sanity &amp;&amp; h.chunks[j]&amp;huffmanCountMask != huffmanChunkBits+1 { </span>
<span class="line">    215</span> <span class="nop">           .          .           				// Longer codes should have been </span>
</pre>

  </div>
  
<script>


function initPanAndZoom(svg, clickHandler) {
  'use strict';

  
  const IDLE = 0;
  const MOUSEPAN = 1;
  const TOUCHPAN = 2;
  const TOUCHZOOM = 3;
  let mode = IDLE;

  
  let currentScale = 1.0;
  const initWidth = svg.viewBox.baseVal.width;
  const initHeight = svg.viewBox.baseVal.height;

  
  let panLastX = 0;      
  let panLastY = 0;      
  let moved = false;     
  let touchid = null;    

  
  let touchid2 = null;     
  let initGap = 1.0;       
  let initScale = 1.0;     
  let centerPoint = null;  

  
  function toSvg(x, y) {
    const p = svg.createSVGPoint();
    p.x = x;
    p.y = y;
    let m = svg.getCTM();
    if (m == null) m = svg.getScreenCTM(); 
    return p.matrixTransform(m.inverse());
  }

  
  
  function rescale(s, u) {
    
    if (s < 0.2) s = 0.2;
    if (s > 10.0) s = 10.0;

    currentScale = s;

    
    
    
    const vb = svg.viewBox;
    const w1 = vb.baseVal.width;
    const w2 = initWidth / s;
    const h1 = vb.baseVal.height;
    const h2 = initHeight / s;
    vb.baseVal.width = w2;
    vb.baseVal.height = h2;

    
    
    
    
    
    
    
    vb.baseVal.x = u.x - (u.x - vb.baseVal.x) * (w2 / w1);
    vb.baseVal.y = u.y - (u.y - vb.baseVal.y) * (h2 / h1);
  }

  function handleWheel(e) {
    if (e.deltaY == 0) return;
    
    rescale(currentScale * (e.deltaY < 0 ? 1.1 : (1/1.1)),
            toSvg(e.offsetX, e.offsetY));
  }

  function setMode(m) {
    mode = m;
    touchid = null;
    touchid2 = null;
  }

  function panStart(x, y) {
    moved = false;
    panLastX = x;
    panLastY = y;
  }

  function panMove(x, y) {
    let dx = x - panLastX;
    let dy = y - panLastY;
    if (Math.abs(dx) <= 2 && Math.abs(dy) <= 2) return; 

    moved = true;
    panLastX = x;
    panLastY = y;

    
    const swidth = svg.clientWidth || svg.parentNode.clientWidth;
    const sheight = svg.clientHeight || svg.parentNode.clientHeight;

    
    dx *= (svg.viewBox.baseVal.width / swidth);
    dy *= (svg.viewBox.baseVal.height / sheight);

    svg.viewBox.baseVal.x -= dx;
    svg.viewBox.baseVal.y -= dy;
  }

  function handleScanStart(e) {
    if (e.button != 0) return; 
    setMode(MOUSEPAN);
    panStart(e.clientX, e.clientY);
    e.preventDefault();
    svg.addEventListener('mousemove', handleScanMove);
  }

  function handleScanMove(e) {
    if (e.buttons == 0) {
      
      setMode(IDLE);
      svg.removeEventListener('mousemove', handleScanMove);
      return;
    }
    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
  }

  function handleScanEnd(e) {
    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
    setMode(IDLE);
    svg.removeEventListener('mousemove', handleScanMove);
    if (!moved) clickHandler(e.target);
  }

  
  function findTouch(tlist, id) {
    for (const t of tlist) {
      if (t.identifier == id) return t;
    }
    return null;
  }

  
  function touchGap(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx, dy);
  }

  function handleTouchStart(e) {
    if (mode == IDLE && e.changedTouches.length == 1) {
      
      const t = e.changedTouches[0];
      setMode(TOUCHPAN);
      touchid = t.identifier;
      panStart(t.clientX, t.clientY);
      e.preventDefault();
    } else if (mode == TOUCHPAN && e.touches.length == 2) {
      
      setMode(TOUCHZOOM);
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      touchid = t1.identifier;
      touchid2 = t2.identifier;
      initScale = currentScale;
      initGap = touchGap(t1, t2);
      centerPoint = toSvg((t1.clientX + t2.clientX) / 2,
                          (t1.clientY + t2.clientY) / 2);
      e.preventDefault();
    }
  }

  function handleTouchMove(e) {
    if (mode == TOUCHPAN) {
      const t = findTouch(e.changedTouches, touchid);
      if (t == null) return;
      if (e.touches.length != 1) {
        setMode(IDLE);
        return;
      }
      panMove(t.clientX, t.clientY);
      e.preventDefault();
    } else if (mode == TOUCHZOOM) {
      
      const t1 = findTouch(e.touches, touchid);
      const t2 = findTouch(e.touches, touchid2);
      if (t1 == null || t2 == null) return;
      const gap = touchGap(t1, t2);
      rescale(initScale * gap / initGap, centerPoint);
      e.preventDefault();
    }
  }

  function handleTouchEnd(e) {
    if (mode == TOUCHPAN) {
      const t = findTouch(e.changedTouches, touchid);
      if (t == null) return;
      panMove(t.clientX, t.clientY);
      setMode(IDLE);
      e.preventDefault();
      if (!moved) clickHandler(t.target);
    } else if (mode == TOUCHZOOM) {
      setMode(IDLE);
      e.preventDefault();
    }
  }

  svg.addEventListener('mousedown', handleScanStart);
  svg.addEventListener('mouseup', handleScanEnd);
  svg.addEventListener('touchstart', handleTouchStart);
  svg.addEventListener('touchmove', handleTouchMove);
  svg.addEventListener('touchend', handleTouchEnd);
  svg.addEventListener('wheel', handleWheel, true);
}

function initMenus() {
  'use strict';

  let activeMenu = null;
  let activeMenuHdr = null;

  function cancelActiveMenu() {
    if (activeMenu == null) return;
    activeMenu.style.display = 'none';
    activeMenu = null;
    activeMenuHdr = null;
  }

  
  for (const menu of document.getElementsByClassName('submenu')) {
    const hdr = menu.parentElement;
    if (hdr == null) return;
    if (hdr.classList.contains('disabled')) return;
    function showMenu(e) {
      
      
      if (e.target.parentElement != hdr) return;
      activeMenu = menu;
      activeMenuHdr = hdr;
      menu.style.display = 'block';
    }
    hdr.addEventListener('mousedown', showMenu);
    hdr.addEventListener('touchstart', showMenu);
  }

  
  for (const t of ['mousedown', 'touchstart']) {
    document.addEventListener(t, (e) => {
      
      
      if (activeMenuHdr != e.target.closest('.menu-item')) {
        cancelActiveMenu();
      }
    }, { passive: true, capture: true });
  }

  
  document.addEventListener('mouseup', (e) => {
    if (activeMenu == e.target.closest('.submenu')) {
      cancelActiveMenu();
    }
  }, { passive: true, capture: true });
}

function viewer(baseUrl, nodes) {
  'use strict';

  
  const search = document.getElementById('search');
  const graph0 = document.getElementById('graph0');
  const svg = (graph0 == null ? null : graph0.parentElement);
  const toptable = document.getElementById('toptable');

  let regexpActive = false;
  let selected = new Map();
  let origFill = new Map();
  let searchAlarm = null;
  let buttonsEnabled = true;

  function handleDetails(e) {
    e.preventDefault();
    const detailsText = document.getElementById('detailsbox');
    if (detailsText != null) {
      if (detailsText.style.display === 'block') {
        detailsText.style.display = 'none';
      } else {
        detailsText.style.display = 'block';
      }
    }
  }

  function handleKey(e) {
    if (e.keyCode != 13) return;
    window.location.href =
        updateUrl(new URL(window.location.href), 'f');
    e.preventDefault();
  }

  function handleSearch() {
    
    if (searchAlarm != null) {
      clearTimeout(searchAlarm);
    }
    searchAlarm = setTimeout(selectMatching, 300);

    regexpActive = true;
    updateButtons();
  }

  function selectMatching() {
    searchAlarm = null;
    let re = null;
    if (search.value != '') {
      try {
        re = new RegExp(search.value);
      } catch (e) {
        
        return;
      }
    }

    function match(text) {
      return re != null && re.test(text);
    }

    
    selected.forEach(function(v, n) {
      if (!match(nodes[n])) {
        unselect(n, document.getElementById('node' + n));
      }
    })

    
    for (let n = 0; n < nodes.length; n++) {
      if (!selected.has(n) && match(nodes[n])) {
        select(n, document.getElementById('node' + n));
      }
    }

    updateButtons();
  }

  function toggleSvgSelect(elem) {
    
    while (elem != null && elem.parentElement != graph0) {
      elem = elem.parentElement;
    }
    if (!elem) return;

    
    regexpActive = false;

    const n = nodeId(elem);
    if (n < 0) return;
    if (selected.has(n)) {
      unselect(n, elem);
    } else {
      select(n, elem);
    }
    updateButtons();
  }

  function unselect(n, elem) {
    if (elem == null) return;
    selected.delete(n);
    setBackground(elem, false);
  }

  function select(n, elem) {
    if (elem == null) return;
    selected.set(n, true);
    setBackground(elem, true);
  }

  function nodeId(elem) {
    const id = elem.id;
    if (!id) return -1;
    if (!id.startsWith('node')) return -1;
    const n = parseInt(id.slice(4), 10);
    if (isNaN(n)) return -1;
    if (n < 0 || n >= nodes.length) return -1;
    return n;
  }

  function setBackground(elem, set) {
    
    if (elem.nodeName == 'TR') {
      elem.classList.toggle('hilite', set);
      return;
    }

    
    const p = findPolygon(elem);
    if (p != null) {
      if (set) {
        origFill.set(p, p.style.fill);
        p.style.fill = '#ccccff';
      } else if (origFill.has(p)) {
        p.style.fill = origFill.get(p);
      }
    }
  }

  function findPolygon(elem) {
    if (elem.localName == 'polygon') return elem;
    for (const c of elem.children) {
      const p = findPolygon(c);
      if (p != null) return p;
    }
    return null;
  }

  
  function quotemeta(str) {
    return str.replace(/([\\\.?+*\[\](){}|^$])/g, '\\$1');
  }

  function setSampleIndexLink(id) {
    const elem = document.getElementById(id);
    if (elem != null) {
      setHrefParams(elem, function (params) {
        params.set("si", id);
      });
    }
  }

  
  
  function makeSearchLinkDynamic(id) {
    const elem = document.getElementById(id);
    if (elem == null) return;

    
    
    let param = 'f';
    if (id == 'ignore') param = 'i';
    if (id == 'hide') param = 'h';
    if (id == 'show') param = 's';
    if (id == 'show-from') param = 'sf';

    
    elem.addEventListener('mouseenter', updater);
    elem.addEventListener('touchstart', updater);

    function updater() {
      
      
      let re = regexpActive
        ? search.value
        : Array.from(selected.keys()).map(key => quotemeta(nodes[key])).join('|');

      setHrefParams(elem, function (params) {
        if (re != '') {
          
          if (param != 'f' && param != 's' && param != 'sf' && params.has(param)) {
            const old = params.get(param);
            if (old != '') {
              re += '|' + old;
            }
          }
          params.set(param, re);
        } else {
          params.delete(param);
        }
      });
    }
  }

  function setHrefParams(elem, paramSetter) {
    let url = new URL(elem.href);
    url.hash = '';

    
    const params = url.searchParams;
    for (const p of new URLSearchParams(window.location.search)) {
      params.set(p[0], p[1]);
    }

    
    paramSetter(params);

    elem.href = url.toString();
  }

  function handleTopClick(e) {
    
    let elem = e.target;
    while (elem != null && elem.nodeName != 'TR') {
      elem = elem.parentElement;
    }
    if (elem == null || elem.children.length < 6) return;

    e.preventDefault();
    const tr = elem;
    const td = elem.children[5];
    if (td.nodeName != 'TD') return;
    const name = td.innerText;
    const index = nodes.indexOf(name);
    if (index < 0) return;

    
    regexpActive = false;

    if (selected.has(index)) {
      unselect(index, elem);
    } else {
      select(index, elem);
    }
    updateButtons();
  }

  function updateButtons() {
    const enable = (search.value != '' || selected.size != 0);
    if (buttonsEnabled == enable) return;
    buttonsEnabled = enable;
    for (const id of ['focus', 'ignore', 'hide', 'show', 'show-from']) {
      const link = document.getElementById(id);
      if (link != null) {
        link.classList.toggle('disabled', !enable);
      }
    }
  }

  
  updateButtons();

  
  initMenus();
  if (svg != null) {
    initPanAndZoom(svg, toggleSvgSelect);
  }
  if (toptable != null) {
    toptable.addEventListener('mousedown', handleTopClick);
    toptable.addEventListener('touchstart', handleTopClick);
  }

  const ids = ['topbtn', 'graphbtn', 'peek', 'list', 'disasm',
               'focus', 'ignore', 'hide', 'show', 'show-from'];
  ids.forEach(makeSearchLinkDynamic);

  const sampleIDs = ['samples', 'cpu', ];
  sampleIDs.forEach(setSampleIndexLink);

  
  function addAction(id, action) {
    const btn = document.getElementById(id);
    if (btn != null) {
      btn.addEventListener('click', action);
      btn.addEventListener('touchstart', action);
    }
  }

  addAction('details', handleDetails);

  search.addEventListener('input', handleSearch);
  search.addEventListener('keydown', handleKey);

  
  const main = document.getElementById('bodycontainer');
  if (main) {
    main.focus();
  }
}
</script>

  <script>viewer(new URL(window.location.href), null);</script>


</body></html>